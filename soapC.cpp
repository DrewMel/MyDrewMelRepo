/* soapC.cpp
   Generated by gSOAP 2.8.111 for .\testbench.h

gSOAP XML Web services tools
Copyright (C) 2000-2021, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC.cpp ver 2.8.111 2021-02-12 14:37:47 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", soap->header, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->version && soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, ""))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->version && soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (soap->header == NULL)
	{	if ((soap->header = soap_new_SOAP_ENV__Header(soap)))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (soap->fault == NULL)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
		if (soap->fault == NULL)
			return;
	}
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code == NULL)
		soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Reason == NULL)
		soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", "");
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault == NULL)
		return NULL;
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault == NULL)
		return NULL;
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
	{	if (soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode == NULL)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
			if (soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode == NULL)
				return NULL;
		}
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_fault_subcode(struct soap *soap)
{
	const char **s = soap_faultsubcode(soap);
	return s ? *s : NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault == NULL)
		return NULL;
	if (soap->version == 2 && soap->fault->SOAP_ENV__Reason)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)(void*)&soap->fault->faultstring;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_fault_string(struct soap *soap)
{
	const char **s = soap_faultstring(soap);
	return s ? *s : NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault == NULL)
		return NULL;
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Detail == NULL)
			soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
		return (const char**)(void*)&soap->fault->SOAP_ENV__Detail->__any;
	}
	if (soap->fault->detail == NULL)
		soap->fault->detail = soap_new_SOAP_ENV__Detail(soap, -1);
	return (const char**)(void*)&soap->fault->detail->__any;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_fault_detail(struct soap *soap)
{
	const char **s = soap_faultdetail(soap);
	return s ? *s : NULL;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, NULL, &t))
				if ((soap->error && soap->error != SOAP_TAG_MISMATCH) || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, const char *tag, int *type)
{	(void)type;
	if (soap_peek_element(soap))
		return NULL;
#ifndef WITH_NOIDREF
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, tag, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, tag, NULL, "xsd:int");
	case SOAP_TYPE_double:
		return soap_in_double(soap, tag, NULL, "xsd:double");
	case SOAP_TYPE_bool:
		return soap_in_bool(soap, tag, NULL, "xsd:boolean");
	case SOAP_TYPE_ns3__TPulseCheck:
		return soap_in_ns3__TPulseCheck(soap, tag, NULL, "ns3:TPulseCheck");
	case SOAP_TYPE_ns3__TStatusCode:
		return soap_in_ns3__TStatusCode(soap, tag, NULL, "ns3:TStatusCode");
	case SOAP_TYPE_ns3__TMeterIndicationMethod:
		return soap_in_ns3__TMeterIndicationMethod(soap, tag, NULL, "ns3:TMeterIndicationMethod");
	case SOAP_TYPE_ns3__TProofMethod:
		return soap_in_ns3__TProofMethod(soap, tag, NULL, "ns3:TProofMethod");
	case SOAP_TYPE_ns3__TResult:
		return soap_in_ns3__TResult(soap, tag, NULL, "ns3:TResult");
	case SOAP_TYPE_std__string:
		return soap_in_std__string(soap, tag, NULL, "xsd:string");
	case SOAP_TYPE_ns3__TPressTestResult:
		return soap_in_ns3__TPressTestResult(soap, tag, NULL, "ns3:TPressTestResult");
	case SOAP_TYPE_ns3__TTestResult:
		return soap_in_ns3__TTestResult(soap, tag, NULL, "ns3:TTestResult");
	case SOAP_TYPE_ns3__TMeterResult:
		return soap_in_ns3__TMeterResult(soap, tag, NULL, "ns3:TMeterResult");
	case SOAP_TYPE_TMeterResults:
		return soap_in_TMeterResults(soap, tag, NULL, "ns3:TMeterResult");
	case SOAP_TYPE_ns3__TTestResults:
		return soap_in_ns3__TTestResults(soap, tag, NULL, "ns3:TTestResults");
	case SOAP_TYPE_ns3__TMeasurementData:
		return soap_in_ns3__TMeasurementData(soap, tag, NULL, "ns3:TMeasurementData");
	case SOAP_TYPE_ns3__TMeterIndication:
		return soap_in_ns3__TMeterIndication(soap, tag, NULL, "ns3:TMeterIndication");
	case SOAP_TYPE_TMeterIndications:
		return soap_in_TMeterIndications(soap, tag, NULL, "ns3:TMeterIndication");
	case SOAP_TYPE_ns3__TMeterData:
		return soap_in_ns3__TMeterData(soap, tag, NULL, "ns3:TMeterData");
	case SOAP_TYPE_TMetersData:
		return soap_in_TMetersData(soap, tag, NULL, "ns3:TMeterData");
	case SOAP_TYPE_ns3__TStatus:
		return soap_in_ns3__TStatus(soap, tag, NULL, "ns3:TStatus");
	case SOAP_TYPE_ns3__TWaitEvents:
		return soap_in_ns3__TWaitEvents(soap, tag, NULL, "ns3:TWaitEvents");
	case SOAP_TYPE_ns3__TPressTestParameters:
		return soap_in_ns3__TPressTestParameters(soap, tag, NULL, "ns3:TPressTestParameters");
	case SOAP_TYPE_ns3__TTestParameters:
		return soap_in_ns3__TTestParameters(soap, tag, NULL, "ns3:TTestParameters");
	case SOAP_TYPE_TBooleanDynArray:
		return soap_in_TBooleanDynArray(soap, tag, NULL, "xsd:boolean");
	case SOAP_TYPE_TIntegerDynArray:
		return soap_in_TIntegerDynArray(soap, tag, NULL, "xsd:int");
	case SOAP_TYPE_TStringDynArray:
		return soap_in_TStringDynArray(soap, tag, NULL, "xsd:string");
	case SOAP_TYPE_SOAP_ENC__Array:
		return soap_in_SOAP_ENC__Array(soap, tag, NULL, "SOAP-ENC:Array");
	case SOAP_TYPE_ns4__SetTestConfiguration:
		return soap_in_ns4__SetTestConfiguration(soap, tag, NULL, "ns4:SetTestConfiguration");
	case SOAP_TYPE_ns4__SetTestConfigurationResponse:
		return soap_in_ns4__SetTestConfigurationResponse(soap, tag, NULL, "ns4:SetTestConfigurationResponse");
	case SOAP_TYPE_ns4__GetTestConfiguration:
		return soap_in_ns4__GetTestConfiguration(soap, tag, NULL, "ns4:GetTestConfiguration");
	case SOAP_TYPE_ns4__GetTestConfigurationResponse:
		return soap_in_ns4__GetTestConfigurationResponse(soap, tag, NULL, "ns4:GetTestConfigurationResponse");
	case SOAP_TYPE_ns4__GetPressTestResult:
		return soap_in_ns4__GetPressTestResult(soap, tag, NULL, "ns4:GetPressTestResult");
	case SOAP_TYPE_ns4__GetPressTestResultResponse:
		return soap_in_ns4__GetPressTestResultResponse(soap, tag, NULL, "ns4:GetPressTestResultResponse");
	case SOAP_TYPE_ns4__GetTestResult:
		return soap_in_ns4__GetTestResult(soap, tag, NULL, "ns4:GetTestResult");
	case SOAP_TYPE_ns4__GetTestResultResponse:
		return soap_in_ns4__GetTestResultResponse(soap, tag, NULL, "ns4:GetTestResultResponse");
	case SOAP_TYPE_ns4__GetMeterResult:
		return soap_in_ns4__GetMeterResult(soap, tag, NULL, "ns4:GetMeterResult");
	case SOAP_TYPE_ns4__GetMeterResultResponse:
		return soap_in_ns4__GetMeterResultResponse(soap, tag, NULL, "ns4:GetMeterResultResponse");
	case SOAP_TYPE_ns4__GetTestResults:
		return soap_in_ns4__GetTestResults(soap, tag, NULL, "ns4:GetTestResults");
	case SOAP_TYPE_ns4__GetTestResultsResponse:
		return soap_in_ns4__GetTestResultsResponse(soap, tag, NULL, "ns4:GetTestResultsResponse");
	case SOAP_TYPE_ns4__GetMeasurementData:
		return soap_in_ns4__GetMeasurementData(soap, tag, NULL, "ns4:GetMeasurementData");
	case SOAP_TYPE_ns4__GetMeasurementDataResponse:
		return soap_in_ns4__GetMeasurementDataResponse(soap, tag, NULL, "ns4:GetMeasurementDataResponse");
	case SOAP_TYPE_ns4__GetMeterPositions:
		return soap_in_ns4__GetMeterPositions(soap, tag, NULL, "ns4:GetMeterPositions");
	case SOAP_TYPE_ns4__GetMeterPositionsResponse:
		return soap_in_ns4__GetMeterPositionsResponse(soap, tag, NULL, "ns4:GetMeterPositionsResponse");
	case SOAP_TYPE_ns4__SetMeterIndications:
		return soap_in_ns4__SetMeterIndications(soap, tag, NULL, "ns4:SetMeterIndications");
	case SOAP_TYPE_ns4__SetMeterIndicationsResponse:
		return soap_in_ns4__SetMeterIndicationsResponse(soap, tag, NULL, "ns4:SetMeterIndicationsResponse");
	case SOAP_TYPE_ns4__GetMeterData:
		return soap_in_ns4__GetMeterData(soap, tag, NULL, "ns4:GetMeterData");
	case SOAP_TYPE_ns4__GetMeterDataResponse:
		return soap_in_ns4__GetMeterDataResponse(soap, tag, NULL, "ns4:GetMeterDataResponse");
	case SOAP_TYPE_ns4__GetMetersData:
		return soap_in_ns4__GetMetersData(soap, tag, NULL, "ns4:GetMetersData");
	case SOAP_TYPE_ns4__GetMetersDataResponse:
		return soap_in_ns4__GetMetersDataResponse(soap, tag, NULL, "ns4:GetMetersDataResponse");
	case SOAP_TYPE_ns4__SetMetersData:
		return soap_in_ns4__SetMetersData(soap, tag, NULL, "ns4:SetMetersData");
	case SOAP_TYPE_ns4__SetMetersDataResponse:
		return soap_in_ns4__SetMetersDataResponse(soap, tag, NULL, "ns4:SetMetersDataResponse");
	case SOAP_TYPE_ns4__GetStatus:
		return soap_in_ns4__GetStatus(soap, tag, NULL, "ns4:GetStatus");
	case SOAP_TYPE_ns4__GetStatusResponse:
		return soap_in_ns4__GetStatusResponse(soap, tag, NULL, "ns4:GetStatusResponse");
	case SOAP_TYPE_ns4__Continue:
		return soap_in_ns4__Continue(soap, tag, NULL, "ns4:Continue");
	case SOAP_TYPE_ns4__ContinueResponse:
		return soap_in_ns4__ContinueResponse(soap, tag, NULL, "ns4:ContinueResponse");
	case SOAP_TYPE_ns4__Stop:
		return soap_in_ns4__Stop(soap, tag, NULL, "ns4:Stop");
	case SOAP_TYPE_ns4__StopResponse:
		return soap_in_ns4__StopResponse(soap, tag, NULL, "ns4:StopResponse");
	case SOAP_TYPE_ns4__Start:
		return soap_in_ns4__Start(soap, tag, NULL, "ns4:Start");
	case SOAP_TYPE_ns4__StartResponse:
		return soap_in_ns4__StartResponse(soap, tag, NULL, "ns4:StartResponse");
	case SOAP_TYPE_ns4__SetPressTestParameters:
		return soap_in_ns4__SetPressTestParameters(soap, tag, NULL, "ns4:SetPressTestParameters");
	case SOAP_TYPE_ns4__SetPressTestParametersResponse:
		return soap_in_ns4__SetPressTestParametersResponse(soap, tag, NULL, "ns4:SetPressTestParametersResponse");
	case SOAP_TYPE_ns4__GetPressTestParameters:
		return soap_in_ns4__GetPressTestParameters(soap, tag, NULL, "ns4:GetPressTestParameters");
	case SOAP_TYPE_ns4__GetPressTestParametersResponse:
		return soap_in_ns4__GetPressTestParametersResponse(soap, tag, NULL, "ns4:GetPressTestParametersResponse");
	case SOAP_TYPE_ns4__SetTestParameters:
		return soap_in_ns4__SetTestParameters(soap, tag, NULL, "ns4:SetTestParameters");
	case SOAP_TYPE_ns4__SetTestParametersResponse:
		return soap_in_ns4__SetTestParametersResponse(soap, tag, NULL, "ns4:SetTestParametersResponse");
	case SOAP_TYPE_ns4__GetTestParameters:
		return soap_in_ns4__GetTestParameters(soap, tag, NULL, "ns4:GetTestParameters");
	case SOAP_TYPE_ns4__GetTestParametersResponse:
		return soap_in_ns4__GetTestParametersResponse(soap, tag, NULL, "ns4:GetTestParametersResponse");
	case SOAP_TYPE_ns4__NewMeasurement:
		return soap_in_ns4__NewMeasurement(soap, tag, NULL, "ns4:NewMeasurement");
	case SOAP_TYPE_ns4__NewMeasurementResponse:
		return soap_in_ns4__NewMeasurementResponse(soap, tag, NULL, "ns4:NewMeasurementResponse");
	case SOAP_TYPE_ns4__GetTypeList:
		return soap_in_ns4__GetTypeList(soap, tag, NULL, "ns4:GetTypeList");
	case SOAP_TYPE_ns4__GetTypeListResponse:
		return soap_in_ns4__GetTypeListResponse(soap, tag, NULL, "ns4:GetTypeListResponse");
	case SOAP_TYPE_PointerTons3__TPressTestResult:
		return soap_in_PointerTons3__TPressTestResult(soap, tag, NULL, "ns3:TPressTestResult");
	case SOAP_TYPE_PointerTons3__TTestResult:
		return soap_in_PointerTons3__TTestResult(soap, tag, NULL, "ns3:TTestResult");
	case SOAP_TYPE_PointerTons3__TTestResults:
		return soap_in_PointerTons3__TTestResults(soap, tag, NULL, "ns3:TTestResults");
	case SOAP_TYPE_PointerTons3__TMeasurementData:
		return soap_in_PointerTons3__TMeasurementData(soap, tag, NULL, "ns3:TMeasurementData");
	case SOAP_TYPE_PointerToTBooleanDynArray:
		return soap_in_PointerToTBooleanDynArray(soap, tag, NULL, "xsd:boolean");
	case SOAP_TYPE_PointerToTMeterIndications:
		return soap_in_PointerToTMeterIndications(soap, tag, NULL, "ns3:TMeterIndication");
	case SOAP_TYPE_PointerToTIntegerDynArray:
		return soap_in_PointerToTIntegerDynArray(soap, tag, NULL, "xsd:int");
	case SOAP_TYPE_PointerToTMetersData:
		return soap_in_PointerToTMetersData(soap, tag, NULL, "ns3:TMeterData");
	case SOAP_TYPE_PointerTons3__TStatus:
		return soap_in_PointerTons3__TStatus(soap, tag, NULL, "ns3:TStatus");
	case SOAP_TYPE_PointerTons3__TWaitEvents:
		return soap_in_PointerTons3__TWaitEvents(soap, tag, NULL, "ns3:TWaitEvents");
	case SOAP_TYPE_PointerTons3__TPressTestParameters:
		return soap_in_PointerTons3__TPressTestParameters(soap, tag, NULL, "ns3:TPressTestParameters");
	case SOAP_TYPE_PointerTons3__TTestParameters:
		return soap_in_PointerTons3__TTestParameters(soap, tag, NULL, "ns3:TTestParameters");
	case SOAP_TYPE_PointerToPointerTons3__TMeterResult:
		return soap_in_PointerToPointerTons3__TMeterResult(soap, tag, NULL, "ns3:TMeterResult");
	case SOAP_TYPE_PointerTons3__TMeterResult:
		return soap_in_PointerTons3__TMeterResult(soap, tag, NULL, "ns3:TMeterResult");
	case SOAP_TYPE_PointerToPointerTons3__TMeterIndication:
		return soap_in_PointerToPointerTons3__TMeterIndication(soap, tag, NULL, "ns3:TMeterIndication");
	case SOAP_TYPE_PointerTons3__TMeterIndication:
		return soap_in_PointerTons3__TMeterIndication(soap, tag, NULL, "ns3:TMeterIndication");
	case SOAP_TYPE_PointerToPointerTons3__TMeterData:
		return soap_in_PointerToPointerTons3__TMeterData(soap, tag, NULL, "ns3:TMeterData");
	case SOAP_TYPE_PointerTons3__TMeterData:
		return soap_in_PointerTons3__TMeterData(soap, tag, NULL, "ns3:TMeterData");
	case SOAP_TYPE_PointerTobool:
		return soap_in_PointerTobool(soap, tag, NULL, "xsd:boolean");
	case SOAP_TYPE_PointerToint:
		return soap_in_PointerToint(soap, tag, NULL, "xsd:int");
	case SOAP_TYPE_PointerTostd__string:
		return soap_in_PointerTostd__string(soap, tag, NULL, "xsd:string");
	case SOAP_TYPE_PointerToTMeterResults:
		return soap_in_PointerToTMeterResults(soap, tag, NULL, "ns3:TMeterResult");
	case SOAP_TYPE_PointerToTStringDynArray:
		return soap_in_PointerToTStringDynArray(soap, tag, NULL, "xsd:string");
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, tag, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, tag, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
#else
	*type = 0;
#endif
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_std__string;
			return soap_in_std__string(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:TPressTestResult"))
		{	*type = SOAP_TYPE_ns3__TPressTestResult;
			return soap_in_ns3__TPressTestResult(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:TTestResult"))
		{	*type = SOAP_TYPE_ns3__TTestResult;
			return soap_in_ns3__TTestResult(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:TMeterResult"))
		{	*type = SOAP_TYPE_ns3__TMeterResult;
			return soap_in_ns3__TMeterResult(soap, tag, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns3:TMeterResult"))
		{	*type = SOAP_TYPE_TMeterResults;
			return soap_in_TMeterResults(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:TTestResults"))
		{	*type = SOAP_TYPE_ns3__TTestResults;
			return soap_in_ns3__TTestResults(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:TMeasurementData"))
		{	*type = SOAP_TYPE_ns3__TMeasurementData;
			return soap_in_ns3__TMeasurementData(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:TMeterIndication"))
		{	*type = SOAP_TYPE_ns3__TMeterIndication;
			return soap_in_ns3__TMeterIndication(soap, tag, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns3:TMeterIndication"))
		{	*type = SOAP_TYPE_TMeterIndications;
			return soap_in_TMeterIndications(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:TMeterData"))
		{	*type = SOAP_TYPE_ns3__TMeterData;
			return soap_in_ns3__TMeterData(soap, tag, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns3:TMeterData"))
		{	*type = SOAP_TYPE_TMetersData;
			return soap_in_TMetersData(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:TStatus"))
		{	*type = SOAP_TYPE_ns3__TStatus;
			return soap_in_ns3__TStatus(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:TWaitEvents"))
		{	*type = SOAP_TYPE_ns3__TWaitEvents;
			return soap_in_ns3__TWaitEvents(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:TPressTestParameters"))
		{	*type = SOAP_TYPE_ns3__TPressTestParameters;
			return soap_in_ns3__TPressTestParameters(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:TTestParameters"))
		{	*type = SOAP_TYPE_ns3__TTestParameters;
			return soap_in_ns3__TTestParameters(soap, tag, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "xsd:boolean"))
		{	*type = SOAP_TYPE_TBooleanDynArray;
			return soap_in_TBooleanDynArray(soap, tag, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "xsd:int"))
		{	*type = SOAP_TYPE_TIntegerDynArray;
			return soap_in_TIntegerDynArray(soap, tag, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "xsd:string"))
		{	*type = SOAP_TYPE_TStringDynArray;
			return soap_in_TStringDynArray(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "SOAP-ENC:Array"))
		{	*type = SOAP_TYPE_SOAP_ENC__Array;
			return soap_in_SOAP_ENC__Array(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:double"))
		{	*type = SOAP_TYPE_double;
			return soap_in_double(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_bool;
			return soap_in_bool(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:TPulseCheck"))
		{	*type = SOAP_TYPE_ns3__TPulseCheck;
			return soap_in_ns3__TPulseCheck(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:TStatusCode"))
		{	*type = SOAP_TYPE_ns3__TStatusCode;
			return soap_in_ns3__TStatusCode(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:TMeterIndicationMethod"))
		{	*type = SOAP_TYPE_ns3__TMeterIndicationMethod;
			return soap_in_ns3__TMeterIndicationMethod(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:TProofMethod"))
		{	*type = SOAP_TYPE_ns3__TProofMethod;
			return soap_in_ns3__TProofMethod(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:TResult"))
		{	*type = SOAP_TYPE_ns3__TResult;
			return soap_in_ns3__TResult(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:SetTestConfiguration"))
		{	*type = SOAP_TYPE_ns4__SetTestConfiguration;
			return soap_in_ns4__SetTestConfiguration(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:SetTestConfigurationResponse"))
		{	*type = SOAP_TYPE_ns4__SetTestConfigurationResponse;
			return soap_in_ns4__SetTestConfigurationResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:GetTestConfiguration"))
		{	*type = SOAP_TYPE_ns4__GetTestConfiguration;
			return soap_in_ns4__GetTestConfiguration(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:GetTestConfigurationResponse"))
		{	*type = SOAP_TYPE_ns4__GetTestConfigurationResponse;
			return soap_in_ns4__GetTestConfigurationResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:GetPressTestResult"))
		{	*type = SOAP_TYPE_ns4__GetPressTestResult;
			return soap_in_ns4__GetPressTestResult(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:GetPressTestResultResponse"))
		{	*type = SOAP_TYPE_ns4__GetPressTestResultResponse;
			return soap_in_ns4__GetPressTestResultResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:GetTestResult"))
		{	*type = SOAP_TYPE_ns4__GetTestResult;
			return soap_in_ns4__GetTestResult(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:GetTestResultResponse"))
		{	*type = SOAP_TYPE_ns4__GetTestResultResponse;
			return soap_in_ns4__GetTestResultResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:GetMeterResult"))
		{	*type = SOAP_TYPE_ns4__GetMeterResult;
			return soap_in_ns4__GetMeterResult(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:GetMeterResultResponse"))
		{	*type = SOAP_TYPE_ns4__GetMeterResultResponse;
			return soap_in_ns4__GetMeterResultResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:GetTestResults"))
		{	*type = SOAP_TYPE_ns4__GetTestResults;
			return soap_in_ns4__GetTestResults(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:GetTestResultsResponse"))
		{	*type = SOAP_TYPE_ns4__GetTestResultsResponse;
			return soap_in_ns4__GetTestResultsResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:GetMeasurementData"))
		{	*type = SOAP_TYPE_ns4__GetMeasurementData;
			return soap_in_ns4__GetMeasurementData(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:GetMeasurementDataResponse"))
		{	*type = SOAP_TYPE_ns4__GetMeasurementDataResponse;
			return soap_in_ns4__GetMeasurementDataResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:GetMeterPositions"))
		{	*type = SOAP_TYPE_ns4__GetMeterPositions;
			return soap_in_ns4__GetMeterPositions(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:GetMeterPositionsResponse"))
		{	*type = SOAP_TYPE_ns4__GetMeterPositionsResponse;
			return soap_in_ns4__GetMeterPositionsResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:SetMeterIndications"))
		{	*type = SOAP_TYPE_ns4__SetMeterIndications;
			return soap_in_ns4__SetMeterIndications(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:SetMeterIndicationsResponse"))
		{	*type = SOAP_TYPE_ns4__SetMeterIndicationsResponse;
			return soap_in_ns4__SetMeterIndicationsResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:GetMeterData"))
		{	*type = SOAP_TYPE_ns4__GetMeterData;
			return soap_in_ns4__GetMeterData(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:GetMeterDataResponse"))
		{	*type = SOAP_TYPE_ns4__GetMeterDataResponse;
			return soap_in_ns4__GetMeterDataResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:GetMetersData"))
		{	*type = SOAP_TYPE_ns4__GetMetersData;
			return soap_in_ns4__GetMetersData(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:GetMetersDataResponse"))
		{	*type = SOAP_TYPE_ns4__GetMetersDataResponse;
			return soap_in_ns4__GetMetersDataResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:SetMetersData"))
		{	*type = SOAP_TYPE_ns4__SetMetersData;
			return soap_in_ns4__SetMetersData(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:SetMetersDataResponse"))
		{	*type = SOAP_TYPE_ns4__SetMetersDataResponse;
			return soap_in_ns4__SetMetersDataResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:GetStatus"))
		{	*type = SOAP_TYPE_ns4__GetStatus;
			return soap_in_ns4__GetStatus(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:GetStatusResponse"))
		{	*type = SOAP_TYPE_ns4__GetStatusResponse;
			return soap_in_ns4__GetStatusResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:Continue"))
		{	*type = SOAP_TYPE_ns4__Continue;
			return soap_in_ns4__Continue(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:ContinueResponse"))
		{	*type = SOAP_TYPE_ns4__ContinueResponse;
			return soap_in_ns4__ContinueResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:Stop"))
		{	*type = SOAP_TYPE_ns4__Stop;
			return soap_in_ns4__Stop(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:StopResponse"))
		{	*type = SOAP_TYPE_ns4__StopResponse;
			return soap_in_ns4__StopResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:Start"))
		{	*type = SOAP_TYPE_ns4__Start;
			return soap_in_ns4__Start(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:StartResponse"))
		{	*type = SOAP_TYPE_ns4__StartResponse;
			return soap_in_ns4__StartResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:SetPressTestParameters"))
		{	*type = SOAP_TYPE_ns4__SetPressTestParameters;
			return soap_in_ns4__SetPressTestParameters(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:SetPressTestParametersResponse"))
		{	*type = SOAP_TYPE_ns4__SetPressTestParametersResponse;
			return soap_in_ns4__SetPressTestParametersResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:GetPressTestParameters"))
		{	*type = SOAP_TYPE_ns4__GetPressTestParameters;
			return soap_in_ns4__GetPressTestParameters(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:GetPressTestParametersResponse"))
		{	*type = SOAP_TYPE_ns4__GetPressTestParametersResponse;
			return soap_in_ns4__GetPressTestParametersResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:SetTestParameters"))
		{	*type = SOAP_TYPE_ns4__SetTestParameters;
			return soap_in_ns4__SetTestParameters(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:SetTestParametersResponse"))
		{	*type = SOAP_TYPE_ns4__SetTestParametersResponse;
			return soap_in_ns4__SetTestParametersResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:GetTestParameters"))
		{	*type = SOAP_TYPE_ns4__GetTestParameters;
			return soap_in_ns4__GetTestParameters(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:GetTestParametersResponse"))
		{	*type = SOAP_TYPE_ns4__GetTestParametersResponse;
			return soap_in_ns4__GetTestParametersResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:NewMeasurement"))
		{	*type = SOAP_TYPE_ns4__NewMeasurement;
			return soap_in_ns4__NewMeasurement(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:NewMeasurementResponse"))
		{	*type = SOAP_TYPE_ns4__NewMeasurementResponse;
			return soap_in_ns4__NewMeasurementResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:GetTypeList"))
		{	*type = SOAP_TYPE_ns4__GetTypeList;
			return soap_in_ns4__GetTypeList(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:GetTypeListResponse"))
		{	*type = SOAP_TYPE_ns4__GetTypeListResponse;
			return soap_in_ns4__GetTypeListResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, tag, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, tag, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
#ifndef WITH_NOIDREF
	}
#endif
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input at level = %u body = %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other && !soap->fignore)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && !soap->fignore && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, NULL, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body && soap_ignore(soap))
				return soap->error;
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, SOAP_MULTIREFTAG, pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{	(void)tag;
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_double:
		return soap_out_double(soap, tag, id, (const double *)ptr, "xsd:double");
	case SOAP_TYPE_bool:
		return soap_out_bool(soap, tag, id, (const bool *)ptr, "xsd:boolean");
	case SOAP_TYPE_ns3__TPulseCheck:
		return soap_out_ns3__TPulseCheck(soap, tag, id, (const enum ns3__TPulseCheck *)ptr, "ns3:TPulseCheck");
	case SOAP_TYPE_ns3__TStatusCode:
		return soap_out_ns3__TStatusCode(soap, tag, id, (const enum ns3__TStatusCode *)ptr, "ns3:TStatusCode");
	case SOAP_TYPE_ns3__TMeterIndicationMethod:
		return soap_out_ns3__TMeterIndicationMethod(soap, tag, id, (const enum ns3__TMeterIndicationMethod *)ptr, "ns3:TMeterIndicationMethod");
	case SOAP_TYPE_ns3__TProofMethod:
		return soap_out_ns3__TProofMethod(soap, tag, id, (const enum ns3__TProofMethod *)ptr, "ns3:TProofMethod");
	case SOAP_TYPE_ns3__TResult:
		return soap_out_ns3__TResult(soap, tag, id, (const enum ns3__TResult *)ptr, "ns3:TResult");
	case SOAP_TYPE_std__string:
		return soap_out_std__string(soap, tag, id, (const std::string *)ptr, "xsd:string");
	case SOAP_TYPE_ns3__TPressTestResult:
		return ((ns3__TPressTestResult *)ptr)->soap_out(soap, tag, id, "ns3:TPressTestResult");
	case SOAP_TYPE_ns3__TTestResult:
		return ((ns3__TTestResult *)ptr)->soap_out(soap, tag, id, "ns3:TTestResult");
	case SOAP_TYPE_ns3__TMeterResult:
		return ((ns3__TMeterResult *)ptr)->soap_out(soap, tag, id, "ns3:TMeterResult");
	case SOAP_TYPE_TMeterResults:
		return ((TMeterResults *)ptr)->soap_out(soap, tag, id, "ns3:TMeterResult");
	case SOAP_TYPE_ns3__TTestResults:
		return ((ns3__TTestResults *)ptr)->soap_out(soap, tag, id, "ns3:TTestResults");
	case SOAP_TYPE_ns3__TMeasurementData:
		return ((ns3__TMeasurementData *)ptr)->soap_out(soap, tag, id, "ns3:TMeasurementData");
	case SOAP_TYPE_ns3__TMeterIndication:
		return ((ns3__TMeterIndication *)ptr)->soap_out(soap, tag, id, "ns3:TMeterIndication");
	case SOAP_TYPE_TMeterIndications:
		return ((TMeterIndications *)ptr)->soap_out(soap, tag, id, "ns3:TMeterIndication");
	case SOAP_TYPE_ns3__TMeterData:
		return ((ns3__TMeterData *)ptr)->soap_out(soap, tag, id, "ns3:TMeterData");
	case SOAP_TYPE_TMetersData:
		return ((TMetersData *)ptr)->soap_out(soap, tag, id, "ns3:TMeterData");
	case SOAP_TYPE_ns3__TStatus:
		return ((ns3__TStatus *)ptr)->soap_out(soap, tag, id, "ns3:TStatus");
	case SOAP_TYPE_ns3__TWaitEvents:
		return ((ns3__TWaitEvents *)ptr)->soap_out(soap, tag, id, "ns3:TWaitEvents");
	case SOAP_TYPE_ns3__TPressTestParameters:
		return ((ns3__TPressTestParameters *)ptr)->soap_out(soap, tag, id, "ns3:TPressTestParameters");
	case SOAP_TYPE_ns3__TTestParameters:
		return ((ns3__TTestParameters *)ptr)->soap_out(soap, tag, id, "ns3:TTestParameters");
	case SOAP_TYPE_TBooleanDynArray:
		return ((TBooleanDynArray *)ptr)->soap_out(soap, tag, id, "xsd:boolean");
	case SOAP_TYPE_TIntegerDynArray:
		return ((TIntegerDynArray *)ptr)->soap_out(soap, tag, id, "xsd:int");
	case SOAP_TYPE_TStringDynArray:
		return ((TStringDynArray *)ptr)->soap_out(soap, tag, id, "xsd:string");
	case SOAP_TYPE_SOAP_ENC__Array:
		return ((SOAP_ENC__Array *)ptr)->soap_out(soap, tag, id, "SOAP-ENC:Array");
	case SOAP_TYPE_ns4__SetTestConfiguration:
		return soap_out_ns4__SetTestConfiguration(soap, tag, id, (const struct ns4__SetTestConfiguration *)ptr, "ns4:SetTestConfiguration");
	case SOAP_TYPE_ns4__SetTestConfigurationResponse:
		return soap_out_ns4__SetTestConfigurationResponse(soap, tag, id, (const struct ns4__SetTestConfigurationResponse *)ptr, "ns4:SetTestConfigurationResponse");
	case SOAP_TYPE_ns4__GetTestConfiguration:
		return soap_out_ns4__GetTestConfiguration(soap, tag, id, (const struct ns4__GetTestConfiguration *)ptr, "ns4:GetTestConfiguration");
	case SOAP_TYPE_ns4__GetTestConfigurationResponse:
		return soap_out_ns4__GetTestConfigurationResponse(soap, tag, id, (const struct ns4__GetTestConfigurationResponse *)ptr, "ns4:GetTestConfigurationResponse");
	case SOAP_TYPE_ns4__GetPressTestResult:
		return soap_out_ns4__GetPressTestResult(soap, tag, id, (const struct ns4__GetPressTestResult *)ptr, "ns4:GetPressTestResult");
	case SOAP_TYPE_ns4__GetPressTestResultResponse:
		return soap_out_ns4__GetPressTestResultResponse(soap, tag, id, (const struct ns4__GetPressTestResultResponse *)ptr, "ns4:GetPressTestResultResponse");
	case SOAP_TYPE_ns4__GetTestResult:
		return soap_out_ns4__GetTestResult(soap, tag, id, (const struct ns4__GetTestResult *)ptr, "ns4:GetTestResult");
	case SOAP_TYPE_ns4__GetTestResultResponse:
		return soap_out_ns4__GetTestResultResponse(soap, tag, id, (const struct ns4__GetTestResultResponse *)ptr, "ns4:GetTestResultResponse");
	case SOAP_TYPE_ns4__GetMeterResult:
		return soap_out_ns4__GetMeterResult(soap, tag, id, (const struct ns4__GetMeterResult *)ptr, "ns4:GetMeterResult");
	case SOAP_TYPE_ns4__GetMeterResultResponse:
		return soap_out_ns4__GetMeterResultResponse(soap, tag, id, (const struct ns4__GetMeterResultResponse *)ptr, "ns4:GetMeterResultResponse");
	case SOAP_TYPE_ns4__GetTestResults:
		return soap_out_ns4__GetTestResults(soap, tag, id, (const struct ns4__GetTestResults *)ptr, "ns4:GetTestResults");
	case SOAP_TYPE_ns4__GetTestResultsResponse:
		return soap_out_ns4__GetTestResultsResponse(soap, tag, id, (const struct ns4__GetTestResultsResponse *)ptr, "ns4:GetTestResultsResponse");
	case SOAP_TYPE_ns4__GetMeasurementData:
		return soap_out_ns4__GetMeasurementData(soap, tag, id, (const struct ns4__GetMeasurementData *)ptr, "ns4:GetMeasurementData");
	case SOAP_TYPE_ns4__GetMeasurementDataResponse:
		return soap_out_ns4__GetMeasurementDataResponse(soap, tag, id, (const struct ns4__GetMeasurementDataResponse *)ptr, "ns4:GetMeasurementDataResponse");
	case SOAP_TYPE_ns4__GetMeterPositions:
		return soap_out_ns4__GetMeterPositions(soap, tag, id, (const struct ns4__GetMeterPositions *)ptr, "ns4:GetMeterPositions");
	case SOAP_TYPE_ns4__GetMeterPositionsResponse:
		return soap_out_ns4__GetMeterPositionsResponse(soap, tag, id, (const struct ns4__GetMeterPositionsResponse *)ptr, "ns4:GetMeterPositionsResponse");
	case SOAP_TYPE_ns4__SetMeterIndications:
		return soap_out_ns4__SetMeterIndications(soap, tag, id, (const struct ns4__SetMeterIndications *)ptr, "ns4:SetMeterIndications");
	case SOAP_TYPE_ns4__SetMeterIndicationsResponse:
		return soap_out_ns4__SetMeterIndicationsResponse(soap, tag, id, (const struct ns4__SetMeterIndicationsResponse *)ptr, "ns4:SetMeterIndicationsResponse");
	case SOAP_TYPE_ns4__GetMeterData:
		return soap_out_ns4__GetMeterData(soap, tag, id, (const struct ns4__GetMeterData *)ptr, "ns4:GetMeterData");
	case SOAP_TYPE_ns4__GetMeterDataResponse:
		return soap_out_ns4__GetMeterDataResponse(soap, tag, id, (const struct ns4__GetMeterDataResponse *)ptr, "ns4:GetMeterDataResponse");
	case SOAP_TYPE_ns4__GetMetersData:
		return soap_out_ns4__GetMetersData(soap, tag, id, (const struct ns4__GetMetersData *)ptr, "ns4:GetMetersData");
	case SOAP_TYPE_ns4__GetMetersDataResponse:
		return soap_out_ns4__GetMetersDataResponse(soap, tag, id, (const struct ns4__GetMetersDataResponse *)ptr, "ns4:GetMetersDataResponse");
	case SOAP_TYPE_ns4__SetMetersData:
		return soap_out_ns4__SetMetersData(soap, tag, id, (const struct ns4__SetMetersData *)ptr, "ns4:SetMetersData");
	case SOAP_TYPE_ns4__SetMetersDataResponse:
		return soap_out_ns4__SetMetersDataResponse(soap, tag, id, (const struct ns4__SetMetersDataResponse *)ptr, "ns4:SetMetersDataResponse");
	case SOAP_TYPE_ns4__GetStatus:
		return soap_out_ns4__GetStatus(soap, tag, id, (const struct ns4__GetStatus *)ptr, "ns4:GetStatus");
	case SOAP_TYPE_ns4__GetStatusResponse:
		return soap_out_ns4__GetStatusResponse(soap, tag, id, (const struct ns4__GetStatusResponse *)ptr, "ns4:GetStatusResponse");
	case SOAP_TYPE_ns4__Continue:
		return soap_out_ns4__Continue(soap, tag, id, (const struct ns4__Continue *)ptr, "ns4:Continue");
	case SOAP_TYPE_ns4__ContinueResponse:
		return soap_out_ns4__ContinueResponse(soap, tag, id, (const struct ns4__ContinueResponse *)ptr, "ns4:ContinueResponse");
	case SOAP_TYPE_ns4__Stop:
		return soap_out_ns4__Stop(soap, tag, id, (const struct ns4__Stop *)ptr, "ns4:Stop");
	case SOAP_TYPE_ns4__StopResponse:
		return soap_out_ns4__StopResponse(soap, tag, id, (const struct ns4__StopResponse *)ptr, "ns4:StopResponse");
	case SOAP_TYPE_ns4__Start:
		return soap_out_ns4__Start(soap, tag, id, (const struct ns4__Start *)ptr, "ns4:Start");
	case SOAP_TYPE_ns4__StartResponse:
		return soap_out_ns4__StartResponse(soap, tag, id, (const struct ns4__StartResponse *)ptr, "ns4:StartResponse");
	case SOAP_TYPE_ns4__SetPressTestParameters:
		return soap_out_ns4__SetPressTestParameters(soap, tag, id, (const struct ns4__SetPressTestParameters *)ptr, "ns4:SetPressTestParameters");
	case SOAP_TYPE_ns4__SetPressTestParametersResponse:
		return soap_out_ns4__SetPressTestParametersResponse(soap, tag, id, (const struct ns4__SetPressTestParametersResponse *)ptr, "ns4:SetPressTestParametersResponse");
	case SOAP_TYPE_ns4__GetPressTestParameters:
		return soap_out_ns4__GetPressTestParameters(soap, tag, id, (const struct ns4__GetPressTestParameters *)ptr, "ns4:GetPressTestParameters");
	case SOAP_TYPE_ns4__GetPressTestParametersResponse:
		return soap_out_ns4__GetPressTestParametersResponse(soap, tag, id, (const struct ns4__GetPressTestParametersResponse *)ptr, "ns4:GetPressTestParametersResponse");
	case SOAP_TYPE_ns4__SetTestParameters:
		return soap_out_ns4__SetTestParameters(soap, tag, id, (const struct ns4__SetTestParameters *)ptr, "ns4:SetTestParameters");
	case SOAP_TYPE_ns4__SetTestParametersResponse:
		return soap_out_ns4__SetTestParametersResponse(soap, tag, id, (const struct ns4__SetTestParametersResponse *)ptr, "ns4:SetTestParametersResponse");
	case SOAP_TYPE_ns4__GetTestParameters:
		return soap_out_ns4__GetTestParameters(soap, tag, id, (const struct ns4__GetTestParameters *)ptr, "ns4:GetTestParameters");
	case SOAP_TYPE_ns4__GetTestParametersResponse:
		return soap_out_ns4__GetTestParametersResponse(soap, tag, id, (const struct ns4__GetTestParametersResponse *)ptr, "ns4:GetTestParametersResponse");
	case SOAP_TYPE_ns4__NewMeasurement:
		return soap_out_ns4__NewMeasurement(soap, tag, id, (const struct ns4__NewMeasurement *)ptr, "ns4:NewMeasurement");
	case SOAP_TYPE_ns4__NewMeasurementResponse:
		return soap_out_ns4__NewMeasurementResponse(soap, tag, id, (const struct ns4__NewMeasurementResponse *)ptr, "ns4:NewMeasurementResponse");
	case SOAP_TYPE_ns4__GetTypeList:
		return soap_out_ns4__GetTypeList(soap, tag, id, (const struct ns4__GetTypeList *)ptr, "ns4:GetTypeList");
	case SOAP_TYPE_ns4__GetTypeListResponse:
		return soap_out_ns4__GetTypeListResponse(soap, tag, id, (const struct ns4__GetTypeListResponse *)ptr, "ns4:GetTypeListResponse");
	case SOAP_TYPE_PointerTons3__TPressTestResult:
		return soap_out_PointerTons3__TPressTestResult(soap, tag, id, (ns3__TPressTestResult *const*)ptr, "ns3:TPressTestResult");
	case SOAP_TYPE_PointerTons3__TTestResult:
		return soap_out_PointerTons3__TTestResult(soap, tag, id, (ns3__TTestResult *const*)ptr, "ns3:TTestResult");
	case SOAP_TYPE_PointerTons3__TTestResults:
		return soap_out_PointerTons3__TTestResults(soap, tag, id, (ns3__TTestResults *const*)ptr, "ns3:TTestResults");
	case SOAP_TYPE_PointerTons3__TMeasurementData:
		return soap_out_PointerTons3__TMeasurementData(soap, tag, id, (ns3__TMeasurementData *const*)ptr, "ns3:TMeasurementData");
	case SOAP_TYPE_PointerToTBooleanDynArray:
		return soap_out_PointerToTBooleanDynArray(soap, tag, id, (TBooleanDynArray *const*)ptr, "xsd:boolean");
	case SOAP_TYPE_PointerToTMeterIndications:
		return soap_out_PointerToTMeterIndications(soap, tag, id, (TMeterIndications *const*)ptr, "ns3:TMeterIndication");
	case SOAP_TYPE_PointerToTIntegerDynArray:
		return soap_out_PointerToTIntegerDynArray(soap, tag, id, (TIntegerDynArray *const*)ptr, "xsd:int");
	case SOAP_TYPE_PointerToTMetersData:
		return soap_out_PointerToTMetersData(soap, tag, id, (TMetersData *const*)ptr, "ns3:TMeterData");
	case SOAP_TYPE_PointerTons3__TStatus:
		return soap_out_PointerTons3__TStatus(soap, tag, id, (ns3__TStatus *const*)ptr, "ns3:TStatus");
	case SOAP_TYPE_PointerTons3__TWaitEvents:
		return soap_out_PointerTons3__TWaitEvents(soap, tag, id, (ns3__TWaitEvents *const*)ptr, "ns3:TWaitEvents");
	case SOAP_TYPE_PointerTons3__TPressTestParameters:
		return soap_out_PointerTons3__TPressTestParameters(soap, tag, id, (ns3__TPressTestParameters *const*)ptr, "ns3:TPressTestParameters");
	case SOAP_TYPE_PointerTons3__TTestParameters:
		return soap_out_PointerTons3__TTestParameters(soap, tag, id, (ns3__TTestParameters *const*)ptr, "ns3:TTestParameters");
	case SOAP_TYPE_PointerToPointerTons3__TMeterResult:
		return soap_out_PointerToPointerTons3__TMeterResult(soap, tag, id, (ns3__TMeterResult **const*)ptr, "ns3:TMeterResult");
	case SOAP_TYPE_PointerTons3__TMeterResult:
		return soap_out_PointerTons3__TMeterResult(soap, tag, id, (ns3__TMeterResult *const*)ptr, "ns3:TMeterResult");
	case SOAP_TYPE_PointerToPointerTons3__TMeterIndication:
		return soap_out_PointerToPointerTons3__TMeterIndication(soap, tag, id, (ns3__TMeterIndication **const*)ptr, "ns3:TMeterIndication");
	case SOAP_TYPE_PointerTons3__TMeterIndication:
		return soap_out_PointerTons3__TMeterIndication(soap, tag, id, (ns3__TMeterIndication *const*)ptr, "ns3:TMeterIndication");
	case SOAP_TYPE_PointerToPointerTons3__TMeterData:
		return soap_out_PointerToPointerTons3__TMeterData(soap, tag, id, (ns3__TMeterData **const*)ptr, "ns3:TMeterData");
	case SOAP_TYPE_PointerTons3__TMeterData:
		return soap_out_PointerTons3__TMeterData(soap, tag, id, (ns3__TMeterData *const*)ptr, "ns3:TMeterData");
	case SOAP_TYPE_PointerTobool:
		return soap_out_PointerTobool(soap, tag, id, (bool *const*)ptr, "xsd:boolean");
	case SOAP_TYPE_PointerToint:
		return soap_out_PointerToint(soap, tag, id, (int *const*)ptr, "xsd:int");
	case SOAP_TYPE_PointerTostd__string:
		return soap_out_PointerTostd__string(soap, tag, id, (std::string *const*)ptr, "xsd:string");
	case SOAP_TYPE_PointerToTMeterResults:
		return soap_out_PointerToTMeterResults(soap, tag, id, (TMeterResults *const*)ptr, "ns3:TMeterResult");
	case SOAP_TYPE_PointerToTStringDynArray:
		return soap_out_PointerToTStringDynArray(soap, tag, id, (TStringDynArray *const*)ptr, "xsd:string");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:string");
	case 0:
		return SOAP_OK;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_putelement '%s' failed for type %d in soapC.cpp\n", tag ? tag : "", type));
	return soap_element_empty(soap, tag, 0, NULL); /* unknown type to serialize */
}
#ifdef __cplusplus
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE_std__string:
		soap_serialize_std__string(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns3__TPressTestResult:
		((ns3__TPressTestResult *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__TTestResult:
		((ns3__TTestResult *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__TMeterResult:
		((ns3__TMeterResult *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TMeterResults:
		((TMeterResults *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__TTestResults:
		((ns3__TTestResults *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__TMeasurementData:
		((ns3__TMeasurementData *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__TMeterIndication:
		((ns3__TMeterIndication *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TMeterIndications:
		((TMeterIndications *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__TMeterData:
		((ns3__TMeterData *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TMetersData:
		((TMetersData *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__TStatus:
		((ns3__TStatus *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__TWaitEvents:
		((ns3__TWaitEvents *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__TPressTestParameters:
		((ns3__TPressTestParameters *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__TTestParameters:
		((ns3__TTestParameters *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TBooleanDynArray:
		((TBooleanDynArray *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TIntegerDynArray:
		((TIntegerDynArray *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TStringDynArray:
		((TStringDynArray *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_SOAP_ENC__Array:
		((SOAP_ENC__Array *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns4__SetTestConfiguration:
		soap_serialize_ns4__SetTestConfiguration(soap, (const struct ns4__SetTestConfiguration *)ptr);
		break;
	case SOAP_TYPE_ns4__SetTestConfigurationResponse:
		soap_serialize_ns4__SetTestConfigurationResponse(soap, (const struct ns4__SetTestConfigurationResponse *)ptr);
		break;
	case SOAP_TYPE_ns4__GetTestConfiguration:
		soap_serialize_ns4__GetTestConfiguration(soap, (const struct ns4__GetTestConfiguration *)ptr);
		break;
	case SOAP_TYPE_ns4__GetTestConfigurationResponse:
		soap_serialize_ns4__GetTestConfigurationResponse(soap, (const struct ns4__GetTestConfigurationResponse *)ptr);
		break;
	case SOAP_TYPE_ns4__GetPressTestResult:
		soap_serialize_ns4__GetPressTestResult(soap, (const struct ns4__GetPressTestResult *)ptr);
		break;
	case SOAP_TYPE_ns4__GetPressTestResultResponse:
		soap_serialize_ns4__GetPressTestResultResponse(soap, (const struct ns4__GetPressTestResultResponse *)ptr);
		break;
	case SOAP_TYPE_ns4__GetTestResult:
		soap_serialize_ns4__GetTestResult(soap, (const struct ns4__GetTestResult *)ptr);
		break;
	case SOAP_TYPE_ns4__GetTestResultResponse:
		soap_serialize_ns4__GetTestResultResponse(soap, (const struct ns4__GetTestResultResponse *)ptr);
		break;
	case SOAP_TYPE_ns4__GetMeterResult:
		soap_serialize_ns4__GetMeterResult(soap, (const struct ns4__GetMeterResult *)ptr);
		break;
	case SOAP_TYPE_ns4__GetMeterResultResponse:
		soap_serialize_ns4__GetMeterResultResponse(soap, (const struct ns4__GetMeterResultResponse *)ptr);
		break;
	case SOAP_TYPE_ns4__GetTestResults:
		soap_serialize_ns4__GetTestResults(soap, (const struct ns4__GetTestResults *)ptr);
		break;
	case SOAP_TYPE_ns4__GetTestResultsResponse:
		soap_serialize_ns4__GetTestResultsResponse(soap, (const struct ns4__GetTestResultsResponse *)ptr);
		break;
	case SOAP_TYPE_ns4__GetMeasurementData:
		soap_serialize_ns4__GetMeasurementData(soap, (const struct ns4__GetMeasurementData *)ptr);
		break;
	case SOAP_TYPE_ns4__GetMeasurementDataResponse:
		soap_serialize_ns4__GetMeasurementDataResponse(soap, (const struct ns4__GetMeasurementDataResponse *)ptr);
		break;
	case SOAP_TYPE_ns4__GetMeterPositions:
		soap_serialize_ns4__GetMeterPositions(soap, (const struct ns4__GetMeterPositions *)ptr);
		break;
	case SOAP_TYPE_ns4__GetMeterPositionsResponse:
		soap_serialize_ns4__GetMeterPositionsResponse(soap, (const struct ns4__GetMeterPositionsResponse *)ptr);
		break;
	case SOAP_TYPE_ns4__SetMeterIndications:
		soap_serialize_ns4__SetMeterIndications(soap, (const struct ns4__SetMeterIndications *)ptr);
		break;
	case SOAP_TYPE_ns4__SetMeterIndicationsResponse:
		soap_serialize_ns4__SetMeterIndicationsResponse(soap, (const struct ns4__SetMeterIndicationsResponse *)ptr);
		break;
	case SOAP_TYPE_ns4__GetMeterData:
		soap_serialize_ns4__GetMeterData(soap, (const struct ns4__GetMeterData *)ptr);
		break;
	case SOAP_TYPE_ns4__GetMeterDataResponse:
		soap_serialize_ns4__GetMeterDataResponse(soap, (const struct ns4__GetMeterDataResponse *)ptr);
		break;
	case SOAP_TYPE_ns4__GetMetersData:
		soap_serialize_ns4__GetMetersData(soap, (const struct ns4__GetMetersData *)ptr);
		break;
	case SOAP_TYPE_ns4__GetMetersDataResponse:
		soap_serialize_ns4__GetMetersDataResponse(soap, (const struct ns4__GetMetersDataResponse *)ptr);
		break;
	case SOAP_TYPE_ns4__SetMetersData:
		soap_serialize_ns4__SetMetersData(soap, (const struct ns4__SetMetersData *)ptr);
		break;
	case SOAP_TYPE_ns4__SetMetersDataResponse:
		soap_serialize_ns4__SetMetersDataResponse(soap, (const struct ns4__SetMetersDataResponse *)ptr);
		break;
	case SOAP_TYPE_ns4__GetStatus:
		soap_serialize_ns4__GetStatus(soap, (const struct ns4__GetStatus *)ptr);
		break;
	case SOAP_TYPE_ns4__GetStatusResponse:
		soap_serialize_ns4__GetStatusResponse(soap, (const struct ns4__GetStatusResponse *)ptr);
		break;
	case SOAP_TYPE_ns4__Continue:
		soap_serialize_ns4__Continue(soap, (const struct ns4__Continue *)ptr);
		break;
	case SOAP_TYPE_ns4__ContinueResponse:
		soap_serialize_ns4__ContinueResponse(soap, (const struct ns4__ContinueResponse *)ptr);
		break;
	case SOAP_TYPE_ns4__Stop:
		soap_serialize_ns4__Stop(soap, (const struct ns4__Stop *)ptr);
		break;
	case SOAP_TYPE_ns4__StopResponse:
		soap_serialize_ns4__StopResponse(soap, (const struct ns4__StopResponse *)ptr);
		break;
	case SOAP_TYPE_ns4__Start:
		soap_serialize_ns4__Start(soap, (const struct ns4__Start *)ptr);
		break;
	case SOAP_TYPE_ns4__StartResponse:
		soap_serialize_ns4__StartResponse(soap, (const struct ns4__StartResponse *)ptr);
		break;
	case SOAP_TYPE_ns4__SetPressTestParameters:
		soap_serialize_ns4__SetPressTestParameters(soap, (const struct ns4__SetPressTestParameters *)ptr);
		break;
	case SOAP_TYPE_ns4__SetPressTestParametersResponse:
		soap_serialize_ns4__SetPressTestParametersResponse(soap, (const struct ns4__SetPressTestParametersResponse *)ptr);
		break;
	case SOAP_TYPE_ns4__GetPressTestParameters:
		soap_serialize_ns4__GetPressTestParameters(soap, (const struct ns4__GetPressTestParameters *)ptr);
		break;
	case SOAP_TYPE_ns4__GetPressTestParametersResponse:
		soap_serialize_ns4__GetPressTestParametersResponse(soap, (const struct ns4__GetPressTestParametersResponse *)ptr);
		break;
	case SOAP_TYPE_ns4__SetTestParameters:
		soap_serialize_ns4__SetTestParameters(soap, (const struct ns4__SetTestParameters *)ptr);
		break;
	case SOAP_TYPE_ns4__SetTestParametersResponse:
		soap_serialize_ns4__SetTestParametersResponse(soap, (const struct ns4__SetTestParametersResponse *)ptr);
		break;
	case SOAP_TYPE_ns4__GetTestParameters:
		soap_serialize_ns4__GetTestParameters(soap, (const struct ns4__GetTestParameters *)ptr);
		break;
	case SOAP_TYPE_ns4__GetTestParametersResponse:
		soap_serialize_ns4__GetTestParametersResponse(soap, (const struct ns4__GetTestParametersResponse *)ptr);
		break;
	case SOAP_TYPE_ns4__NewMeasurement:
		soap_serialize_ns4__NewMeasurement(soap, (const struct ns4__NewMeasurement *)ptr);
		break;
	case SOAP_TYPE_ns4__NewMeasurementResponse:
		soap_serialize_ns4__NewMeasurementResponse(soap, (const struct ns4__NewMeasurementResponse *)ptr);
		break;
	case SOAP_TYPE_ns4__GetTypeList:
		soap_serialize_ns4__GetTypeList(soap, (const struct ns4__GetTypeList *)ptr);
		break;
	case SOAP_TYPE_ns4__GetTypeListResponse:
		soap_serialize_ns4__GetTypeListResponse(soap, (const struct ns4__GetTypeListResponse *)ptr);
		break;
	case SOAP_TYPE_PointerTons3__TPressTestResult:
		soap_serialize_PointerTons3__TPressTestResult(soap, (ns3__TPressTestResult *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__TTestResult:
		soap_serialize_PointerTons3__TTestResult(soap, (ns3__TTestResult *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__TTestResults:
		soap_serialize_PointerTons3__TTestResults(soap, (ns3__TTestResults *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__TMeasurementData:
		soap_serialize_PointerTons3__TMeasurementData(soap, (ns3__TMeasurementData *const*)ptr);
		break;
	case SOAP_TYPE_PointerToTBooleanDynArray:
		soap_serialize_PointerToTBooleanDynArray(soap, (TBooleanDynArray *const*)ptr);
		break;
	case SOAP_TYPE_PointerToTMeterIndications:
		soap_serialize_PointerToTMeterIndications(soap, (TMeterIndications *const*)ptr);
		break;
	case SOAP_TYPE_PointerToTIntegerDynArray:
		soap_serialize_PointerToTIntegerDynArray(soap, (TIntegerDynArray *const*)ptr);
		break;
	case SOAP_TYPE_PointerToTMetersData:
		soap_serialize_PointerToTMetersData(soap, (TMetersData *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__TStatus:
		soap_serialize_PointerTons3__TStatus(soap, (ns3__TStatus *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__TWaitEvents:
		soap_serialize_PointerTons3__TWaitEvents(soap, (ns3__TWaitEvents *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__TPressTestParameters:
		soap_serialize_PointerTons3__TPressTestParameters(soap, (ns3__TPressTestParameters *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__TTestParameters:
		soap_serialize_PointerTons3__TTestParameters(soap, (ns3__TTestParameters *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons3__TMeterResult:
		soap_serialize_PointerToPointerTons3__TMeterResult(soap, (ns3__TMeterResult **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__TMeterResult:
		soap_serialize_PointerTons3__TMeterResult(soap, (ns3__TMeterResult *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons3__TMeterIndication:
		soap_serialize_PointerToPointerTons3__TMeterIndication(soap, (ns3__TMeterIndication **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__TMeterIndication:
		soap_serialize_PointerTons3__TMeterIndication(soap, (ns3__TMeterIndication *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons3__TMeterData:
		soap_serialize_PointerToPointerTons3__TMeterData(soap, (ns3__TMeterData **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__TMeterData:
		soap_serialize_PointerTons3__TMeterData(soap, (ns3__TMeterData *const*)ptr);
		break;
	case SOAP_TYPE_PointerTobool:
		soap_serialize_PointerTobool(soap, (bool *const*)ptr);
		break;
	case SOAP_TYPE_PointerToint:
		soap_serialize_PointerToint(soap, (int *const*)ptr);
		break;
	case SOAP_TYPE_PointerTostd__string:
		soap_serialize_PointerTostd__string(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerToTMeterResults:
		soap_serialize_PointerToTMeterResults(soap, (TMeterResults *const*)ptr);
		break;
	case SOAP_TYPE_PointerToTStringDynArray:
		soap_serialize_PointerToTStringDynArray(soap, (TStringDynArray *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	}
}
#ifdef __cplusplus
}
#endif
#endif

#ifdef __cplusplus
extern "C" {
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_dupelement(struct soap *soap, const void *ptr, int type)
{(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	return NULL;
}
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_delelement(const void *ptr, int type)
{(void)ptr; (void)type; /* appease -Wall -Werror */
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{	(void)type;
	switch (t)
	{
	case SOAP_TYPE_SOAP_ENC__Array:
		return (void*)soap_instantiate_SOAP_ENC__Array(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__TTestParameters:
		return (void*)soap_instantiate_ns3__TTestParameters(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__TPressTestParameters:
		return (void*)soap_instantiate_ns3__TPressTestParameters(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__TWaitEvents:
		return (void*)soap_instantiate_ns3__TWaitEvents(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__string:
		return (void*)soap_instantiate_std__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__TStatus:
		return (void*)soap_instantiate_ns3__TStatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__TMeterData:
		return (void*)soap_instantiate_ns3__TMeterData(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__TMeterIndication:
		return (void*)soap_instantiate_ns3__TMeterIndication(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__TMeasurementData:
		return (void*)soap_instantiate_ns3__TMeasurementData(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__TTestResults:
		return (void*)soap_instantiate_ns3__TTestResults(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__TMeterResult:
		return (void*)soap_instantiate_ns3__TMeterResult(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__TTestResult:
		return (void*)soap_instantiate_ns3__TTestResult(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__TPressTestResult:
		return (void*)soap_instantiate_ns3__TPressTestResult(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TStringDynArray:
		return (void*)soap_instantiate_TStringDynArray(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TIntegerDynArray:
		return (void*)soap_instantiate_TIntegerDynArray(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TBooleanDynArray:
		return (void*)soap_instantiate_TBooleanDynArray(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TMetersData:
		return (void*)soap_instantiate_TMetersData(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TMeterIndications:
		return (void*)soap_instantiate_TMeterIndications(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TMeterResults:
		return (void*)soap_instantiate_TMeterResults(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__GetTypeListResponse:
		return (void*)soap_instantiate_ns4__GetTypeListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__GetTypeList:
		return (void*)soap_instantiate_ns4__GetTypeList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__NewMeasurementResponse:
		return (void*)soap_instantiate_ns4__NewMeasurementResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__NewMeasurement:
		return (void*)soap_instantiate_ns4__NewMeasurement(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__GetTestParametersResponse:
		return (void*)soap_instantiate_ns4__GetTestParametersResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__GetTestParameters:
		return (void*)soap_instantiate_ns4__GetTestParameters(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__SetTestParametersResponse:
		return (void*)soap_instantiate_ns4__SetTestParametersResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__SetTestParameters:
		return (void*)soap_instantiate_ns4__SetTestParameters(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__GetPressTestParametersResponse:
		return (void*)soap_instantiate_ns4__GetPressTestParametersResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__GetPressTestParameters:
		return (void*)soap_instantiate_ns4__GetPressTestParameters(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__SetPressTestParametersResponse:
		return (void*)soap_instantiate_ns4__SetPressTestParametersResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__SetPressTestParameters:
		return (void*)soap_instantiate_ns4__SetPressTestParameters(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__StartResponse:
		return (void*)soap_instantiate_ns4__StartResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__Start:
		return (void*)soap_instantiate_ns4__Start(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__StopResponse:
		return (void*)soap_instantiate_ns4__StopResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__Stop:
		return (void*)soap_instantiate_ns4__Stop(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__ContinueResponse:
		return (void*)soap_instantiate_ns4__ContinueResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__Continue:
		return (void*)soap_instantiate_ns4__Continue(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__GetStatusResponse:
		return (void*)soap_instantiate_ns4__GetStatusResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__GetStatus:
		return (void*)soap_instantiate_ns4__GetStatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__SetMetersDataResponse:
		return (void*)soap_instantiate_ns4__SetMetersDataResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__SetMetersData:
		return (void*)soap_instantiate_ns4__SetMetersData(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__GetMetersDataResponse:
		return (void*)soap_instantiate_ns4__GetMetersDataResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__GetMetersData:
		return (void*)soap_instantiate_ns4__GetMetersData(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__GetMeterDataResponse:
		return (void*)soap_instantiate_ns4__GetMeterDataResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__GetMeterData:
		return (void*)soap_instantiate_ns4__GetMeterData(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__SetMeterIndicationsResponse:
		return (void*)soap_instantiate_ns4__SetMeterIndicationsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__SetMeterIndications:
		return (void*)soap_instantiate_ns4__SetMeterIndications(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__GetMeterPositionsResponse:
		return (void*)soap_instantiate_ns4__GetMeterPositionsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__GetMeterPositions:
		return (void*)soap_instantiate_ns4__GetMeterPositions(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__GetMeasurementDataResponse:
		return (void*)soap_instantiate_ns4__GetMeasurementDataResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__GetMeasurementData:
		return (void*)soap_instantiate_ns4__GetMeasurementData(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__GetTestResultsResponse:
		return (void*)soap_instantiate_ns4__GetTestResultsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__GetTestResults:
		return (void*)soap_instantiate_ns4__GetTestResults(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__GetMeterResultResponse:
		return (void*)soap_instantiate_ns4__GetMeterResultResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__GetMeterResult:
		return (void*)soap_instantiate_ns4__GetMeterResult(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__GetTestResultResponse:
		return (void*)soap_instantiate_ns4__GetTestResultResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__GetTestResult:
		return (void*)soap_instantiate_ns4__GetTestResult(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__GetPressTestResultResponse:
		return (void*)soap_instantiate_ns4__GetPressTestResultResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__GetPressTestResult:
		return (void*)soap_instantiate_ns4__GetPressTestResult(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__GetTestConfigurationResponse:
		return (void*)soap_instantiate_ns4__GetTestConfigurationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__GetTestConfiguration:
		return (void*)soap_instantiate_ns4__GetTestConfiguration(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__SetTestConfigurationResponse:
		return (void*)soap_instantiate_ns4__SetTestConfigurationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__SetTestConfiguration:
		return (void*)soap_instantiate_ns4__SetTestConfiguration(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap *soap, struct soap_clist *p)
{
	(void)soap; /* appease -Wall -Werror */
	if (!p->ptr)
		return SOAP_OK;
	switch (p->type)
	{
	case SOAP_TYPE_SOAP_ENC__Array:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<SOAP_ENC__Array*>(p->ptr), SOAP_ENC__Array);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<SOAP_ENC__Array*>(p->ptr), SOAP_ENC__Array);
		break;
	case SOAP_TYPE_ns3__TTestParameters:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns3__TTestParameters*>(p->ptr), ns3__TTestParameters);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns3__TTestParameters*>(p->ptr), ns3__TTestParameters);
		break;
	case SOAP_TYPE_ns3__TPressTestParameters:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns3__TPressTestParameters*>(p->ptr), ns3__TPressTestParameters);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns3__TPressTestParameters*>(p->ptr), ns3__TPressTestParameters);
		break;
	case SOAP_TYPE_ns3__TWaitEvents:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns3__TWaitEvents*>(p->ptr), ns3__TWaitEvents);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns3__TWaitEvents*>(p->ptr), ns3__TWaitEvents);
		break;
	case SOAP_TYPE_std__string:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_ns3__TStatus:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns3__TStatus*>(p->ptr), ns3__TStatus);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns3__TStatus*>(p->ptr), ns3__TStatus);
		break;
	case SOAP_TYPE_ns3__TMeterData:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns3__TMeterData*>(p->ptr), ns3__TMeterData);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns3__TMeterData*>(p->ptr), ns3__TMeterData);
		break;
	case SOAP_TYPE_ns3__TMeterIndication:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns3__TMeterIndication*>(p->ptr), ns3__TMeterIndication);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns3__TMeterIndication*>(p->ptr), ns3__TMeterIndication);
		break;
	case SOAP_TYPE_ns3__TMeasurementData:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns3__TMeasurementData*>(p->ptr), ns3__TMeasurementData);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns3__TMeasurementData*>(p->ptr), ns3__TMeasurementData);
		break;
	case SOAP_TYPE_ns3__TTestResults:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns3__TTestResults*>(p->ptr), ns3__TTestResults);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns3__TTestResults*>(p->ptr), ns3__TTestResults);
		break;
	case SOAP_TYPE_ns3__TMeterResult:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns3__TMeterResult*>(p->ptr), ns3__TMeterResult);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns3__TMeterResult*>(p->ptr), ns3__TMeterResult);
		break;
	case SOAP_TYPE_ns3__TTestResult:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns3__TTestResult*>(p->ptr), ns3__TTestResult);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns3__TTestResult*>(p->ptr), ns3__TTestResult);
		break;
	case SOAP_TYPE_ns3__TPressTestResult:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns3__TPressTestResult*>(p->ptr), ns3__TPressTestResult);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns3__TPressTestResult*>(p->ptr), ns3__TPressTestResult);
		break;
	case SOAP_TYPE_TStringDynArray:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<TStringDynArray*>(p->ptr), TStringDynArray);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<TStringDynArray*>(p->ptr), TStringDynArray);
		break;
	case SOAP_TYPE_TIntegerDynArray:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<TIntegerDynArray*>(p->ptr), TIntegerDynArray);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<TIntegerDynArray*>(p->ptr), TIntegerDynArray);
		break;
	case SOAP_TYPE_TBooleanDynArray:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<TBooleanDynArray*>(p->ptr), TBooleanDynArray);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<TBooleanDynArray*>(p->ptr), TBooleanDynArray);
		break;
	case SOAP_TYPE_TMetersData:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<TMetersData*>(p->ptr), TMetersData);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<TMetersData*>(p->ptr), TMetersData);
		break;
	case SOAP_TYPE_TMeterIndications:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<TMeterIndications*>(p->ptr), TMeterIndications);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<TMeterIndications*>(p->ptr), TMeterIndications);
		break;
	case SOAP_TYPE_TMeterResults:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<TMeterResults*>(p->ptr), TMeterResults);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<TMeterResults*>(p->ptr), TMeterResults);
		break;
	case SOAP_TYPE_ns4__GetTypeListResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns4__GetTypeListResponse*>(p->ptr), struct ns4__GetTypeListResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns4__GetTypeListResponse*>(p->ptr), struct ns4__GetTypeListResponse);
		break;
	case SOAP_TYPE_ns4__GetTypeList:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns4__GetTypeList*>(p->ptr), struct ns4__GetTypeList);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns4__GetTypeList*>(p->ptr), struct ns4__GetTypeList);
		break;
	case SOAP_TYPE_ns4__NewMeasurementResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns4__NewMeasurementResponse*>(p->ptr), struct ns4__NewMeasurementResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns4__NewMeasurementResponse*>(p->ptr), struct ns4__NewMeasurementResponse);
		break;
	case SOAP_TYPE_ns4__NewMeasurement:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns4__NewMeasurement*>(p->ptr), struct ns4__NewMeasurement);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns4__NewMeasurement*>(p->ptr), struct ns4__NewMeasurement);
		break;
	case SOAP_TYPE_ns4__GetTestParametersResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns4__GetTestParametersResponse*>(p->ptr), struct ns4__GetTestParametersResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns4__GetTestParametersResponse*>(p->ptr), struct ns4__GetTestParametersResponse);
		break;
	case SOAP_TYPE_ns4__GetTestParameters:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns4__GetTestParameters*>(p->ptr), struct ns4__GetTestParameters);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns4__GetTestParameters*>(p->ptr), struct ns4__GetTestParameters);
		break;
	case SOAP_TYPE_ns4__SetTestParametersResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns4__SetTestParametersResponse*>(p->ptr), struct ns4__SetTestParametersResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns4__SetTestParametersResponse*>(p->ptr), struct ns4__SetTestParametersResponse);
		break;
	case SOAP_TYPE_ns4__SetTestParameters:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns4__SetTestParameters*>(p->ptr), struct ns4__SetTestParameters);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns4__SetTestParameters*>(p->ptr), struct ns4__SetTestParameters);
		break;
	case SOAP_TYPE_ns4__GetPressTestParametersResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns4__GetPressTestParametersResponse*>(p->ptr), struct ns4__GetPressTestParametersResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns4__GetPressTestParametersResponse*>(p->ptr), struct ns4__GetPressTestParametersResponse);
		break;
	case SOAP_TYPE_ns4__GetPressTestParameters:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns4__GetPressTestParameters*>(p->ptr), struct ns4__GetPressTestParameters);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns4__GetPressTestParameters*>(p->ptr), struct ns4__GetPressTestParameters);
		break;
	case SOAP_TYPE_ns4__SetPressTestParametersResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns4__SetPressTestParametersResponse*>(p->ptr), struct ns4__SetPressTestParametersResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns4__SetPressTestParametersResponse*>(p->ptr), struct ns4__SetPressTestParametersResponse);
		break;
	case SOAP_TYPE_ns4__SetPressTestParameters:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns4__SetPressTestParameters*>(p->ptr), struct ns4__SetPressTestParameters);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns4__SetPressTestParameters*>(p->ptr), struct ns4__SetPressTestParameters);
		break;
	case SOAP_TYPE_ns4__StartResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns4__StartResponse*>(p->ptr), struct ns4__StartResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns4__StartResponse*>(p->ptr), struct ns4__StartResponse);
		break;
	case SOAP_TYPE_ns4__Start:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns4__Start*>(p->ptr), struct ns4__Start);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns4__Start*>(p->ptr), struct ns4__Start);
		break;
	case SOAP_TYPE_ns4__StopResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns4__StopResponse*>(p->ptr), struct ns4__StopResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns4__StopResponse*>(p->ptr), struct ns4__StopResponse);
		break;
	case SOAP_TYPE_ns4__Stop:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns4__Stop*>(p->ptr), struct ns4__Stop);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns4__Stop*>(p->ptr), struct ns4__Stop);
		break;
	case SOAP_TYPE_ns4__ContinueResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns4__ContinueResponse*>(p->ptr), struct ns4__ContinueResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns4__ContinueResponse*>(p->ptr), struct ns4__ContinueResponse);
		break;
	case SOAP_TYPE_ns4__Continue:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns4__Continue*>(p->ptr), struct ns4__Continue);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns4__Continue*>(p->ptr), struct ns4__Continue);
		break;
	case SOAP_TYPE_ns4__GetStatusResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns4__GetStatusResponse*>(p->ptr), struct ns4__GetStatusResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns4__GetStatusResponse*>(p->ptr), struct ns4__GetStatusResponse);
		break;
	case SOAP_TYPE_ns4__GetStatus:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns4__GetStatus*>(p->ptr), struct ns4__GetStatus);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns4__GetStatus*>(p->ptr), struct ns4__GetStatus);
		break;
	case SOAP_TYPE_ns4__SetMetersDataResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns4__SetMetersDataResponse*>(p->ptr), struct ns4__SetMetersDataResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns4__SetMetersDataResponse*>(p->ptr), struct ns4__SetMetersDataResponse);
		break;
	case SOAP_TYPE_ns4__SetMetersData:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns4__SetMetersData*>(p->ptr), struct ns4__SetMetersData);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns4__SetMetersData*>(p->ptr), struct ns4__SetMetersData);
		break;
	case SOAP_TYPE_ns4__GetMetersDataResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns4__GetMetersDataResponse*>(p->ptr), struct ns4__GetMetersDataResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns4__GetMetersDataResponse*>(p->ptr), struct ns4__GetMetersDataResponse);
		break;
	case SOAP_TYPE_ns4__GetMetersData:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns4__GetMetersData*>(p->ptr), struct ns4__GetMetersData);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns4__GetMetersData*>(p->ptr), struct ns4__GetMetersData);
		break;
	case SOAP_TYPE_ns4__GetMeterDataResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns4__GetMeterDataResponse*>(p->ptr), struct ns4__GetMeterDataResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns4__GetMeterDataResponse*>(p->ptr), struct ns4__GetMeterDataResponse);
		break;
	case SOAP_TYPE_ns4__GetMeterData:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns4__GetMeterData*>(p->ptr), struct ns4__GetMeterData);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns4__GetMeterData*>(p->ptr), struct ns4__GetMeterData);
		break;
	case SOAP_TYPE_ns4__SetMeterIndicationsResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns4__SetMeterIndicationsResponse*>(p->ptr), struct ns4__SetMeterIndicationsResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns4__SetMeterIndicationsResponse*>(p->ptr), struct ns4__SetMeterIndicationsResponse);
		break;
	case SOAP_TYPE_ns4__SetMeterIndications:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns4__SetMeterIndications*>(p->ptr), struct ns4__SetMeterIndications);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns4__SetMeterIndications*>(p->ptr), struct ns4__SetMeterIndications);
		break;
	case SOAP_TYPE_ns4__GetMeterPositionsResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns4__GetMeterPositionsResponse*>(p->ptr), struct ns4__GetMeterPositionsResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns4__GetMeterPositionsResponse*>(p->ptr), struct ns4__GetMeterPositionsResponse);
		break;
	case SOAP_TYPE_ns4__GetMeterPositions:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns4__GetMeterPositions*>(p->ptr), struct ns4__GetMeterPositions);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns4__GetMeterPositions*>(p->ptr), struct ns4__GetMeterPositions);
		break;
	case SOAP_TYPE_ns4__GetMeasurementDataResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns4__GetMeasurementDataResponse*>(p->ptr), struct ns4__GetMeasurementDataResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns4__GetMeasurementDataResponse*>(p->ptr), struct ns4__GetMeasurementDataResponse);
		break;
	case SOAP_TYPE_ns4__GetMeasurementData:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns4__GetMeasurementData*>(p->ptr), struct ns4__GetMeasurementData);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns4__GetMeasurementData*>(p->ptr), struct ns4__GetMeasurementData);
		break;
	case SOAP_TYPE_ns4__GetTestResultsResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns4__GetTestResultsResponse*>(p->ptr), struct ns4__GetTestResultsResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns4__GetTestResultsResponse*>(p->ptr), struct ns4__GetTestResultsResponse);
		break;
	case SOAP_TYPE_ns4__GetTestResults:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns4__GetTestResults*>(p->ptr), struct ns4__GetTestResults);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns4__GetTestResults*>(p->ptr), struct ns4__GetTestResults);
		break;
	case SOAP_TYPE_ns4__GetMeterResultResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns4__GetMeterResultResponse*>(p->ptr), struct ns4__GetMeterResultResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns4__GetMeterResultResponse*>(p->ptr), struct ns4__GetMeterResultResponse);
		break;
	case SOAP_TYPE_ns4__GetMeterResult:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns4__GetMeterResult*>(p->ptr), struct ns4__GetMeterResult);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns4__GetMeterResult*>(p->ptr), struct ns4__GetMeterResult);
		break;
	case SOAP_TYPE_ns4__GetTestResultResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns4__GetTestResultResponse*>(p->ptr), struct ns4__GetTestResultResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns4__GetTestResultResponse*>(p->ptr), struct ns4__GetTestResultResponse);
		break;
	case SOAP_TYPE_ns4__GetTestResult:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns4__GetTestResult*>(p->ptr), struct ns4__GetTestResult);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns4__GetTestResult*>(p->ptr), struct ns4__GetTestResult);
		break;
	case SOAP_TYPE_ns4__GetPressTestResultResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns4__GetPressTestResultResponse*>(p->ptr), struct ns4__GetPressTestResultResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns4__GetPressTestResultResponse*>(p->ptr), struct ns4__GetPressTestResultResponse);
		break;
	case SOAP_TYPE_ns4__GetPressTestResult:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns4__GetPressTestResult*>(p->ptr), struct ns4__GetPressTestResult);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns4__GetPressTestResult*>(p->ptr), struct ns4__GetPressTestResult);
		break;
	case SOAP_TYPE_ns4__GetTestConfigurationResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns4__GetTestConfigurationResponse*>(p->ptr), struct ns4__GetTestConfigurationResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns4__GetTestConfigurationResponse*>(p->ptr), struct ns4__GetTestConfigurationResponse);
		break;
	case SOAP_TYPE_ns4__GetTestConfiguration:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns4__GetTestConfiguration*>(p->ptr), struct ns4__GetTestConfiguration);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns4__GetTestConfiguration*>(p->ptr), struct ns4__GetTestConfiguration);
		break;
	case SOAP_TYPE_ns4__SetTestConfigurationResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns4__SetTestConfigurationResponse*>(p->ptr), struct ns4__SetTestConfigurationResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns4__SetTestConfigurationResponse*>(p->ptr), struct ns4__SetTestConfigurationResponse);
		break;
	case SOAP_TYPE_ns4__SetTestConfiguration:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns4__SetTestConfiguration*>(p->ptr), struct ns4__SetTestConfiguration);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns4__SetTestConfiguration*>(p->ptr), struct ns4__SetTestConfiguration);
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Header*>(p->ptr), struct SOAP_ENV__Header);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Header*>(p->ptr), struct SOAP_ENV__Header);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Code*>(p->ptr), struct SOAP_ENV__Code);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Code*>(p->ptr), struct SOAP_ENV__Code);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Detail*>(p->ptr), struct SOAP_ENV__Detail);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Detail*>(p->ptr), struct SOAP_ENV__Detail);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Reason*>(p->ptr), struct SOAP_ENV__Reason);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Reason*>(p->ptr), struct SOAP_ENV__Reason);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Fault*>(p->ptr), struct SOAP_ENV__Fault);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Fault*>(p->ptr), struct SOAP_ENV__Fault);
		break;
#endif
	default:
		return SOAP_ERR;
	}
	return SOAP_OK;
}

#ifdef WIN32
#pragma warning(push)
// do not warn on switch w/o cases
#pragma warning(disable:4065)
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_fbase(int t, int b)
{
	(void)t; (void)b; /* appease -Wall -Werror */
	return 0;
}
#ifdef WIN32
#pragma warning(pop)
#endif

#ifndef WITH_NOIDREF
#ifdef WIN32
#pragma warning(push)
// do not warn on switch w/o cases
#pragma warning(disable:4065)
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_finsert(struct soap *soap, int t, int tt, void *p, size_t index, const void *q, void **x)
{
	(void)soap; (void)t; (void)p; (void)index; (void)q; (void)x; /* appease -Wall -Werror */
	switch (tt)
	{
	case SOAP_TYPE_SOAP_ENC__Array:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy SOAP_ENC__Array type=%d location=%p object=%p\n", t, p, q));
		*(SOAP_ENC__Array*)p = *(SOAP_ENC__Array*)q;
		break;
	case SOAP_TYPE_ns3__TTestParameters:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__TTestParameters type=%d location=%p object=%p\n", t, p, q));
		*(ns3__TTestParameters*)p = *(ns3__TTestParameters*)q;
		break;
	case SOAP_TYPE_ns3__TPressTestParameters:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__TPressTestParameters type=%d location=%p object=%p\n", t, p, q));
		*(ns3__TPressTestParameters*)p = *(ns3__TPressTestParameters*)q;
		break;
	case SOAP_TYPE_ns3__TWaitEvents:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__TWaitEvents type=%d location=%p object=%p\n", t, p, q));
		*(ns3__TWaitEvents*)p = *(ns3__TWaitEvents*)q;
		break;
	case SOAP_TYPE_std__string:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_ns3__TStatus:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__TStatus type=%d location=%p object=%p\n", t, p, q));
		*(ns3__TStatus*)p = *(ns3__TStatus*)q;
		break;
	case SOAP_TYPE_ns3__TMeterData:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__TMeterData type=%d location=%p object=%p\n", t, p, q));
		*(ns3__TMeterData*)p = *(ns3__TMeterData*)q;
		break;
	case SOAP_TYPE_ns3__TMeterIndication:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__TMeterIndication type=%d location=%p object=%p\n", t, p, q));
		*(ns3__TMeterIndication*)p = *(ns3__TMeterIndication*)q;
		break;
	case SOAP_TYPE_ns3__TMeasurementData:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__TMeasurementData type=%d location=%p object=%p\n", t, p, q));
		*(ns3__TMeasurementData*)p = *(ns3__TMeasurementData*)q;
		break;
	case SOAP_TYPE_ns3__TTestResults:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__TTestResults type=%d location=%p object=%p\n", t, p, q));
		*(ns3__TTestResults*)p = *(ns3__TTestResults*)q;
		break;
	case SOAP_TYPE_ns3__TMeterResult:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__TMeterResult type=%d location=%p object=%p\n", t, p, q));
		*(ns3__TMeterResult*)p = *(ns3__TMeterResult*)q;
		break;
	case SOAP_TYPE_ns3__TTestResult:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__TTestResult type=%d location=%p object=%p\n", t, p, q));
		*(ns3__TTestResult*)p = *(ns3__TTestResult*)q;
		break;
	case SOAP_TYPE_ns3__TPressTestResult:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__TPressTestResult type=%d location=%p object=%p\n", t, p, q));
		*(ns3__TPressTestResult*)p = *(ns3__TPressTestResult*)q;
		break;
	case SOAP_TYPE_TStringDynArray:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy TStringDynArray type=%d location=%p object=%p\n", t, p, q));
		*(TStringDynArray*)p = *(TStringDynArray*)q;
		break;
	case SOAP_TYPE_TIntegerDynArray:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy TIntegerDynArray type=%d location=%p object=%p\n", t, p, q));
		*(TIntegerDynArray*)p = *(TIntegerDynArray*)q;
		break;
	case SOAP_TYPE_TBooleanDynArray:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy TBooleanDynArray type=%d location=%p object=%p\n", t, p, q));
		*(TBooleanDynArray*)p = *(TBooleanDynArray*)q;
		break;
	case SOAP_TYPE_TMetersData:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy TMetersData type=%d location=%p object=%p\n", t, p, q));
		*(TMetersData*)p = *(TMetersData*)q;
		break;
	case SOAP_TYPE_TMeterIndications:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy TMeterIndications type=%d location=%p object=%p\n", t, p, q));
		*(TMeterIndications*)p = *(TMeterIndications*)q;
		break;
	case SOAP_TYPE_TMeterResults:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy TMeterResults type=%d location=%p object=%p\n", t, p, q));
		*(TMeterResults*)p = *(TMeterResults*)q;
		break;
	case SOAP_TYPE_ns4__GetTypeListResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns4__GetTypeListResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns4__GetTypeListResponse*)p = *(struct ns4__GetTypeListResponse*)q;
		break;
	case SOAP_TYPE_ns4__GetTypeList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns4__GetTypeList type=%d location=%p object=%p\n", t, p, q));
		*(struct ns4__GetTypeList*)p = *(struct ns4__GetTypeList*)q;
		break;
	case SOAP_TYPE_ns4__NewMeasurementResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns4__NewMeasurementResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns4__NewMeasurementResponse*)p = *(struct ns4__NewMeasurementResponse*)q;
		break;
	case SOAP_TYPE_ns4__NewMeasurement:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns4__NewMeasurement type=%d location=%p object=%p\n", t, p, q));
		*(struct ns4__NewMeasurement*)p = *(struct ns4__NewMeasurement*)q;
		break;
	case SOAP_TYPE_ns4__GetTestParametersResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns4__GetTestParametersResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns4__GetTestParametersResponse*)p = *(struct ns4__GetTestParametersResponse*)q;
		break;
	case SOAP_TYPE_ns4__GetTestParameters:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns4__GetTestParameters type=%d location=%p object=%p\n", t, p, q));
		*(struct ns4__GetTestParameters*)p = *(struct ns4__GetTestParameters*)q;
		break;
	case SOAP_TYPE_ns4__SetTestParametersResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns4__SetTestParametersResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns4__SetTestParametersResponse*)p = *(struct ns4__SetTestParametersResponse*)q;
		break;
	case SOAP_TYPE_ns4__SetTestParameters:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns4__SetTestParameters type=%d location=%p object=%p\n", t, p, q));
		*(struct ns4__SetTestParameters*)p = *(struct ns4__SetTestParameters*)q;
		break;
	case SOAP_TYPE_ns4__GetPressTestParametersResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns4__GetPressTestParametersResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns4__GetPressTestParametersResponse*)p = *(struct ns4__GetPressTestParametersResponse*)q;
		break;
	case SOAP_TYPE_ns4__GetPressTestParameters:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns4__GetPressTestParameters type=%d location=%p object=%p\n", t, p, q));
		*(struct ns4__GetPressTestParameters*)p = *(struct ns4__GetPressTestParameters*)q;
		break;
	case SOAP_TYPE_ns4__SetPressTestParametersResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns4__SetPressTestParametersResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns4__SetPressTestParametersResponse*)p = *(struct ns4__SetPressTestParametersResponse*)q;
		break;
	case SOAP_TYPE_ns4__SetPressTestParameters:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns4__SetPressTestParameters type=%d location=%p object=%p\n", t, p, q));
		*(struct ns4__SetPressTestParameters*)p = *(struct ns4__SetPressTestParameters*)q;
		break;
	case SOAP_TYPE_ns4__StartResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns4__StartResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns4__StartResponse*)p = *(struct ns4__StartResponse*)q;
		break;
	case SOAP_TYPE_ns4__Start:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns4__Start type=%d location=%p object=%p\n", t, p, q));
		*(struct ns4__Start*)p = *(struct ns4__Start*)q;
		break;
	case SOAP_TYPE_ns4__StopResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns4__StopResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns4__StopResponse*)p = *(struct ns4__StopResponse*)q;
		break;
	case SOAP_TYPE_ns4__Stop:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns4__Stop type=%d location=%p object=%p\n", t, p, q));
		*(struct ns4__Stop*)p = *(struct ns4__Stop*)q;
		break;
	case SOAP_TYPE_ns4__ContinueResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns4__ContinueResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns4__ContinueResponse*)p = *(struct ns4__ContinueResponse*)q;
		break;
	case SOAP_TYPE_ns4__Continue:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns4__Continue type=%d location=%p object=%p\n", t, p, q));
		*(struct ns4__Continue*)p = *(struct ns4__Continue*)q;
		break;
	case SOAP_TYPE_ns4__GetStatusResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns4__GetStatusResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns4__GetStatusResponse*)p = *(struct ns4__GetStatusResponse*)q;
		break;
	case SOAP_TYPE_ns4__GetStatus:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns4__GetStatus type=%d location=%p object=%p\n", t, p, q));
		*(struct ns4__GetStatus*)p = *(struct ns4__GetStatus*)q;
		break;
	case SOAP_TYPE_ns4__SetMetersDataResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns4__SetMetersDataResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns4__SetMetersDataResponse*)p = *(struct ns4__SetMetersDataResponse*)q;
		break;
	case SOAP_TYPE_ns4__SetMetersData:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns4__SetMetersData type=%d location=%p object=%p\n", t, p, q));
		*(struct ns4__SetMetersData*)p = *(struct ns4__SetMetersData*)q;
		break;
	case SOAP_TYPE_ns4__GetMetersDataResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns4__GetMetersDataResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns4__GetMetersDataResponse*)p = *(struct ns4__GetMetersDataResponse*)q;
		break;
	case SOAP_TYPE_ns4__GetMetersData:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns4__GetMetersData type=%d location=%p object=%p\n", t, p, q));
		*(struct ns4__GetMetersData*)p = *(struct ns4__GetMetersData*)q;
		break;
	case SOAP_TYPE_ns4__GetMeterDataResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns4__GetMeterDataResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns4__GetMeterDataResponse*)p = *(struct ns4__GetMeterDataResponse*)q;
		break;
	case SOAP_TYPE_ns4__GetMeterData:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns4__GetMeterData type=%d location=%p object=%p\n", t, p, q));
		*(struct ns4__GetMeterData*)p = *(struct ns4__GetMeterData*)q;
		break;
	case SOAP_TYPE_ns4__SetMeterIndicationsResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns4__SetMeterIndicationsResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns4__SetMeterIndicationsResponse*)p = *(struct ns4__SetMeterIndicationsResponse*)q;
		break;
	case SOAP_TYPE_ns4__SetMeterIndications:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns4__SetMeterIndications type=%d location=%p object=%p\n", t, p, q));
		*(struct ns4__SetMeterIndications*)p = *(struct ns4__SetMeterIndications*)q;
		break;
	case SOAP_TYPE_ns4__GetMeterPositionsResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns4__GetMeterPositionsResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns4__GetMeterPositionsResponse*)p = *(struct ns4__GetMeterPositionsResponse*)q;
		break;
	case SOAP_TYPE_ns4__GetMeterPositions:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns4__GetMeterPositions type=%d location=%p object=%p\n", t, p, q));
		*(struct ns4__GetMeterPositions*)p = *(struct ns4__GetMeterPositions*)q;
		break;
	case SOAP_TYPE_ns4__GetMeasurementDataResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns4__GetMeasurementDataResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns4__GetMeasurementDataResponse*)p = *(struct ns4__GetMeasurementDataResponse*)q;
		break;
	case SOAP_TYPE_ns4__GetMeasurementData:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns4__GetMeasurementData type=%d location=%p object=%p\n", t, p, q));
		*(struct ns4__GetMeasurementData*)p = *(struct ns4__GetMeasurementData*)q;
		break;
	case SOAP_TYPE_ns4__GetTestResultsResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns4__GetTestResultsResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns4__GetTestResultsResponse*)p = *(struct ns4__GetTestResultsResponse*)q;
		break;
	case SOAP_TYPE_ns4__GetTestResults:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns4__GetTestResults type=%d location=%p object=%p\n", t, p, q));
		*(struct ns4__GetTestResults*)p = *(struct ns4__GetTestResults*)q;
		break;
	case SOAP_TYPE_ns4__GetMeterResultResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns4__GetMeterResultResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns4__GetMeterResultResponse*)p = *(struct ns4__GetMeterResultResponse*)q;
		break;
	case SOAP_TYPE_ns4__GetMeterResult:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns4__GetMeterResult type=%d location=%p object=%p\n", t, p, q));
		*(struct ns4__GetMeterResult*)p = *(struct ns4__GetMeterResult*)q;
		break;
	case SOAP_TYPE_ns4__GetTestResultResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns4__GetTestResultResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns4__GetTestResultResponse*)p = *(struct ns4__GetTestResultResponse*)q;
		break;
	case SOAP_TYPE_ns4__GetTestResult:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns4__GetTestResult type=%d location=%p object=%p\n", t, p, q));
		*(struct ns4__GetTestResult*)p = *(struct ns4__GetTestResult*)q;
		break;
	case SOAP_TYPE_ns4__GetPressTestResultResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns4__GetPressTestResultResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns4__GetPressTestResultResponse*)p = *(struct ns4__GetPressTestResultResponse*)q;
		break;
	case SOAP_TYPE_ns4__GetPressTestResult:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns4__GetPressTestResult type=%d location=%p object=%p\n", t, p, q));
		*(struct ns4__GetPressTestResult*)p = *(struct ns4__GetPressTestResult*)q;
		break;
	case SOAP_TYPE_ns4__GetTestConfigurationResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns4__GetTestConfigurationResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns4__GetTestConfigurationResponse*)p = *(struct ns4__GetTestConfigurationResponse*)q;
		break;
	case SOAP_TYPE_ns4__GetTestConfiguration:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns4__GetTestConfiguration type=%d location=%p object=%p\n", t, p, q));
		*(struct ns4__GetTestConfiguration*)p = *(struct ns4__GetTestConfiguration*)q;
		break;
	case SOAP_TYPE_ns4__SetTestConfigurationResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns4__SetTestConfigurationResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns4__SetTestConfigurationResponse*)p = *(struct ns4__SetTestConfigurationResponse*)q;
		break;
	case SOAP_TYPE_ns4__SetTestConfiguration:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns4__SetTestConfiguration type=%d location=%p object=%p\n", t, p, q));
		*(struct ns4__SetTestConfiguration*)p = *(struct ns4__SetTestConfiguration*)q;
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Header type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Code type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Detail type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Reason type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Fault type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
		break;
#endif
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type=%d in %d\n", t, tt));
	}
}
#ifdef WIN32
#pragma warning(pop)
#endif
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{
	a = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return a;
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_new_byte(struct soap *soap, int n)
{
	char *a = static_cast<char *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(char)));
	for (char *p = a; p && n--; ++p)
		soap_default_byte(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	if (soap_out_byte(soap, tag ? tag : "byte", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{
	a = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return a;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_new_int(struct soap *soap, int n)
{
	int *a = static_cast<int *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(int)));
	for (int *p = a; p && n--; ++p)
		soap_default_int(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	if (soap_out_int(soap, tag ? tag : "int", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_double(struct soap *soap, const char *tag, int id, const double *a, const char *type)
{
	return soap_outdouble(soap, tag, id, a, type, SOAP_TYPE_double);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_in_double(struct soap *soap, const char *tag, double *a, const char *type)
{
	a = soap_indouble(soap, tag, a, type, SOAP_TYPE_double);
	return a;
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_new_double(struct soap *soap, int n)
{
	double *a = static_cast<double *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(double)));
	for (double *p = a; p && n--; ++p)
		soap_default_double(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_double(struct soap *soap, const double *a, const char *tag, const char *type)
{
	if (soap_out_double(soap, tag ? tag : "double", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_get_double(struct soap *soap, double *p, const char *tag, const char *type)
{
	if ((p = soap_in_double(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_bool[] =
{	{ (LONG64)false, "false" },
	{ (LONG64)true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_bool2s(struct soap *soap, bool n)
{
	(void)soap; /* appease -Wall -Werror */
	return soap_code_str(soap_codes_bool, n != 0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bool(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bool), type) || soap_send(soap, soap_bool2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2bool(struct soap *soap, const char *s, bool *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_bool, s);
	if (map)
		*a = (bool)(map->code != 0);
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (bool)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_bool(struct soap *soap, const char *tag, bool *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (bool*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bool, sizeof(bool), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2bool(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (bool *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bool, SOAP_TYPE_bool, sizeof(bool), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_new_bool(struct soap *soap, int n)
{
	bool *a = static_cast<bool *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(bool)));
	for (bool *p = a; p && n--; ++p)
		soap_default_bool(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bool(struct soap *soap, const bool *a, const char *tag, const char *type)
{
	if (soap_out_bool(soap, tag ? tag : "boolean", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_bool(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if ((p = soap_in_bool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_ns3__TPulseCheck[] =
{	{ (LONG64)ns3__TPulseCheck__pcNotUsed, "pcNotUsed" },
	{ (LONG64)ns3__TPulseCheck__pcPass, "pcPass" },
	{ (LONG64)ns3__TPulseCheck__pcFail, "pcFail" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns3__TPulseCheck2s(struct soap *soap, enum ns3__TPulseCheck n)
{
	const char *s = soap_code_str(soap_codes_ns3__TPulseCheck, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__TPulseCheck(struct soap *soap, const char *tag, int id, const enum ns3__TPulseCheck *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__TPulseCheck), type) || soap_send(soap, soap_ns3__TPulseCheck2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns3__TPulseCheck(struct soap *soap, const char *s, enum ns3__TPulseCheck *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns3__TPulseCheck, s);
	if (map)
		*a = (enum ns3__TPulseCheck)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 2)
			return soap->error = SOAP_TYPE;
		*a = (enum ns3__TPulseCheck)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns3__TPulseCheck * SOAP_FMAC4 soap_in_ns3__TPulseCheck(struct soap *soap, const char *tag, enum ns3__TPulseCheck *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns3__TPulseCheck*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__TPulseCheck, sizeof(enum ns3__TPulseCheck), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2ns3__TPulseCheck(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum ns3__TPulseCheck *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__TPulseCheck, SOAP_TYPE_ns3__TPulseCheck, sizeof(enum ns3__TPulseCheck), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum ns3__TPulseCheck * SOAP_FMAC4 soap_new_ns3__TPulseCheck(struct soap *soap, int n)
{
	enum ns3__TPulseCheck *a = static_cast<enum ns3__TPulseCheck *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum ns3__TPulseCheck)));
	for (enum ns3__TPulseCheck *p = a; p && n--; ++p)
		soap_default_ns3__TPulseCheck(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__TPulseCheck(struct soap *soap, const enum ns3__TPulseCheck *a, const char *tag, const char *type)
{
	if (soap_out_ns3__TPulseCheck(soap, tag ? tag : "ns3:TPulseCheck", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns3__TPulseCheck * SOAP_FMAC4 soap_get_ns3__TPulseCheck(struct soap *soap, enum ns3__TPulseCheck *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__TPulseCheck(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_ns3__TStatusCode[] =
{	{ (LONG64)ns3__TStatusCode__stReady, "stReady" },
	{ (LONG64)ns3__TStatusCode__stError, "stError" },
	{ (LONG64)ns3__TStatusCode__stPrepare, "stPrepare" },
	{ (LONG64)ns3__TStatusCode__stTest, "stTest" },
	{ (LONG64)ns3__TStatusCode__stStartTestWait, "stStartTestWait" },
	{ (LONG64)ns3__TStatusCode__stStopTestWait, "stStopTestWait" },
	{ (LONG64)ns3__TStatusCode__stBusy, "stBusy" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns3__TStatusCode2s(struct soap *soap, enum ns3__TStatusCode n)
{
	const char *s = soap_code_str(soap_codes_ns3__TStatusCode, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__TStatusCode(struct soap *soap, const char *tag, int id, const enum ns3__TStatusCode *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__TStatusCode), type) || soap_send(soap, soap_ns3__TStatusCode2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns3__TStatusCode(struct soap *soap, const char *s, enum ns3__TStatusCode *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns3__TStatusCode, s);
	if (map)
		*a = (enum ns3__TStatusCode)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 6)
			return soap->error = SOAP_TYPE;
		*a = (enum ns3__TStatusCode)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns3__TStatusCode * SOAP_FMAC4 soap_in_ns3__TStatusCode(struct soap *soap, const char *tag, enum ns3__TStatusCode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns3__TStatusCode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__TStatusCode, sizeof(enum ns3__TStatusCode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2ns3__TStatusCode(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum ns3__TStatusCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__TStatusCode, SOAP_TYPE_ns3__TStatusCode, sizeof(enum ns3__TStatusCode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum ns3__TStatusCode * SOAP_FMAC4 soap_new_ns3__TStatusCode(struct soap *soap, int n)
{
	enum ns3__TStatusCode *a = static_cast<enum ns3__TStatusCode *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum ns3__TStatusCode)));
	for (enum ns3__TStatusCode *p = a; p && n--; ++p)
		soap_default_ns3__TStatusCode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__TStatusCode(struct soap *soap, const enum ns3__TStatusCode *a, const char *tag, const char *type)
{
	if (soap_out_ns3__TStatusCode(soap, tag ? tag : "ns3:TStatusCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns3__TStatusCode * SOAP_FMAC4 soap_get_ns3__TStatusCode(struct soap *soap, enum ns3__TStatusCode *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__TStatusCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_ns3__TMeterIndicationMethod[] =
{	{ (LONG64)ns3__TMeterIndicationMethod__miPulses, "miPulses" },
	{ (LONG64)ns3__TMeterIndicationMethod__miSyncPulses, "miSyncPulses" },
	{ (LONG64)ns3__TMeterIndicationMethod__miInterpPulses, "miInterpPulses" },
	{ (LONG64)ns3__TMeterIndicationMethod__miManual, "miManual" },
	{ (LONG64)ns3__TMeterIndicationMethod__miNone, "miNone" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns3__TMeterIndicationMethod2s(struct soap *soap, enum ns3__TMeterIndicationMethod n)
{
	const char *s = soap_code_str(soap_codes_ns3__TMeterIndicationMethod, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__TMeterIndicationMethod(struct soap *soap, const char *tag, int id, const enum ns3__TMeterIndicationMethod *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__TMeterIndicationMethod), type) || soap_send(soap, soap_ns3__TMeterIndicationMethod2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns3__TMeterIndicationMethod(struct soap *soap, const char *s, enum ns3__TMeterIndicationMethod *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns3__TMeterIndicationMethod, s);
	if (map)
		*a = (enum ns3__TMeterIndicationMethod)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 4)
			return soap->error = SOAP_TYPE;
		*a = (enum ns3__TMeterIndicationMethod)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns3__TMeterIndicationMethod * SOAP_FMAC4 soap_in_ns3__TMeterIndicationMethod(struct soap *soap, const char *tag, enum ns3__TMeterIndicationMethod *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns3__TMeterIndicationMethod*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__TMeterIndicationMethod, sizeof(enum ns3__TMeterIndicationMethod), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2ns3__TMeterIndicationMethod(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum ns3__TMeterIndicationMethod *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__TMeterIndicationMethod, SOAP_TYPE_ns3__TMeterIndicationMethod, sizeof(enum ns3__TMeterIndicationMethod), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum ns3__TMeterIndicationMethod * SOAP_FMAC4 soap_new_ns3__TMeterIndicationMethod(struct soap *soap, int n)
{
	enum ns3__TMeterIndicationMethod *a = static_cast<enum ns3__TMeterIndicationMethod *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum ns3__TMeterIndicationMethod)));
	for (enum ns3__TMeterIndicationMethod *p = a; p && n--; ++p)
		soap_default_ns3__TMeterIndicationMethod(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__TMeterIndicationMethod(struct soap *soap, const enum ns3__TMeterIndicationMethod *a, const char *tag, const char *type)
{
	if (soap_out_ns3__TMeterIndicationMethod(soap, tag ? tag : "ns3:TMeterIndicationMethod", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns3__TMeterIndicationMethod * SOAP_FMAC4 soap_get_ns3__TMeterIndicationMethod(struct soap *soap, enum ns3__TMeterIndicationMethod *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__TMeterIndicationMethod(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_ns3__TProofMethod[] =
{	{ (LONG64)ns3__TProofMethod__pmFlyGra, "pmFlyGra" },
	{ (LONG64)ns3__TProofMethod__pmFlyMID, "pmFlyMID" },
	{ (LONG64)ns3__TProofMethod__pmStdGra, "pmStdGra" },
	{ (LONG64)ns3__TProofMethod__pmStdMid, "pmStdMid" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns3__TProofMethod2s(struct soap *soap, enum ns3__TProofMethod n)
{
	const char *s = soap_code_str(soap_codes_ns3__TProofMethod, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__TProofMethod(struct soap *soap, const char *tag, int id, const enum ns3__TProofMethod *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__TProofMethod), type) || soap_send(soap, soap_ns3__TProofMethod2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns3__TProofMethod(struct soap *soap, const char *s, enum ns3__TProofMethod *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns3__TProofMethod, s);
	if (map)
		*a = (enum ns3__TProofMethod)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 3)
			return soap->error = SOAP_TYPE;
		*a = (enum ns3__TProofMethod)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns3__TProofMethod * SOAP_FMAC4 soap_in_ns3__TProofMethod(struct soap *soap, const char *tag, enum ns3__TProofMethod *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns3__TProofMethod*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__TProofMethod, sizeof(enum ns3__TProofMethod), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2ns3__TProofMethod(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum ns3__TProofMethod *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__TProofMethod, SOAP_TYPE_ns3__TProofMethod, sizeof(enum ns3__TProofMethod), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum ns3__TProofMethod * SOAP_FMAC4 soap_new_ns3__TProofMethod(struct soap *soap, int n)
{
	enum ns3__TProofMethod *a = static_cast<enum ns3__TProofMethod *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum ns3__TProofMethod)));
	for (enum ns3__TProofMethod *p = a; p && n--; ++p)
		soap_default_ns3__TProofMethod(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__TProofMethod(struct soap *soap, const enum ns3__TProofMethod *a, const char *tag, const char *type)
{
	if (soap_out_ns3__TProofMethod(soap, tag ? tag : "ns3:TProofMethod", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns3__TProofMethod * SOAP_FMAC4 soap_get_ns3__TProofMethod(struct soap *soap, enum ns3__TProofMethod *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__TProofMethod(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_ns3__TResult[] =
{	{ (LONG64)ns3__TResult__rsOK, "rsOK" },
	{ (LONG64)ns3__TResult__rsPositionOutOfRange, "rsPositionOutOfRange" },
	{ (LONG64)ns3__TResult__rsNotApplicable, "rsNotApplicable" },
	{ (LONG64)ns3__TResult__rsTestNotFound, "rsTestNotFound" },
	{ (LONG64)ns3__TResult__rsInvalidParameter, "rsInvalidParameter" },
	{ (LONG64)ns3__TResult__rsTestAlreadyExists, "rsTestAlreadyExists" },
	{ (LONG64)ns3__TResult__rsTypeNotFound, "rsTypeNotFound" },
	{ (LONG64)ns3__TResult__rsBenchNotFound, "rsBenchNotFound" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns3__TResult2s(struct soap *soap, enum ns3__TResult n)
{
	const char *s = soap_code_str(soap_codes_ns3__TResult, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__TResult(struct soap *soap, const char *tag, int id, const enum ns3__TResult *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__TResult), type) || soap_send(soap, soap_ns3__TResult2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns3__TResult(struct soap *soap, const char *s, enum ns3__TResult *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns3__TResult, s);
	if (map)
		*a = (enum ns3__TResult)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 7)
			return soap->error = SOAP_TYPE;
		*a = (enum ns3__TResult)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns3__TResult * SOAP_FMAC4 soap_in_ns3__TResult(struct soap *soap, const char *tag, enum ns3__TResult *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns3__TResult*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__TResult, sizeof(enum ns3__TResult), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2ns3__TResult(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum ns3__TResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__TResult, SOAP_TYPE_ns3__TResult, sizeof(enum ns3__TResult), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum ns3__TResult * SOAP_FMAC4 soap_new_ns3__TResult(struct soap *soap, int n)
{
	enum ns3__TResult *a = static_cast<enum ns3__TResult *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum ns3__TResult)));
	for (enum ns3__TResult *p = a; p && n--; ++p)
		soap_default_ns3__TResult(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__TResult(struct soap *soap, const enum ns3__TResult *a, const char *tag, const char *type)
{
	if (soap_out_ns3__TResult(soap, tag ? tag : "ns3:TResult", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns3__TResult * SOAP_FMAC4 soap_get_ns3__TResult(struct soap *soap, enum ns3__TResult *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__TResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__string(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__string(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_std__string), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_std__string(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_std__string, SOAP_TYPE_std__string, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_instantiate_std__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__string(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::string *p;
	size_t k = sizeof(std::string);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__string, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::string);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::string, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::string location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__string(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_std__string(soap, tag ? tag : "string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_std__string(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_std__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__TPressTestResult::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->ns3__TPressTestResult::Done);
	soap_default_std__string(soap, &this->ns3__TPressTestResult::TestName);
	soap_default_double(soap, &this->ns3__TPressTestResult::StartPress);
	soap_default_double(soap, &this->ns3__TPressTestResult::PressDrop);
	soap_default_bool(soap, &this->ns3__TPressTestResult::Passed);
}

void ns3__TPressTestResult::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns3__TPressTestResult::Done, SOAP_TYPE_bool);
	soap_embedded(soap, &this->ns3__TPressTestResult::TestName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns3__TPressTestResult::TestName);
	soap_embedded(soap, &this->ns3__TPressTestResult::Passed, SOAP_TYPE_bool);
#endif
}

int ns3__TPressTestResult::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__TPressTestResult(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__TPressTestResult(struct soap *soap, const char *tag, int id, const ns3__TPressTestResult *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__TPressTestResult), type))
		return soap->error;
	if (soap_out_bool(soap, "Done", -1, &a->ns3__TPressTestResult::Done, ""))
		return soap->error;
	if (soap_out_std__string(soap, "TestName", -1, &a->ns3__TPressTestResult::TestName, ""))
		return soap->error;
	if (soap_out_double(soap, "StartPress", -1, &a->ns3__TPressTestResult::StartPress, ""))
		return soap->error;
	if (soap_out_double(soap, "PressDrop", -1, &a->ns3__TPressTestResult::PressDrop, ""))
		return soap->error;
	if (soap_out_bool(soap, "Passed", -1, &a->ns3__TPressTestResult::Passed, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__TPressTestResult::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns3__TPressTestResult(soap, tag, this, type);
}

SOAP_FMAC3 ns3__TPressTestResult * SOAP_FMAC4 soap_in_ns3__TPressTestResult(struct soap *soap, const char *tag, ns3__TPressTestResult *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__TPressTestResult*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__TPressTestResult, sizeof(ns3__TPressTestResult), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns3__TPressTestResult)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__TPressTestResult *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Done1 = 1;
	size_t soap_flag_TestName1 = 1;
	size_t soap_flag_StartPress1 = 1;
	size_t soap_flag_PressDrop1 = 1;
	size_t soap_flag_Passed1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Done1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "Done", &a->ns3__TPressTestResult::Done, "xsd:boolean"))
				{	soap_flag_Done1--;
					continue;
				}
			}
			if (soap_flag_TestName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "TestName", &a->ns3__TPressTestResult::TestName, "xsd:string"))
				{	soap_flag_TestName1--;
					continue;
				}
			}
			if (soap_flag_StartPress1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "StartPress", &a->ns3__TPressTestResult::StartPress, "xsd:double"))
				{	soap_flag_StartPress1--;
					continue;
				}
			}
			if (soap_flag_PressDrop1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "PressDrop", &a->ns3__TPressTestResult::PressDrop, "xsd:double"))
				{	soap_flag_PressDrop1--;
					continue;
				}
			}
			if (soap_flag_Passed1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "Passed", &a->ns3__TPressTestResult::Passed, "xsd:boolean"))
				{	soap_flag_Passed1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Done1 > 0 || soap_flag_TestName1 > 0 || soap_flag_StartPress1 > 0 || soap_flag_PressDrop1 > 0 || soap_flag_Passed1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns3__TPressTestResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__TPressTestResult, SOAP_TYPE_ns3__TPressTestResult, sizeof(ns3__TPressTestResult), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__TPressTestResult * SOAP_FMAC2 soap_instantiate_ns3__TPressTestResult(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__TPressTestResult(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__TPressTestResult *p;
	size_t k = sizeof(ns3__TPressTestResult);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns3__TPressTestResult, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns3__TPressTestResult);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns3__TPressTestResult, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__TPressTestResult location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns3__TPressTestResult::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__TPressTestResult(soap, tag ? tag : "ns3:TPressTestResult", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__TPressTestResult::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__TPressTestResult(soap, this, tag, type);
}

SOAP_FMAC3 ns3__TPressTestResult * SOAP_FMAC4 soap_get_ns3__TPressTestResult(struct soap *soap, ns3__TPressTestResult *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__TPressTestResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__TTestResult::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->ns3__TTestResult::Done);
	soap_default_std__string(soap, &this->ns3__TTestResult::TestName);
	soap_default_double(soap, &this->ns3__TTestResult::Flowrate);
	soap_default_double(soap, &this->ns3__TTestResult::Weight);
	soap_default_double(soap, &this->ns3__TTestResult::InletTemp);
	soap_default_double(soap, &this->ns3__TTestResult::OutletTemp);
	soap_default_double(soap, &this->ns3__TTestResult::InletPressure);
	soap_default_double(soap, &this->ns3__TTestResult::OutletPressure);
	soap_default_double(soap, &this->ns3__TTestResult::Lambda);
	soap_default_double(soap, &this->ns3__TTestResult::MIDTemp);
	soap_default_double(soap, &this->ns3__TTestResult::MIDPulseConst);
	soap_default_double(soap, &this->ns3__TTestResult::MIDVolume);
	soap_default_double(soap, &this->ns3__TTestResult::MIDError);
	soap_default_double(soap, &this->ns3__TTestResult::Duration);
	soap_default_double(soap, &this->ns3__TTestResult::AdditiveLambda);
}

void ns3__TTestResult::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns3__TTestResult::Done, SOAP_TYPE_bool);
	soap_embedded(soap, &this->ns3__TTestResult::TestName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns3__TTestResult::TestName);
#endif
}

int ns3__TTestResult::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__TTestResult(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__TTestResult(struct soap *soap, const char *tag, int id, const ns3__TTestResult *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__TTestResult), type))
		return soap->error;
	if (soap_out_bool(soap, "Done", -1, &a->ns3__TTestResult::Done, ""))
		return soap->error;
	if (soap_out_std__string(soap, "TestName", -1, &a->ns3__TTestResult::TestName, ""))
		return soap->error;
	if (soap_out_double(soap, "Flowrate", -1, &a->ns3__TTestResult::Flowrate, ""))
		return soap->error;
	if (soap_out_double(soap, "Weight", -1, &a->ns3__TTestResult::Weight, ""))
		return soap->error;
	if (soap_out_double(soap, "InletTemp", -1, &a->ns3__TTestResult::InletTemp, ""))
		return soap->error;
	if (soap_out_double(soap, "OutletTemp", -1, &a->ns3__TTestResult::OutletTemp, ""))
		return soap->error;
	if (soap_out_double(soap, "InletPressure", -1, &a->ns3__TTestResult::InletPressure, ""))
		return soap->error;
	if (soap_out_double(soap, "OutletPressure", -1, &a->ns3__TTestResult::OutletPressure, ""))
		return soap->error;
	if (soap_out_double(soap, "Lambda", -1, &a->ns3__TTestResult::Lambda, ""))
		return soap->error;
	if (soap_out_double(soap, "MIDTemp", -1, &a->ns3__TTestResult::MIDTemp, ""))
		return soap->error;
	if (soap_out_double(soap, "MIDPulseConst", -1, &a->ns3__TTestResult::MIDPulseConst, ""))
		return soap->error;
	if (soap_out_double(soap, "MIDVolume", -1, &a->ns3__TTestResult::MIDVolume, ""))
		return soap->error;
	if (soap_out_double(soap, "MIDError", -1, &a->ns3__TTestResult::MIDError, ""))
		return soap->error;
	if (soap_out_double(soap, "Duration", -1, &a->ns3__TTestResult::Duration, ""))
		return soap->error;
	if (soap_out_double(soap, "AdditiveLambda", -1, &a->ns3__TTestResult::AdditiveLambda, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__TTestResult::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns3__TTestResult(soap, tag, this, type);
}

SOAP_FMAC3 ns3__TTestResult * SOAP_FMAC4 soap_in_ns3__TTestResult(struct soap *soap, const char *tag, ns3__TTestResult *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__TTestResult*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__TTestResult, sizeof(ns3__TTestResult), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns3__TTestResult)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__TTestResult *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Done1 = 1;
	size_t soap_flag_TestName1 = 1;
	size_t soap_flag_Flowrate1 = 1;
	size_t soap_flag_Weight1 = 1;
	size_t soap_flag_InletTemp1 = 1;
	size_t soap_flag_OutletTemp1 = 1;
	size_t soap_flag_InletPressure1 = 1;
	size_t soap_flag_OutletPressure1 = 1;
	size_t soap_flag_Lambda1 = 1;
	size_t soap_flag_MIDTemp1 = 1;
	size_t soap_flag_MIDPulseConst1 = 1;
	size_t soap_flag_MIDVolume1 = 1;
	size_t soap_flag_MIDError1 = 1;
	size_t soap_flag_Duration1 = 1;
	size_t soap_flag_AdditiveLambda1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Done1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "Done", &a->ns3__TTestResult::Done, "xsd:boolean"))
				{	soap_flag_Done1--;
					continue;
				}
			}
			if (soap_flag_TestName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "TestName", &a->ns3__TTestResult::TestName, "xsd:string"))
				{	soap_flag_TestName1--;
					continue;
				}
			}
			if (soap_flag_Flowrate1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "Flowrate", &a->ns3__TTestResult::Flowrate, "xsd:double"))
				{	soap_flag_Flowrate1--;
					continue;
				}
			}
			if (soap_flag_Weight1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "Weight", &a->ns3__TTestResult::Weight, "xsd:double"))
				{	soap_flag_Weight1--;
					continue;
				}
			}
			if (soap_flag_InletTemp1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "InletTemp", &a->ns3__TTestResult::InletTemp, "xsd:double"))
				{	soap_flag_InletTemp1--;
					continue;
				}
			}
			if (soap_flag_OutletTemp1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "OutletTemp", &a->ns3__TTestResult::OutletTemp, "xsd:double"))
				{	soap_flag_OutletTemp1--;
					continue;
				}
			}
			if (soap_flag_InletPressure1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "InletPressure", &a->ns3__TTestResult::InletPressure, "xsd:double"))
				{	soap_flag_InletPressure1--;
					continue;
				}
			}
			if (soap_flag_OutletPressure1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "OutletPressure", &a->ns3__TTestResult::OutletPressure, "xsd:double"))
				{	soap_flag_OutletPressure1--;
					continue;
				}
			}
			if (soap_flag_Lambda1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "Lambda", &a->ns3__TTestResult::Lambda, "xsd:double"))
				{	soap_flag_Lambda1--;
					continue;
				}
			}
			if (soap_flag_MIDTemp1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "MIDTemp", &a->ns3__TTestResult::MIDTemp, "xsd:double"))
				{	soap_flag_MIDTemp1--;
					continue;
				}
			}
			if (soap_flag_MIDPulseConst1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "MIDPulseConst", &a->ns3__TTestResult::MIDPulseConst, "xsd:double"))
				{	soap_flag_MIDPulseConst1--;
					continue;
				}
			}
			if (soap_flag_MIDVolume1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "MIDVolume", &a->ns3__TTestResult::MIDVolume, "xsd:double"))
				{	soap_flag_MIDVolume1--;
					continue;
				}
			}
			if (soap_flag_MIDError1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "MIDError", &a->ns3__TTestResult::MIDError, "xsd:double"))
				{	soap_flag_MIDError1--;
					continue;
				}
			}
			if (soap_flag_Duration1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "Duration", &a->ns3__TTestResult::Duration, "xsd:double"))
				{	soap_flag_Duration1--;
					continue;
				}
			}
			if (soap_flag_AdditiveLambda1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "AdditiveLambda", &a->ns3__TTestResult::AdditiveLambda, "xsd:double"))
				{	soap_flag_AdditiveLambda1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Done1 > 0 || soap_flag_TestName1 > 0 || soap_flag_Flowrate1 > 0 || soap_flag_Weight1 > 0 || soap_flag_InletTemp1 > 0 || soap_flag_OutletTemp1 > 0 || soap_flag_InletPressure1 > 0 || soap_flag_OutletPressure1 > 0 || soap_flag_Lambda1 > 0 || soap_flag_MIDTemp1 > 0 || soap_flag_MIDPulseConst1 > 0 || soap_flag_MIDVolume1 > 0 || soap_flag_MIDError1 > 0 || soap_flag_Duration1 > 0 || soap_flag_AdditiveLambda1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns3__TTestResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__TTestResult, SOAP_TYPE_ns3__TTestResult, sizeof(ns3__TTestResult), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__TTestResult * SOAP_FMAC2 soap_instantiate_ns3__TTestResult(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__TTestResult(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__TTestResult *p;
	size_t k = sizeof(ns3__TTestResult);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns3__TTestResult, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns3__TTestResult);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns3__TTestResult, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__TTestResult location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns3__TTestResult::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__TTestResult(soap, tag ? tag : "ns3:TTestResult", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__TTestResult::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__TTestResult(soap, this, tag, type);
}

SOAP_FMAC3 ns3__TTestResult * SOAP_FMAC4 soap_get_ns3__TTestResult(struct soap *soap, ns3__TTestResult *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__TTestResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__TMeterResult::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns3__TMeterResult::Position);
	soap_default_double(soap, &this->ns3__TMeterResult::Temperature);
	soap_default_double(soap, &this->ns3__TMeterResult::Pressure);
	soap_default_double(soap, &this->ns3__TMeterResult::Density);
	soap_default_int(soap, &this->ns3__TMeterResult::GatedMIDPulses);
	soap_default_double(soap, &this->ns3__TMeterResult::NominalVolume);
	soap_default_double(soap, &this->ns3__TMeterResult::Pulses);
	soap_default_double(soap, &this->ns3__TMeterResult::PulseConst);
	soap_default_double(soap, &this->ns3__TMeterResult::StartVolume);
	soap_default_double(soap, &this->ns3__TMeterResult::StopVolume);
	soap_default_double(soap, &this->ns3__TMeterResult::IndicatedVolume);
	soap_default_double(soap, &this->ns3__TMeterResult::Error);
	soap_default_ns3__TPulseCheck(soap, &this->ns3__TMeterResult::PulseCheck);
	soap_default_bool(soap, &this->ns3__TMeterResult::Passed);
}

void ns3__TMeterResult::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns3__TMeterResult::Position, SOAP_TYPE_int);
	soap_embedded(soap, &this->ns3__TMeterResult::GatedMIDPulses, SOAP_TYPE_int);
	soap_embedded(soap, &this->ns3__TMeterResult::Passed, SOAP_TYPE_bool);
#endif
}

int ns3__TMeterResult::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__TMeterResult(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__TMeterResult(struct soap *soap, const char *tag, int id, const ns3__TMeterResult *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__TMeterResult), type))
		return soap->error;
	if (soap_out_int(soap, "Position", -1, &a->ns3__TMeterResult::Position, ""))
		return soap->error;
	if (soap_out_double(soap, "Temperature", -1, &a->ns3__TMeterResult::Temperature, ""))
		return soap->error;
	if (soap_out_double(soap, "Pressure", -1, &a->ns3__TMeterResult::Pressure, ""))
		return soap->error;
	if (soap_out_double(soap, "Density", -1, &a->ns3__TMeterResult::Density, ""))
		return soap->error;
	if (soap_out_int(soap, "GatedMIDPulses", -1, &a->ns3__TMeterResult::GatedMIDPulses, ""))
		return soap->error;
	if (soap_out_double(soap, "NominalVolume", -1, &a->ns3__TMeterResult::NominalVolume, ""))
		return soap->error;
	if (soap_out_double(soap, "Pulses", -1, &a->ns3__TMeterResult::Pulses, ""))
		return soap->error;
	if (soap_out_double(soap, "PulseConst", -1, &a->ns3__TMeterResult::PulseConst, ""))
		return soap->error;
	if (soap_out_double(soap, "StartVolume", -1, &a->ns3__TMeterResult::StartVolume, ""))
		return soap->error;
	if (soap_out_double(soap, "StopVolume", -1, &a->ns3__TMeterResult::StopVolume, ""))
		return soap->error;
	if (soap_out_double(soap, "IndicatedVolume", -1, &a->ns3__TMeterResult::IndicatedVolume, ""))
		return soap->error;
	if (soap_out_double(soap, "Error", -1, &a->ns3__TMeterResult::Error, ""))
		return soap->error;
	if (soap_out_ns3__TPulseCheck(soap, "PulseCheck", -1, &a->ns3__TMeterResult::PulseCheck, ""))
		return soap->error;
	if (soap_out_bool(soap, "Passed", -1, &a->ns3__TMeterResult::Passed, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__TMeterResult::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns3__TMeterResult(soap, tag, this, type);
}

SOAP_FMAC3 ns3__TMeterResult * SOAP_FMAC4 soap_in_ns3__TMeterResult(struct soap *soap, const char *tag, ns3__TMeterResult *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__TMeterResult*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__TMeterResult, sizeof(ns3__TMeterResult), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns3__TMeterResult)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__TMeterResult *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Position1 = 1;
	size_t soap_flag_Temperature1 = 1;
	size_t soap_flag_Pressure1 = 1;
	size_t soap_flag_Density1 = 1;
	size_t soap_flag_GatedMIDPulses1 = 1;
	size_t soap_flag_NominalVolume1 = 1;
	size_t soap_flag_Pulses1 = 1;
	size_t soap_flag_PulseConst1 = 1;
	size_t soap_flag_StartVolume1 = 1;
	size_t soap_flag_StopVolume1 = 1;
	size_t soap_flag_IndicatedVolume1 = 1;
	size_t soap_flag_Error1 = 1;
	size_t soap_flag_PulseCheck1 = 1;
	size_t soap_flag_Passed1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Position1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "Position", &a->ns3__TMeterResult::Position, "xsd:int"))
				{	soap_flag_Position1--;
					continue;
				}
			}
			if (soap_flag_Temperature1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "Temperature", &a->ns3__TMeterResult::Temperature, "xsd:double"))
				{	soap_flag_Temperature1--;
					continue;
				}
			}
			if (soap_flag_Pressure1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "Pressure", &a->ns3__TMeterResult::Pressure, "xsd:double"))
				{	soap_flag_Pressure1--;
					continue;
				}
			}
			if (soap_flag_Density1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "Density", &a->ns3__TMeterResult::Density, "xsd:double"))
				{	soap_flag_Density1--;
					continue;
				}
			}
			if (soap_flag_GatedMIDPulses1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "GatedMIDPulses", &a->ns3__TMeterResult::GatedMIDPulses, "xsd:int"))
				{	soap_flag_GatedMIDPulses1--;
					continue;
				}
			}
			if (soap_flag_NominalVolume1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "NominalVolume", &a->ns3__TMeterResult::NominalVolume, "xsd:double"))
				{	soap_flag_NominalVolume1--;
					continue;
				}
			}
			if (soap_flag_Pulses1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "Pulses", &a->ns3__TMeterResult::Pulses, "xsd:double"))
				{	soap_flag_Pulses1--;
					continue;
				}
			}
			if (soap_flag_PulseConst1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "PulseConst", &a->ns3__TMeterResult::PulseConst, "xsd:double"))
				{	soap_flag_PulseConst1--;
					continue;
				}
			}
			if (soap_flag_StartVolume1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "StartVolume", &a->ns3__TMeterResult::StartVolume, "xsd:double"))
				{	soap_flag_StartVolume1--;
					continue;
				}
			}
			if (soap_flag_StopVolume1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "StopVolume", &a->ns3__TMeterResult::StopVolume, "xsd:double"))
				{	soap_flag_StopVolume1--;
					continue;
				}
			}
			if (soap_flag_IndicatedVolume1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "IndicatedVolume", &a->ns3__TMeterResult::IndicatedVolume, "xsd:double"))
				{	soap_flag_IndicatedVolume1--;
					continue;
				}
			}
			if (soap_flag_Error1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "Error", &a->ns3__TMeterResult::Error, "xsd:double"))
				{	soap_flag_Error1--;
					continue;
				}
			}
			if (soap_flag_PulseCheck1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_ns3__TPulseCheck(soap, "PulseCheck", &a->ns3__TMeterResult::PulseCheck, "ns3:TPulseCheck"))
				{	soap_flag_PulseCheck1--;
					continue;
				}
			}
			if (soap_flag_Passed1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "Passed", &a->ns3__TMeterResult::Passed, "xsd:boolean"))
				{	soap_flag_Passed1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Position1 > 0 || soap_flag_Temperature1 > 0 || soap_flag_Pressure1 > 0 || soap_flag_Density1 > 0 || soap_flag_GatedMIDPulses1 > 0 || soap_flag_NominalVolume1 > 0 || soap_flag_Pulses1 > 0 || soap_flag_PulseConst1 > 0 || soap_flag_StartVolume1 > 0 || soap_flag_StopVolume1 > 0 || soap_flag_IndicatedVolume1 > 0 || soap_flag_Error1 > 0 || soap_flag_PulseCheck1 > 0 || soap_flag_Passed1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns3__TMeterResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__TMeterResult, SOAP_TYPE_ns3__TMeterResult, sizeof(ns3__TMeterResult), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__TMeterResult * SOAP_FMAC2 soap_instantiate_ns3__TMeterResult(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__TMeterResult(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__TMeterResult *p;
	size_t k = sizeof(ns3__TMeterResult);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns3__TMeterResult, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns3__TMeterResult);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns3__TMeterResult, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__TMeterResult location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns3__TMeterResult::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__TMeterResult(soap, tag ? tag : "ns3:TMeterResult", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__TMeterResult::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__TMeterResult(soap, this, tag, type);
}

SOAP_FMAC3 ns3__TMeterResult * SOAP_FMAC4 soap_get_ns3__TMeterResult(struct soap *soap, ns3__TMeterResult *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__TMeterResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void TMeterResults::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__ptr = NULL;
	this->__size = 0;
}

void TMeterResults::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (this->__ptr && !soap_array_reference(soap, this, this->__ptr, this->__size, SOAP_TYPE_TMeterResults))
	{	for (size_t i = 0; i < (size_t)this->__size; i++)
		{
			soap_serialize_PointerTons3__TMeterResult(soap, this->__ptr + i);
		}
	}
#endif
}

int TMeterResults::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_TMeterResults(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TMeterResults(struct soap *soap, const char *tag, int id, const TMeterResults *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptr ? soap_putsizesoffsets(soap, "ns3:TMeterResult", &a->__size, NULL, 1) : NULL;
	id = soap_element_id(soap, tag, id, a, a->__ptr, a->__size, type, SOAP_TYPE_TMeterResults, NULL);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		if (soap_out_PointerTons3__TMeterResult(soap, "item", -1, &a->__ptr[i], ""))
			return soap->error;
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *TMeterResults::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_TMeterResults(soap, tag, this, type);
}

SOAP_FMAC3 TMeterResults * SOAP_FMAC4 soap_in_TMeterResults(struct soap *soap, const char *tag, TMeterResults *a, const char *type)
{
	int i, j;
	ns3__TMeterResult **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (TMeterResults*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TMeterResults, sizeof(TMeterResults), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		if (*soap->arraySize)
		{
			soap_getsizes(soap->arraySize, &a->__size, 1);
			a->__size -= j = soap_getoffsets(soap->arrayOffset, &a->__size, NULL, 1);
			if ((size_t)a->__size > soap->maxoccurs)
			{	soap->error = SOAP_OCCURS;
				return NULL;
			}
			a->__ptr = (ns3__TMeterResult **)soap_malloc(soap, sizeof(ns3__TMeterResult *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons3__TMeterResult(soap, NULL, a->__ptr + i, "ns3:TMeterResult"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_alloc_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (ns3__TMeterResult **)soap_push_block(soap, NULL, sizeof(ns3__TMeterResult *));
				if (!p)
					break;
				*p = NULL;
				if (!soap_in_PointerTons3__TMeterResult(soap, NULL, p, "ns3:TMeterResult"))
				{	if (soap->error == SOAP_NO_TAG)
						soap->error = SOAP_OK;
					soap_pop_block(soap, NULL);
					break;
				}
				if ((size_t)a->__size > soap->maxoccurs)
				{	soap->error = SOAP_OCCURS;
					return NULL;
				}
			}
			a->__ptr = (ns3__TMeterResult **)soap_save_block(soap, NULL, NULL, 1);
		}
		if (soap->error || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (TMeterResults *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TMeterResults, SOAP_TYPE_TMeterResults, sizeof(TMeterResults), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 TMeterResults * SOAP_FMAC2 soap_instantiate_TMeterResults(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TMeterResults(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	TMeterResults *p;
	size_t k = sizeof(TMeterResults);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_TMeterResults, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, TMeterResults);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, TMeterResults, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated TMeterResults location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int TMeterResults::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_TMeterResults(soap, tag ? tag : "SOAP-ENC:Array", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *TMeterResults::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_TMeterResults(soap, this, tag, type);
}

SOAP_FMAC3 TMeterResults * SOAP_FMAC4 soap_get_TMeterResults(struct soap *soap, TMeterResults *p, const char *tag, const char *type)
{
	if ((p = soap_in_TMeterResults(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__TTestResults::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns3__TTestResults::TestName);
	soap_default_double(soap, &this->ns3__TTestResults::Flowrate);
	soap_default_double(soap, &this->ns3__TTestResults::Weight);
	soap_default_double(soap, &this->ns3__TTestResults::InletTemp);
	soap_default_double(soap, &this->ns3__TTestResults::OutletTemp);
	soap_default_double(soap, &this->ns3__TTestResults::MIDTemp);
	soap_default_double(soap, &this->ns3__TTestResults::MIDPulseConst);
	soap_default_double(soap, &this->ns3__TTestResults::MIDVolume);
	soap_default_double(soap, &this->ns3__TTestResults::MIDError);
	soap_default_double(soap, &this->ns3__TTestResults::Duration);
	this->ns3__TTestResults::MeterResults = NULL;
}

void ns3__TTestResults::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns3__TTestResults::TestName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns3__TTestResults::TestName);
	soap_serialize_PointerToTMeterResults(soap, &this->ns3__TTestResults::MeterResults);
#endif
}

int ns3__TTestResults::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__TTestResults(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__TTestResults(struct soap *soap, const char *tag, int id, const ns3__TTestResults *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__TTestResults), type))
		return soap->error;
	if (soap_out_std__string(soap, "TestName", -1, &a->ns3__TTestResults::TestName, ""))
		return soap->error;
	if (soap_out_double(soap, "Flowrate", -1, &a->ns3__TTestResults::Flowrate, ""))
		return soap->error;
	if (soap_out_double(soap, "Weight", -1, &a->ns3__TTestResults::Weight, ""))
		return soap->error;
	if (soap_out_double(soap, "InletTemp", -1, &a->ns3__TTestResults::InletTemp, ""))
		return soap->error;
	if (soap_out_double(soap, "OutletTemp", -1, &a->ns3__TTestResults::OutletTemp, ""))
		return soap->error;
	if (soap_out_double(soap, "MIDTemp", -1, &a->ns3__TTestResults::MIDTemp, ""))
		return soap->error;
	if (soap_out_double(soap, "MIDPulseConst", -1, &a->ns3__TTestResults::MIDPulseConst, ""))
		return soap->error;
	if (soap_out_double(soap, "MIDVolume", -1, &a->ns3__TTestResults::MIDVolume, ""))
		return soap->error;
	if (soap_out_double(soap, "MIDError", -1, &a->ns3__TTestResults::MIDError, ""))
		return soap->error;
	if (soap_out_double(soap, "Duration", -1, &a->ns3__TTestResults::Duration, ""))
		return soap->error;
	if (!a->ns3__TTestResults::MeterResults)
	{	if (soap_element_empty(soap, "MeterResults", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerToTMeterResults(soap, "MeterResults", -1, &a->ns3__TTestResults::MeterResults, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__TTestResults::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns3__TTestResults(soap, tag, this, type);
}

SOAP_FMAC3 ns3__TTestResults * SOAP_FMAC4 soap_in_ns3__TTestResults(struct soap *soap, const char *tag, ns3__TTestResults *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__TTestResults*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__TTestResults, sizeof(ns3__TTestResults), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns3__TTestResults)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__TTestResults *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_TestName1 = 1;
	size_t soap_flag_Flowrate1 = 1;
	size_t soap_flag_Weight1 = 1;
	size_t soap_flag_InletTemp1 = 1;
	size_t soap_flag_OutletTemp1 = 1;
	size_t soap_flag_MIDTemp1 = 1;
	size_t soap_flag_MIDPulseConst1 = 1;
	size_t soap_flag_MIDVolume1 = 1;
	size_t soap_flag_MIDError1 = 1;
	size_t soap_flag_Duration1 = 1;
	size_t soap_flag_MeterResults1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TestName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "TestName", &a->ns3__TTestResults::TestName, "xsd:string"))
				{	soap_flag_TestName1--;
					continue;
				}
			}
			if (soap_flag_Flowrate1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "Flowrate", &a->ns3__TTestResults::Flowrate, "xsd:double"))
				{	soap_flag_Flowrate1--;
					continue;
				}
			}
			if (soap_flag_Weight1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "Weight", &a->ns3__TTestResults::Weight, "xsd:double"))
				{	soap_flag_Weight1--;
					continue;
				}
			}
			if (soap_flag_InletTemp1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "InletTemp", &a->ns3__TTestResults::InletTemp, "xsd:double"))
				{	soap_flag_InletTemp1--;
					continue;
				}
			}
			if (soap_flag_OutletTemp1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "OutletTemp", &a->ns3__TTestResults::OutletTemp, "xsd:double"))
				{	soap_flag_OutletTemp1--;
					continue;
				}
			}
			if (soap_flag_MIDTemp1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "MIDTemp", &a->ns3__TTestResults::MIDTemp, "xsd:double"))
				{	soap_flag_MIDTemp1--;
					continue;
				}
			}
			if (soap_flag_MIDPulseConst1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "MIDPulseConst", &a->ns3__TTestResults::MIDPulseConst, "xsd:double"))
				{	soap_flag_MIDPulseConst1--;
					continue;
				}
			}
			if (soap_flag_MIDVolume1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "MIDVolume", &a->ns3__TTestResults::MIDVolume, "xsd:double"))
				{	soap_flag_MIDVolume1--;
					continue;
				}
			}
			if (soap_flag_MIDError1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "MIDError", &a->ns3__TTestResults::MIDError, "xsd:double"))
				{	soap_flag_MIDError1--;
					continue;
				}
			}
			if (soap_flag_Duration1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "Duration", &a->ns3__TTestResults::Duration, "xsd:double"))
				{	soap_flag_Duration1--;
					continue;
				}
			}
			if (soap_flag_MeterResults1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToTMeterResults(soap, "MeterResults", &a->ns3__TTestResults::MeterResults, "ns3:TMeterResult"))
				{	soap_flag_MeterResults1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TestName1 > 0 || soap_flag_Flowrate1 > 0 || soap_flag_Weight1 > 0 || soap_flag_InletTemp1 > 0 || soap_flag_OutletTemp1 > 0 || soap_flag_MIDTemp1 > 0 || soap_flag_MIDPulseConst1 > 0 || soap_flag_MIDVolume1 > 0 || soap_flag_MIDError1 > 0 || soap_flag_Duration1 > 0 || !a->ns3__TTestResults::MeterResults))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns3__TTestResults *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__TTestResults, SOAP_TYPE_ns3__TTestResults, sizeof(ns3__TTestResults), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__TTestResults * SOAP_FMAC2 soap_instantiate_ns3__TTestResults(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__TTestResults(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__TTestResults *p;
	size_t k = sizeof(ns3__TTestResults);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns3__TTestResults, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns3__TTestResults);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns3__TTestResults, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__TTestResults location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns3__TTestResults::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__TTestResults(soap, tag ? tag : "ns3:TTestResults", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__TTestResults::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__TTestResults(soap, this, tag, type);
}

SOAP_FMAC3 ns3__TTestResults * SOAP_FMAC4 soap_get_ns3__TTestResults(struct soap *soap, ns3__TTestResults *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__TTestResults(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__TMeasurementData::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->ns3__TMeasurementData::Done);
	this->ns3__TMeasurementData::TestNames = NULL;
	soap_default_std__string(soap, &this->ns3__TMeasurementData::ProtocolNumber);
	soap_default_std__string(soap, &this->ns3__TMeasurementData::TestBench);
	soap_default_std__string(soap, &this->ns3__TMeasurementData::Tester);
	soap_default_std__string(soap, &this->ns3__TMeasurementData::TypeName);
	soap_default_std__string(soap, &this->ns3__TMeasurementData::TypeApprovalNumber);
	soap_default_std__string(soap, &this->ns3__TMeasurementData::TypeClass);
	soap_default_int(soap, &this->ns3__TMeasurementData::TypeNominalSize);
	this->ns3__TMeasurementData::TypeTestNames = NULL;
	soap_default_double(soap, &this->ns3__TMeasurementData::TypeMeterConst);
	soap_default_double(soap, &this->ns3__TMeasurementData::TypeNominalFlowrate);
}

void ns3__TMeasurementData::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns3__TMeasurementData::Done, SOAP_TYPE_bool);
	soap_serialize_PointerToTStringDynArray(soap, &this->ns3__TMeasurementData::TestNames);
	soap_embedded(soap, &this->ns3__TMeasurementData::ProtocolNumber, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns3__TMeasurementData::ProtocolNumber);
	soap_embedded(soap, &this->ns3__TMeasurementData::TestBench, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns3__TMeasurementData::TestBench);
	soap_embedded(soap, &this->ns3__TMeasurementData::Tester, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns3__TMeasurementData::Tester);
	soap_embedded(soap, &this->ns3__TMeasurementData::TypeName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns3__TMeasurementData::TypeName);
	soap_embedded(soap, &this->ns3__TMeasurementData::TypeApprovalNumber, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns3__TMeasurementData::TypeApprovalNumber);
	soap_embedded(soap, &this->ns3__TMeasurementData::TypeClass, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns3__TMeasurementData::TypeClass);
	soap_embedded(soap, &this->ns3__TMeasurementData::TypeNominalSize, SOAP_TYPE_int);
	soap_serialize_PointerToTStringDynArray(soap, &this->ns3__TMeasurementData::TypeTestNames);
#endif
}

int ns3__TMeasurementData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__TMeasurementData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__TMeasurementData(struct soap *soap, const char *tag, int id, const ns3__TMeasurementData *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__TMeasurementData), type))
		return soap->error;
	if (soap_out_bool(soap, "Done", -1, &a->ns3__TMeasurementData::Done, ""))
		return soap->error;
	if (!a->ns3__TMeasurementData::TestNames)
	{	if (soap_element_empty(soap, "TestNames", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerToTStringDynArray(soap, "TestNames", -1, &a->ns3__TMeasurementData::TestNames, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ProtocolNumber", -1, &a->ns3__TMeasurementData::ProtocolNumber, ""))
		return soap->error;
	if (soap_out_std__string(soap, "TestBench", -1, &a->ns3__TMeasurementData::TestBench, ""))
		return soap->error;
	if (soap_out_std__string(soap, "Tester", -1, &a->ns3__TMeasurementData::Tester, ""))
		return soap->error;
	if (soap_out_std__string(soap, "TypeName", -1, &a->ns3__TMeasurementData::TypeName, ""))
		return soap->error;
	if (soap_out_std__string(soap, "TypeApprovalNumber", -1, &a->ns3__TMeasurementData::TypeApprovalNumber, ""))
		return soap->error;
	if (soap_out_std__string(soap, "TypeClass", -1, &a->ns3__TMeasurementData::TypeClass, ""))
		return soap->error;
	if (soap_out_int(soap, "TypeNominalSize", -1, &a->ns3__TMeasurementData::TypeNominalSize, ""))
		return soap->error;
	if (!a->ns3__TMeasurementData::TypeTestNames)
	{	if (soap_element_empty(soap, "TypeTestNames", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerToTStringDynArray(soap, "TypeTestNames", -1, &a->ns3__TMeasurementData::TypeTestNames, ""))
		return soap->error;
	if (soap_out_double(soap, "TypeMeterConst", -1, &a->ns3__TMeasurementData::TypeMeterConst, ""))
		return soap->error;
	if (soap_out_double(soap, "TypeNominalFlowrate", -1, &a->ns3__TMeasurementData::TypeNominalFlowrate, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__TMeasurementData::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns3__TMeasurementData(soap, tag, this, type);
}

SOAP_FMAC3 ns3__TMeasurementData * SOAP_FMAC4 soap_in_ns3__TMeasurementData(struct soap *soap, const char *tag, ns3__TMeasurementData *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__TMeasurementData*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__TMeasurementData, sizeof(ns3__TMeasurementData), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns3__TMeasurementData)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__TMeasurementData *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Done1 = 1;
	size_t soap_flag_TestNames1 = 1;
	size_t soap_flag_ProtocolNumber1 = 1;
	size_t soap_flag_TestBench1 = 1;
	size_t soap_flag_Tester1 = 1;
	size_t soap_flag_TypeName1 = 1;
	size_t soap_flag_TypeApprovalNumber1 = 1;
	size_t soap_flag_TypeClass1 = 1;
	size_t soap_flag_TypeNominalSize1 = 1;
	size_t soap_flag_TypeTestNames1 = 1;
	size_t soap_flag_TypeMeterConst1 = 1;
	size_t soap_flag_TypeNominalFlowrate1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Done1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "Done", &a->ns3__TMeasurementData::Done, "xsd:boolean"))
				{	soap_flag_Done1--;
					continue;
				}
			}
			if (soap_flag_TestNames1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToTStringDynArray(soap, "TestNames", &a->ns3__TMeasurementData::TestNames, "xsd:string"))
				{	soap_flag_TestNames1--;
					continue;
				}
			}
			if (soap_flag_ProtocolNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ProtocolNumber", &a->ns3__TMeasurementData::ProtocolNumber, "xsd:string"))
				{	soap_flag_ProtocolNumber1--;
					continue;
				}
			}
			if (soap_flag_TestBench1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "TestBench", &a->ns3__TMeasurementData::TestBench, "xsd:string"))
				{	soap_flag_TestBench1--;
					continue;
				}
			}
			if (soap_flag_Tester1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "Tester", &a->ns3__TMeasurementData::Tester, "xsd:string"))
				{	soap_flag_Tester1--;
					continue;
				}
			}
			if (soap_flag_TypeName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "TypeName", &a->ns3__TMeasurementData::TypeName, "xsd:string"))
				{	soap_flag_TypeName1--;
					continue;
				}
			}
			if (soap_flag_TypeApprovalNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "TypeApprovalNumber", &a->ns3__TMeasurementData::TypeApprovalNumber, "xsd:string"))
				{	soap_flag_TypeApprovalNumber1--;
					continue;
				}
			}
			if (soap_flag_TypeClass1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "TypeClass", &a->ns3__TMeasurementData::TypeClass, "xsd:string"))
				{	soap_flag_TypeClass1--;
					continue;
				}
			}
			if (soap_flag_TypeNominalSize1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "TypeNominalSize", &a->ns3__TMeasurementData::TypeNominalSize, "xsd:int"))
				{	soap_flag_TypeNominalSize1--;
					continue;
				}
			}
			if (soap_flag_TypeTestNames1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToTStringDynArray(soap, "TypeTestNames", &a->ns3__TMeasurementData::TypeTestNames, "xsd:string"))
				{	soap_flag_TypeTestNames1--;
					continue;
				}
			}
			if (soap_flag_TypeMeterConst1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "TypeMeterConst", &a->ns3__TMeasurementData::TypeMeterConst, "xsd:double"))
				{	soap_flag_TypeMeterConst1--;
					continue;
				}
			}
			if (soap_flag_TypeNominalFlowrate1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "TypeNominalFlowrate", &a->ns3__TMeasurementData::TypeNominalFlowrate, "xsd:double"))
				{	soap_flag_TypeNominalFlowrate1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Done1 > 0 || !a->ns3__TMeasurementData::TestNames || soap_flag_ProtocolNumber1 > 0 || soap_flag_TestBench1 > 0 || soap_flag_Tester1 > 0 || soap_flag_TypeName1 > 0 || soap_flag_TypeApprovalNumber1 > 0 || soap_flag_TypeClass1 > 0 || soap_flag_TypeNominalSize1 > 0 || !a->ns3__TMeasurementData::TypeTestNames || soap_flag_TypeMeterConst1 > 0 || soap_flag_TypeNominalFlowrate1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns3__TMeasurementData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__TMeasurementData, SOAP_TYPE_ns3__TMeasurementData, sizeof(ns3__TMeasurementData), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__TMeasurementData * SOAP_FMAC2 soap_instantiate_ns3__TMeasurementData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__TMeasurementData(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__TMeasurementData *p;
	size_t k = sizeof(ns3__TMeasurementData);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns3__TMeasurementData, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns3__TMeasurementData);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns3__TMeasurementData, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__TMeasurementData location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns3__TMeasurementData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__TMeasurementData(soap, tag ? tag : "ns3:TMeasurementData", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__TMeasurementData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__TMeasurementData(soap, this, tag, type);
}

SOAP_FMAC3 ns3__TMeasurementData * SOAP_FMAC4 soap_get_ns3__TMeasurementData(struct soap *soap, ns3__TMeasurementData *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__TMeasurementData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__TMeterIndication::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns3__TMeterIndication::Position);
	soap_default_double(soap, &this->ns3__TMeterIndication::StartVolume);
	soap_default_double(soap, &this->ns3__TMeterIndication::StopVolume);
	soap_default_double(soap, &this->ns3__TMeterIndication::IndicatedVolume);
}

void ns3__TMeterIndication::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns3__TMeterIndication::Position, SOAP_TYPE_int);
#endif
}

int ns3__TMeterIndication::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__TMeterIndication(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__TMeterIndication(struct soap *soap, const char *tag, int id, const ns3__TMeterIndication *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__TMeterIndication), type))
		return soap->error;
	if (soap_out_int(soap, "Position", -1, &a->ns3__TMeterIndication::Position, ""))
		return soap->error;
	if (soap_out_double(soap, "StartVolume", -1, &a->ns3__TMeterIndication::StartVolume, ""))
		return soap->error;
	if (soap_out_double(soap, "StopVolume", -1, &a->ns3__TMeterIndication::StopVolume, ""))
		return soap->error;
	if (soap_out_double(soap, "IndicatedVolume", -1, &a->ns3__TMeterIndication::IndicatedVolume, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__TMeterIndication::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns3__TMeterIndication(soap, tag, this, type);
}

SOAP_FMAC3 ns3__TMeterIndication * SOAP_FMAC4 soap_in_ns3__TMeterIndication(struct soap *soap, const char *tag, ns3__TMeterIndication *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__TMeterIndication*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__TMeterIndication, sizeof(ns3__TMeterIndication), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns3__TMeterIndication)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__TMeterIndication *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Position1 = 1;
	size_t soap_flag_StartVolume1 = 1;
	size_t soap_flag_StopVolume1 = 1;
	size_t soap_flag_IndicatedVolume1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Position1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "Position", &a->ns3__TMeterIndication::Position, "xsd:int"))
				{	soap_flag_Position1--;
					continue;
				}
			}
			if (soap_flag_StartVolume1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "StartVolume", &a->ns3__TMeterIndication::StartVolume, "xsd:double"))
				{	soap_flag_StartVolume1--;
					continue;
				}
			}
			if (soap_flag_StopVolume1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "StopVolume", &a->ns3__TMeterIndication::StopVolume, "xsd:double"))
				{	soap_flag_StopVolume1--;
					continue;
				}
			}
			if (soap_flag_IndicatedVolume1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "IndicatedVolume", &a->ns3__TMeterIndication::IndicatedVolume, "xsd:double"))
				{	soap_flag_IndicatedVolume1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Position1 > 0 || soap_flag_StartVolume1 > 0 || soap_flag_StopVolume1 > 0 || soap_flag_IndicatedVolume1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns3__TMeterIndication *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__TMeterIndication, SOAP_TYPE_ns3__TMeterIndication, sizeof(ns3__TMeterIndication), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__TMeterIndication * SOAP_FMAC2 soap_instantiate_ns3__TMeterIndication(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__TMeterIndication(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__TMeterIndication *p;
	size_t k = sizeof(ns3__TMeterIndication);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns3__TMeterIndication, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns3__TMeterIndication);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns3__TMeterIndication, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__TMeterIndication location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns3__TMeterIndication::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__TMeterIndication(soap, tag ? tag : "ns3:TMeterIndication", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__TMeterIndication::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__TMeterIndication(soap, this, tag, type);
}

SOAP_FMAC3 ns3__TMeterIndication * SOAP_FMAC4 soap_get_ns3__TMeterIndication(struct soap *soap, ns3__TMeterIndication *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__TMeterIndication(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void TMeterIndications::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__ptr = NULL;
	this->__size = 0;
}

void TMeterIndications::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (this->__ptr && !soap_array_reference(soap, this, this->__ptr, this->__size, SOAP_TYPE_TMeterIndications))
	{	for (size_t i = 0; i < (size_t)this->__size; i++)
		{
			soap_serialize_PointerTons3__TMeterIndication(soap, this->__ptr + i);
		}
	}
#endif
}

int TMeterIndications::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_TMeterIndications(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TMeterIndications(struct soap *soap, const char *tag, int id, const TMeterIndications *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptr ? soap_putsizesoffsets(soap, "ns3:TMeterIndication", &a->__size, NULL, 1) : NULL;
	id = soap_element_id(soap, tag, id, a, a->__ptr, a->__size, type, SOAP_TYPE_TMeterIndications, NULL);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		if (soap_out_PointerTons3__TMeterIndication(soap, "item", -1, &a->__ptr[i], ""))
			return soap->error;
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *TMeterIndications::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_TMeterIndications(soap, tag, this, type);
}

SOAP_FMAC3 TMeterIndications * SOAP_FMAC4 soap_in_TMeterIndications(struct soap *soap, const char *tag, TMeterIndications *a, const char *type)
{
	int i, j;
	ns3__TMeterIndication **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (TMeterIndications*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TMeterIndications, sizeof(TMeterIndications), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		if (*soap->arraySize)
		{
			soap_getsizes(soap->arraySize, &a->__size, 1);
			a->__size -= j = soap_getoffsets(soap->arrayOffset, &a->__size, NULL, 1);
			if ((size_t)a->__size > soap->maxoccurs)
			{	soap->error = SOAP_OCCURS;
				return NULL;
			}
			a->__ptr = (ns3__TMeterIndication **)soap_malloc(soap, sizeof(ns3__TMeterIndication *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons3__TMeterIndication(soap, NULL, a->__ptr + i, "ns3:TMeterIndication"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_alloc_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (ns3__TMeterIndication **)soap_push_block(soap, NULL, sizeof(ns3__TMeterIndication *));
				if (!p)
					break;
				*p = NULL;
				if (!soap_in_PointerTons3__TMeterIndication(soap, NULL, p, "ns3:TMeterIndication"))
				{	if (soap->error == SOAP_NO_TAG)
						soap->error = SOAP_OK;
					soap_pop_block(soap, NULL);
					break;
				}
				if ((size_t)a->__size > soap->maxoccurs)
				{	soap->error = SOAP_OCCURS;
					return NULL;
				}
			}
			a->__ptr = (ns3__TMeterIndication **)soap_save_block(soap, NULL, NULL, 1);
		}
		if (soap->error || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (TMeterIndications *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TMeterIndications, SOAP_TYPE_TMeterIndications, sizeof(TMeterIndications), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 TMeterIndications * SOAP_FMAC2 soap_instantiate_TMeterIndications(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TMeterIndications(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	TMeterIndications *p;
	size_t k = sizeof(TMeterIndications);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_TMeterIndications, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, TMeterIndications);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, TMeterIndications, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated TMeterIndications location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int TMeterIndications::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_TMeterIndications(soap, tag ? tag : "SOAP-ENC:Array", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *TMeterIndications::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_TMeterIndications(soap, this, tag, type);
}

SOAP_FMAC3 TMeterIndications * SOAP_FMAC4 soap_get_TMeterIndications(struct soap *soap, TMeterIndications *p, const char *tag, const char *type)
{
	if ((p = soap_in_TMeterIndications(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__TMeterData::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns3__TMeterData::Position);
	soap_default_std__string(soap, &this->ns3__TMeterData::ProdNr);
	soap_default_double(soap, &this->ns3__TMeterData::MeterConstant);
}

void ns3__TMeterData::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns3__TMeterData::Position, SOAP_TYPE_int);
	soap_embedded(soap, &this->ns3__TMeterData::ProdNr, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns3__TMeterData::ProdNr);
#endif
}

int ns3__TMeterData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__TMeterData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__TMeterData(struct soap *soap, const char *tag, int id, const ns3__TMeterData *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__TMeterData), type))
		return soap->error;
	if (soap_out_int(soap, "Position", -1, &a->ns3__TMeterData::Position, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ProdNr", -1, &a->ns3__TMeterData::ProdNr, ""))
		return soap->error;
	if (soap_out_double(soap, "MeterConstant", -1, &a->ns3__TMeterData::MeterConstant, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__TMeterData::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns3__TMeterData(soap, tag, this, type);
}

SOAP_FMAC3 ns3__TMeterData * SOAP_FMAC4 soap_in_ns3__TMeterData(struct soap *soap, const char *tag, ns3__TMeterData *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__TMeterData*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__TMeterData, sizeof(ns3__TMeterData), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns3__TMeterData)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__TMeterData *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Position1 = 1;
	size_t soap_flag_ProdNr1 = 1;
	size_t soap_flag_MeterConstant1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Position1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "Position", &a->ns3__TMeterData::Position, "xsd:int"))
				{	soap_flag_Position1--;
					continue;
				}
			}
			if (soap_flag_ProdNr1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ProdNr", &a->ns3__TMeterData::ProdNr, "xsd:string"))
				{	soap_flag_ProdNr1--;
					continue;
				}
			}
			if (soap_flag_MeterConstant1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "MeterConstant", &a->ns3__TMeterData::MeterConstant, "xsd:double"))
				{	soap_flag_MeterConstant1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Position1 > 0 || soap_flag_ProdNr1 > 0 || soap_flag_MeterConstant1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns3__TMeterData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__TMeterData, SOAP_TYPE_ns3__TMeterData, sizeof(ns3__TMeterData), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__TMeterData * SOAP_FMAC2 soap_instantiate_ns3__TMeterData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__TMeterData(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__TMeterData *p;
	size_t k = sizeof(ns3__TMeterData);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns3__TMeterData, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns3__TMeterData);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns3__TMeterData, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__TMeterData location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns3__TMeterData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__TMeterData(soap, tag ? tag : "ns3:TMeterData", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__TMeterData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__TMeterData(soap, this, tag, type);
}

SOAP_FMAC3 ns3__TMeterData * SOAP_FMAC4 soap_get_ns3__TMeterData(struct soap *soap, ns3__TMeterData *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__TMeterData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void TMetersData::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__ptr = NULL;
	this->__size = 0;
}

void TMetersData::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (this->__ptr && !soap_array_reference(soap, this, this->__ptr, this->__size, SOAP_TYPE_TMetersData))
	{	for (size_t i = 0; i < (size_t)this->__size; i++)
		{
			soap_serialize_PointerTons3__TMeterData(soap, this->__ptr + i);
		}
	}
#endif
}

int TMetersData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_TMetersData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TMetersData(struct soap *soap, const char *tag, int id, const TMetersData *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptr ? soap_putsizesoffsets(soap, "ns3:TMeterData", &a->__size, NULL, 1) : NULL;
	id = soap_element_id(soap, tag, id, a, a->__ptr, a->__size, type, SOAP_TYPE_TMetersData, NULL);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		if (soap_out_PointerTons3__TMeterData(soap, "item", -1, &a->__ptr[i], ""))
			return soap->error;
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *TMetersData::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_TMetersData(soap, tag, this, type);
}

SOAP_FMAC3 TMetersData * SOAP_FMAC4 soap_in_TMetersData(struct soap *soap, const char *tag, TMetersData *a, const char *type)
{
	int i, j;
	ns3__TMeterData **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (TMetersData*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TMetersData, sizeof(TMetersData), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		if (*soap->arraySize)
		{
			soap_getsizes(soap->arraySize, &a->__size, 1);
			a->__size -= j = soap_getoffsets(soap->arrayOffset, &a->__size, NULL, 1);
			if ((size_t)a->__size > soap->maxoccurs)
			{	soap->error = SOAP_OCCURS;
				return NULL;
			}
			a->__ptr = (ns3__TMeterData **)soap_malloc(soap, sizeof(ns3__TMeterData *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons3__TMeterData(soap, NULL, a->__ptr + i, "ns3:TMeterData"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_alloc_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (ns3__TMeterData **)soap_push_block(soap, NULL, sizeof(ns3__TMeterData *));
				if (!p)
					break;
				*p = NULL;
				if (!soap_in_PointerTons3__TMeterData(soap, NULL, p, "ns3:TMeterData"))
				{	if (soap->error == SOAP_NO_TAG)
						soap->error = SOAP_OK;
					soap_pop_block(soap, NULL);
					break;
				}
				if ((size_t)a->__size > soap->maxoccurs)
				{	soap->error = SOAP_OCCURS;
					return NULL;
				}
			}
			a->__ptr = (ns3__TMeterData **)soap_save_block(soap, NULL, NULL, 1);
		}
		if (soap->error || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (TMetersData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TMetersData, SOAP_TYPE_TMetersData, sizeof(TMetersData), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 TMetersData * SOAP_FMAC2 soap_instantiate_TMetersData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TMetersData(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	TMetersData *p;
	size_t k = sizeof(TMetersData);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_TMetersData, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, TMetersData);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, TMetersData, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated TMetersData location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int TMetersData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_TMetersData(soap, tag ? tag : "SOAP-ENC:Array", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *TMetersData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_TMetersData(soap, this, tag, type);
}

SOAP_FMAC3 TMetersData * SOAP_FMAC4 soap_get_TMetersData(struct soap *soap, TMetersData *p, const char *tag, const char *type)
{
	if ((p = soap_in_TMetersData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__TStatus::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns3__TStatusCode(soap, &this->ns3__TStatus::StatusCode);
	soap_default_std__string(soap, &this->ns3__TStatus::TestName);
	soap_default_bool(soap, &this->ns3__TStatus::InitializationEvent);
	soap_default_bool(soap, &this->ns3__TStatus::CanceledEvent);
	soap_default_bool(soap, &this->ns3__TStatus::FinishEvent);
	soap_default_bool(soap, &this->ns3__TStatus::FinishTestEvent);
	soap_default_std__string(soap, &this->ns3__TStatus::StatusMessage);
	soap_default_std__string(soap, &this->ns3__TStatus::CancelMessage);
}

void ns3__TStatus::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns3__TStatus::TestName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns3__TStatus::TestName);
	soap_embedded(soap, &this->ns3__TStatus::InitializationEvent, SOAP_TYPE_bool);
	soap_embedded(soap, &this->ns3__TStatus::CanceledEvent, SOAP_TYPE_bool);
	soap_embedded(soap, &this->ns3__TStatus::FinishEvent, SOAP_TYPE_bool);
	soap_embedded(soap, &this->ns3__TStatus::FinishTestEvent, SOAP_TYPE_bool);
	soap_embedded(soap, &this->ns3__TStatus::StatusMessage, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns3__TStatus::StatusMessage);
	soap_embedded(soap, &this->ns3__TStatus::CancelMessage, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns3__TStatus::CancelMessage);
#endif
}

int ns3__TStatus::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__TStatus(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__TStatus(struct soap *soap, const char *tag, int id, const ns3__TStatus *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__TStatus), type))
		return soap->error;
	if (soap_out_ns3__TStatusCode(soap, "StatusCode", -1, &a->ns3__TStatus::StatusCode, ""))
		return soap->error;
	if (soap_out_std__string(soap, "TestName", -1, &a->ns3__TStatus::TestName, ""))
		return soap->error;
	if (soap_out_bool(soap, "InitializationEvent", -1, &a->ns3__TStatus::InitializationEvent, ""))
		return soap->error;
	if (soap_out_bool(soap, "CanceledEvent", -1, &a->ns3__TStatus::CanceledEvent, ""))
		return soap->error;
	if (soap_out_bool(soap, "FinishEvent", -1, &a->ns3__TStatus::FinishEvent, ""))
		return soap->error;
	if (soap_out_bool(soap, "FinishTestEvent", -1, &a->ns3__TStatus::FinishTestEvent, ""))
		return soap->error;
	if (soap_out_std__string(soap, "StatusMessage", -1, &a->ns3__TStatus::StatusMessage, ""))
		return soap->error;
	if (soap_out_std__string(soap, "CancelMessage", -1, &a->ns3__TStatus::CancelMessage, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__TStatus::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns3__TStatus(soap, tag, this, type);
}

SOAP_FMAC3 ns3__TStatus * SOAP_FMAC4 soap_in_ns3__TStatus(struct soap *soap, const char *tag, ns3__TStatus *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__TStatus*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__TStatus, sizeof(ns3__TStatus), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns3__TStatus)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__TStatus *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_StatusCode1 = 1;
	size_t soap_flag_TestName1 = 1;
	size_t soap_flag_InitializationEvent1 = 1;
	size_t soap_flag_CanceledEvent1 = 1;
	size_t soap_flag_FinishEvent1 = 1;
	size_t soap_flag_FinishTestEvent1 = 1;
	size_t soap_flag_StatusMessage1 = 1;
	size_t soap_flag_CancelMessage1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_StatusCode1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_ns3__TStatusCode(soap, "StatusCode", &a->ns3__TStatus::StatusCode, "ns3:TStatusCode"))
				{	soap_flag_StatusCode1--;
					continue;
				}
			}
			if (soap_flag_TestName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "TestName", &a->ns3__TStatus::TestName, "xsd:string"))
				{	soap_flag_TestName1--;
					continue;
				}
			}
			if (soap_flag_InitializationEvent1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "InitializationEvent", &a->ns3__TStatus::InitializationEvent, "xsd:boolean"))
				{	soap_flag_InitializationEvent1--;
					continue;
				}
			}
			if (soap_flag_CanceledEvent1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "CanceledEvent", &a->ns3__TStatus::CanceledEvent, "xsd:boolean"))
				{	soap_flag_CanceledEvent1--;
					continue;
				}
			}
			if (soap_flag_FinishEvent1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "FinishEvent", &a->ns3__TStatus::FinishEvent, "xsd:boolean"))
				{	soap_flag_FinishEvent1--;
					continue;
				}
			}
			if (soap_flag_FinishTestEvent1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "FinishTestEvent", &a->ns3__TStatus::FinishTestEvent, "xsd:boolean"))
				{	soap_flag_FinishTestEvent1--;
					continue;
				}
			}
			if (soap_flag_StatusMessage1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "StatusMessage", &a->ns3__TStatus::StatusMessage, "xsd:string"))
				{	soap_flag_StatusMessage1--;
					continue;
				}
			}
			if (soap_flag_CancelMessage1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "CancelMessage", &a->ns3__TStatus::CancelMessage, "xsd:string"))
				{	soap_flag_CancelMessage1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_StatusCode1 > 0 || soap_flag_TestName1 > 0 || soap_flag_InitializationEvent1 > 0 || soap_flag_CanceledEvent1 > 0 || soap_flag_FinishEvent1 > 0 || soap_flag_FinishTestEvent1 > 0 || soap_flag_StatusMessage1 > 0 || soap_flag_CancelMessage1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns3__TStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__TStatus, SOAP_TYPE_ns3__TStatus, sizeof(ns3__TStatus), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__TStatus * SOAP_FMAC2 soap_instantiate_ns3__TStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__TStatus(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__TStatus *p;
	size_t k = sizeof(ns3__TStatus);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns3__TStatus, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns3__TStatus);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns3__TStatus, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__TStatus location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns3__TStatus::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__TStatus(soap, tag ? tag : "ns3:TStatus", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__TStatus::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__TStatus(soap, this, tag, type);
}

SOAP_FMAC3 ns3__TStatus * SOAP_FMAC4 soap_get_ns3__TStatus(struct soap *soap, ns3__TStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__TStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__TWaitEvents::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->ns3__TWaitEvents::StartTest);
	soap_default_bool(soap, &this->ns3__TWaitEvents::StopTest);
}

void ns3__TWaitEvents::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns3__TWaitEvents::StartTest, SOAP_TYPE_bool);
	soap_embedded(soap, &this->ns3__TWaitEvents::StopTest, SOAP_TYPE_bool);
#endif
}

int ns3__TWaitEvents::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__TWaitEvents(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__TWaitEvents(struct soap *soap, const char *tag, int id, const ns3__TWaitEvents *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__TWaitEvents), type))
		return soap->error;
	if (soap_out_bool(soap, "StartTest", -1, &a->ns3__TWaitEvents::StartTest, ""))
		return soap->error;
	if (soap_out_bool(soap, "StopTest", -1, &a->ns3__TWaitEvents::StopTest, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__TWaitEvents::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns3__TWaitEvents(soap, tag, this, type);
}

SOAP_FMAC3 ns3__TWaitEvents * SOAP_FMAC4 soap_in_ns3__TWaitEvents(struct soap *soap, const char *tag, ns3__TWaitEvents *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__TWaitEvents*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__TWaitEvents, sizeof(ns3__TWaitEvents), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns3__TWaitEvents)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__TWaitEvents *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_StartTest1 = 1;
	size_t soap_flag_StopTest1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_StartTest1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "StartTest", &a->ns3__TWaitEvents::StartTest, "xsd:boolean"))
				{	soap_flag_StartTest1--;
					continue;
				}
			}
			if (soap_flag_StopTest1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "StopTest", &a->ns3__TWaitEvents::StopTest, "xsd:boolean"))
				{	soap_flag_StopTest1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_StartTest1 > 0 || soap_flag_StopTest1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns3__TWaitEvents *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__TWaitEvents, SOAP_TYPE_ns3__TWaitEvents, sizeof(ns3__TWaitEvents), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__TWaitEvents * SOAP_FMAC2 soap_instantiate_ns3__TWaitEvents(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__TWaitEvents(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__TWaitEvents *p;
	size_t k = sizeof(ns3__TWaitEvents);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns3__TWaitEvents, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns3__TWaitEvents);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns3__TWaitEvents, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__TWaitEvents location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns3__TWaitEvents::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__TWaitEvents(soap, tag ? tag : "ns3:TWaitEvents", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__TWaitEvents::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__TWaitEvents(soap, this, tag, type);
}

SOAP_FMAC3 ns3__TWaitEvents * SOAP_FMAC4 soap_get_ns3__TWaitEvents(struct soap *soap, ns3__TWaitEvents *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__TWaitEvents(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__TPressTestParameters::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_double(soap, &this->ns3__TPressTestParameters::StartPress);
	soap_default_double(soap, &this->ns3__TPressTestParameters::Duration);
	soap_default_double(soap, &this->ns3__TPressTestParameters::MaxFall);
}

void ns3__TPressTestParameters::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int ns3__TPressTestParameters::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__TPressTestParameters(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__TPressTestParameters(struct soap *soap, const char *tag, int id, const ns3__TPressTestParameters *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__TPressTestParameters), type))
		return soap->error;
	if (soap_out_double(soap, "StartPress", -1, &a->ns3__TPressTestParameters::StartPress, ""))
		return soap->error;
	if (soap_out_double(soap, "Duration", -1, &a->ns3__TPressTestParameters::Duration, ""))
		return soap->error;
	if (soap_out_double(soap, "MaxFall", -1, &a->ns3__TPressTestParameters::MaxFall, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__TPressTestParameters::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns3__TPressTestParameters(soap, tag, this, type);
}

SOAP_FMAC3 ns3__TPressTestParameters * SOAP_FMAC4 soap_in_ns3__TPressTestParameters(struct soap *soap, const char *tag, ns3__TPressTestParameters *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__TPressTestParameters*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__TPressTestParameters, sizeof(ns3__TPressTestParameters), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns3__TPressTestParameters)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__TPressTestParameters *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_StartPress1 = 1;
	size_t soap_flag_Duration1 = 1;
	size_t soap_flag_MaxFall1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_StartPress1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "StartPress", &a->ns3__TPressTestParameters::StartPress, "xsd:double"))
				{	soap_flag_StartPress1--;
					continue;
				}
			}
			if (soap_flag_Duration1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "Duration", &a->ns3__TPressTestParameters::Duration, "xsd:double"))
				{	soap_flag_Duration1--;
					continue;
				}
			}
			if (soap_flag_MaxFall1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "MaxFall", &a->ns3__TPressTestParameters::MaxFall, "xsd:double"))
				{	soap_flag_MaxFall1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_StartPress1 > 0 || soap_flag_Duration1 > 0 || soap_flag_MaxFall1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns3__TPressTestParameters *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__TPressTestParameters, SOAP_TYPE_ns3__TPressTestParameters, sizeof(ns3__TPressTestParameters), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__TPressTestParameters * SOAP_FMAC2 soap_instantiate_ns3__TPressTestParameters(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__TPressTestParameters(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__TPressTestParameters *p;
	size_t k = sizeof(ns3__TPressTestParameters);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns3__TPressTestParameters, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns3__TPressTestParameters);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns3__TPressTestParameters, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__TPressTestParameters location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns3__TPressTestParameters::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__TPressTestParameters(soap, tag ? tag : "ns3:TPressTestParameters", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__TPressTestParameters::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__TPressTestParameters(soap, this, tag, type);
}

SOAP_FMAC3 ns3__TPressTestParameters * SOAP_FMAC4 soap_get_ns3__TPressTestParameters(struct soap *soap, ns3__TPressTestParameters *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__TPressTestParameters(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__TTestParameters::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_double(soap, &this->ns3__TTestParameters::MinFlowrate);
	soap_default_double(soap, &this->ns3__TTestParameters::MaxFlowrate);
	soap_default_double(soap, &this->ns3__TTestParameters::MinTemperature);
	soap_default_double(soap, &this->ns3__TTestParameters::MaxTemperature);
	soap_default_double(soap, &this->ns3__TTestParameters::MinVolume);
	soap_default_ns3__TProofMethod(soap, &this->ns3__TTestParameters::ProofMethod);
	soap_default_ns3__TMeterIndicationMethod(soap, &this->ns3__TTestParameters::MeterIndicationMethod);
	soap_default_double(soap, &this->ns3__TTestParameters::MinError);
	soap_default_double(soap, &this->ns3__TTestParameters::MaxError);
}

void ns3__TTestParameters::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int ns3__TTestParameters::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__TTestParameters(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__TTestParameters(struct soap *soap, const char *tag, int id, const ns3__TTestParameters *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__TTestParameters), type))
		return soap->error;
	if (soap_out_double(soap, "MinFlowrate", -1, &a->ns3__TTestParameters::MinFlowrate, ""))
		return soap->error;
	if (soap_out_double(soap, "MaxFlowrate", -1, &a->ns3__TTestParameters::MaxFlowrate, ""))
		return soap->error;
	if (soap_out_double(soap, "MinTemperature", -1, &a->ns3__TTestParameters::MinTemperature, ""))
		return soap->error;
	if (soap_out_double(soap, "MaxTemperature", -1, &a->ns3__TTestParameters::MaxTemperature, ""))
		return soap->error;
	if (soap_out_double(soap, "MinVolume", -1, &a->ns3__TTestParameters::MinVolume, ""))
		return soap->error;
	if (soap_out_ns3__TProofMethod(soap, "ProofMethod", -1, &a->ns3__TTestParameters::ProofMethod, ""))
		return soap->error;
	if (soap_out_ns3__TMeterIndicationMethod(soap, "MeterIndicationMethod", -1, &a->ns3__TTestParameters::MeterIndicationMethod, ""))
		return soap->error;
	if (soap_out_double(soap, "MinError", -1, &a->ns3__TTestParameters::MinError, ""))
		return soap->error;
	if (soap_out_double(soap, "MaxError", -1, &a->ns3__TTestParameters::MaxError, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__TTestParameters::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns3__TTestParameters(soap, tag, this, type);
}

SOAP_FMAC3 ns3__TTestParameters * SOAP_FMAC4 soap_in_ns3__TTestParameters(struct soap *soap, const char *tag, ns3__TTestParameters *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__TTestParameters*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__TTestParameters, sizeof(ns3__TTestParameters), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns3__TTestParameters)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__TTestParameters *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_MinFlowrate1 = 1;
	size_t soap_flag_MaxFlowrate1 = 1;
	size_t soap_flag_MinTemperature1 = 1;
	size_t soap_flag_MaxTemperature1 = 1;
	size_t soap_flag_MinVolume1 = 1;
	size_t soap_flag_ProofMethod1 = 1;
	size_t soap_flag_MeterIndicationMethod1 = 1;
	size_t soap_flag_MinError1 = 1;
	size_t soap_flag_MaxError1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MinFlowrate1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "MinFlowrate", &a->ns3__TTestParameters::MinFlowrate, "xsd:double"))
				{	soap_flag_MinFlowrate1--;
					continue;
				}
			}
			if (soap_flag_MaxFlowrate1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "MaxFlowrate", &a->ns3__TTestParameters::MaxFlowrate, "xsd:double"))
				{	soap_flag_MaxFlowrate1--;
					continue;
				}
			}
			if (soap_flag_MinTemperature1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "MinTemperature", &a->ns3__TTestParameters::MinTemperature, "xsd:double"))
				{	soap_flag_MinTemperature1--;
					continue;
				}
			}
			if (soap_flag_MaxTemperature1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "MaxTemperature", &a->ns3__TTestParameters::MaxTemperature, "xsd:double"))
				{	soap_flag_MaxTemperature1--;
					continue;
				}
			}
			if (soap_flag_MinVolume1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "MinVolume", &a->ns3__TTestParameters::MinVolume, "xsd:double"))
				{	soap_flag_MinVolume1--;
					continue;
				}
			}
			if (soap_flag_ProofMethod1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_ns3__TProofMethod(soap, "ProofMethod", &a->ns3__TTestParameters::ProofMethod, "ns3:TProofMethod"))
				{	soap_flag_ProofMethod1--;
					continue;
				}
			}
			if (soap_flag_MeterIndicationMethod1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_ns3__TMeterIndicationMethod(soap, "MeterIndicationMethod", &a->ns3__TTestParameters::MeterIndicationMethod, "ns3:TMeterIndicationMethod"))
				{	soap_flag_MeterIndicationMethod1--;
					continue;
				}
			}
			if (soap_flag_MinError1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "MinError", &a->ns3__TTestParameters::MinError, "xsd:double"))
				{	soap_flag_MinError1--;
					continue;
				}
			}
			if (soap_flag_MaxError1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "MaxError", &a->ns3__TTestParameters::MaxError, "xsd:double"))
				{	soap_flag_MaxError1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_MinFlowrate1 > 0 || soap_flag_MaxFlowrate1 > 0 || soap_flag_MinTemperature1 > 0 || soap_flag_MaxTemperature1 > 0 || soap_flag_MinVolume1 > 0 || soap_flag_ProofMethod1 > 0 || soap_flag_MeterIndicationMethod1 > 0 || soap_flag_MinError1 > 0 || soap_flag_MaxError1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns3__TTestParameters *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__TTestParameters, SOAP_TYPE_ns3__TTestParameters, sizeof(ns3__TTestParameters), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__TTestParameters * SOAP_FMAC2 soap_instantiate_ns3__TTestParameters(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__TTestParameters(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__TTestParameters *p;
	size_t k = sizeof(ns3__TTestParameters);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns3__TTestParameters, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns3__TTestParameters);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns3__TTestParameters, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__TTestParameters location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns3__TTestParameters::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__TTestParameters(soap, tag ? tag : "ns3:TTestParameters", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__TTestParameters::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__TTestParameters(soap, this, tag, type);
}

SOAP_FMAC3 ns3__TTestParameters * SOAP_FMAC4 soap_get_ns3__TTestParameters(struct soap *soap, ns3__TTestParameters *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__TTestParameters(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void TBooleanDynArray::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__ptr = NULL;
	this->__size = 0;
}

void TBooleanDynArray::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (this->__ptr && !soap_array_reference(soap, this, this->__ptr, this->__size, SOAP_TYPE_TBooleanDynArray))
	{	for (size_t i = 0; i < (size_t)this->__size; i++)
		{	soap_embedded(soap, this->__ptr + i, SOAP_TYPE_bool);
		}
	}
#endif
}

int TBooleanDynArray::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_TBooleanDynArray(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TBooleanDynArray(struct soap *soap, const char *tag, int id, const TBooleanDynArray *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptr ? soap_putsizesoffsets(soap, "xsd:boolean", &a->__size, NULL, 1) : NULL;
	id = soap_element_id(soap, tag, id, a, a->__ptr, a->__size, type, SOAP_TYPE_TBooleanDynArray, NULL);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		if (soap_out_bool(soap, "item", -1, &a->__ptr[i], ""))
			return soap->error;
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *TBooleanDynArray::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_TBooleanDynArray(soap, tag, this, type);
}

SOAP_FMAC3 TBooleanDynArray * SOAP_FMAC4 soap_in_TBooleanDynArray(struct soap *soap, const char *tag, TBooleanDynArray *a, const char *type)
{
	int i, j;
	bool *p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (TBooleanDynArray*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TBooleanDynArray, sizeof(TBooleanDynArray), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		if (*soap->arraySize)
		{
			soap_getsizes(soap->arraySize, &a->__size, 1);
			a->__size -= j = soap_getoffsets(soap->arrayOffset, &a->__size, NULL, 1);
			if ((size_t)a->__size > soap->maxoccurs)
			{	soap->error = SOAP_OCCURS;
				return NULL;
			}
			a->__ptr = (bool *)soap_malloc(soap, sizeof(bool) * a->__size);
			for (i = 0; i < a->__size; i++)
				soap_default_bool(soap, a->__ptr+i);
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_bool(soap, NULL, a->__ptr + i, "xsd:boolean"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_alloc_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (bool *)soap_push_block(soap, NULL, sizeof(bool));
				if (!p)
					break;
				soap_default_bool(soap, p);
				if (!soap_in_bool(soap, NULL, p, "xsd:boolean"))
				{	if (soap->error == SOAP_NO_TAG)
						soap->error = SOAP_OK;
					soap_pop_block(soap, NULL);
					break;
				}
				if ((size_t)a->__size > soap->maxoccurs)
				{	soap->error = SOAP_OCCURS;
					return NULL;
				}
			}
			a->__ptr = (bool *)soap_save_block(soap, NULL, NULL, 1);
		}
		if (soap->error || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (TBooleanDynArray *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TBooleanDynArray, SOAP_TYPE_TBooleanDynArray, sizeof(TBooleanDynArray), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 TBooleanDynArray * SOAP_FMAC2 soap_instantiate_TBooleanDynArray(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TBooleanDynArray(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	TBooleanDynArray *p;
	size_t k = sizeof(TBooleanDynArray);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_TBooleanDynArray, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, TBooleanDynArray);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, TBooleanDynArray, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated TBooleanDynArray location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int TBooleanDynArray::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_TBooleanDynArray(soap, tag ? tag : "SOAP-ENC:Array", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *TBooleanDynArray::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_TBooleanDynArray(soap, this, tag, type);
}

SOAP_FMAC3 TBooleanDynArray * SOAP_FMAC4 soap_get_TBooleanDynArray(struct soap *soap, TBooleanDynArray *p, const char *tag, const char *type)
{
	if ((p = soap_in_TBooleanDynArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void TIntegerDynArray::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__ptr = NULL;
	this->__size = 0;
}

void TIntegerDynArray::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (this->__ptr && !soap_array_reference(soap, this, this->__ptr, this->__size, SOAP_TYPE_TIntegerDynArray))
	{	for (size_t i = 0; i < (size_t)this->__size; i++)
		{	soap_embedded(soap, this->__ptr + i, SOAP_TYPE_int);
		}
	}
#endif
}

int TIntegerDynArray::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_TIntegerDynArray(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TIntegerDynArray(struct soap *soap, const char *tag, int id, const TIntegerDynArray *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptr ? soap_putsizesoffsets(soap, "xsd:int", &a->__size, NULL, 1) : NULL;
	id = soap_element_id(soap, tag, id, a, a->__ptr, a->__size, type, SOAP_TYPE_TIntegerDynArray, NULL);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		if (soap_out_int(soap, "item", -1, &a->__ptr[i], ""))
			return soap->error;
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *TIntegerDynArray::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_TIntegerDynArray(soap, tag, this, type);
}

SOAP_FMAC3 TIntegerDynArray * SOAP_FMAC4 soap_in_TIntegerDynArray(struct soap *soap, const char *tag, TIntegerDynArray *a, const char *type)
{
	int i, j;
	int *p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (TIntegerDynArray*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TIntegerDynArray, sizeof(TIntegerDynArray), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		if (*soap->arraySize)
		{
			soap_getsizes(soap->arraySize, &a->__size, 1);
			a->__size -= j = soap_getoffsets(soap->arrayOffset, &a->__size, NULL, 1);
			if ((size_t)a->__size > soap->maxoccurs)
			{	soap->error = SOAP_OCCURS;
				return NULL;
			}
			a->__ptr = (int *)soap_malloc(soap, sizeof(int) * a->__size);
			for (i = 0; i < a->__size; i++)
				soap_default_int(soap, a->__ptr+i);
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_int(soap, NULL, a->__ptr + i, "xsd:int"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_alloc_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (int *)soap_push_block(soap, NULL, sizeof(int));
				if (!p)
					break;
				soap_default_int(soap, p);
				if (!soap_in_int(soap, NULL, p, "xsd:int"))
				{	if (soap->error == SOAP_NO_TAG)
						soap->error = SOAP_OK;
					soap_pop_block(soap, NULL);
					break;
				}
				if ((size_t)a->__size > soap->maxoccurs)
				{	soap->error = SOAP_OCCURS;
					return NULL;
				}
			}
			a->__ptr = (int *)soap_save_block(soap, NULL, NULL, 1);
		}
		if (soap->error || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (TIntegerDynArray *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TIntegerDynArray, SOAP_TYPE_TIntegerDynArray, sizeof(TIntegerDynArray), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 TIntegerDynArray * SOAP_FMAC2 soap_instantiate_TIntegerDynArray(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TIntegerDynArray(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	TIntegerDynArray *p;
	size_t k = sizeof(TIntegerDynArray);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_TIntegerDynArray, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, TIntegerDynArray);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, TIntegerDynArray, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated TIntegerDynArray location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int TIntegerDynArray::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_TIntegerDynArray(soap, tag ? tag : "SOAP-ENC:Array", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *TIntegerDynArray::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_TIntegerDynArray(soap, this, tag, type);
}

SOAP_FMAC3 TIntegerDynArray * SOAP_FMAC4 soap_get_TIntegerDynArray(struct soap *soap, TIntegerDynArray *p, const char *tag, const char *type)
{
	if ((p = soap_in_TIntegerDynArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void TStringDynArray::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__ptr = NULL;
	this->__size = 0;
}

void TStringDynArray::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (this->__ptr && !soap_array_reference(soap, this, this->__ptr, this->__size, SOAP_TYPE_TStringDynArray))
	{	for (size_t i = 0; i < (size_t)this->__size; i++)
		{	soap_embedded(soap, this->__ptr + i, SOAP_TYPE_std__string);
			soap_serialize_std__string(soap, this->__ptr + i);
		}
	}
#endif
}

int TStringDynArray::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_TStringDynArray(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TStringDynArray(struct soap *soap, const char *tag, int id, const TStringDynArray *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptr ? soap_putsizesoffsets(soap, "xsd:string", &a->__size, NULL, 1) : NULL;
	id = soap_element_id(soap, tag, id, a, a->__ptr, a->__size, type, SOAP_TYPE_TStringDynArray, NULL);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		if (soap_out_std__string(soap, "item", -1, &a->__ptr[i], ""))
			return soap->error;
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *TStringDynArray::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_TStringDynArray(soap, tag, this, type);
}

SOAP_FMAC3 TStringDynArray * SOAP_FMAC4 soap_in_TStringDynArray(struct soap *soap, const char *tag, TStringDynArray *a, const char *type)
{
	int i, j;
	std::string *p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (TStringDynArray*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TStringDynArray, sizeof(TStringDynArray), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		if (*soap->arraySize)
		{
			soap_getsizes(soap->arraySize, &a->__size, 1);
			a->__size -= j = soap_getoffsets(soap->arrayOffset, &a->__size, NULL, 1);
			if ((size_t)a->__size > soap->maxoccurs)
			{	soap->error = SOAP_OCCURS;
				return NULL;
			}
			a->__ptr = soap_new_std__string(soap, a->__size);
			for (i = 0; i < a->__size; i++)
				soap_default_std__string(soap, a->__ptr+i);
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_std__string(soap, NULL, a->__ptr + i, "xsd:string"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_alloc_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = soap_block<std::string>::push(soap, NULL);
				if (!p)
					break;
				soap_default_std__string(soap, p);
				if (!soap_in_std__string(soap, NULL, p, "xsd:string"))
				{	if (soap->error == SOAP_NO_TAG)
						soap->error = SOAP_OK;
					soap_block<std::string>::pop(soap, NULL);
					break;
				}
				if ((size_t)a->__size > soap->maxoccurs)
				{	soap->error = SOAP_OCCURS;
					return NULL;
				}
			}
			if (soap->blist->size)
				a->__ptr = soap_new_std__string(soap, soap->blist->size/sizeof(std::string));
			else
				a->__ptr = NULL;
			if (a->__ptr)
				soap_block<std::string>::save(soap, NULL, a->__ptr);
			else
				soap_block<std::string>::end(soap, NULL);
		}
		if (soap->error || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (TStringDynArray *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TStringDynArray, SOAP_TYPE_TStringDynArray, sizeof(TStringDynArray), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 TStringDynArray * SOAP_FMAC2 soap_instantiate_TStringDynArray(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TStringDynArray(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	TStringDynArray *p;
	size_t k = sizeof(TStringDynArray);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_TStringDynArray, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, TStringDynArray);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, TStringDynArray, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated TStringDynArray location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int TStringDynArray::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_TStringDynArray(soap, tag ? tag : "SOAP-ENC:Array", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *TStringDynArray::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_TStringDynArray(soap, this, tag, type);
}

SOAP_FMAC3 TStringDynArray * SOAP_FMAC4 soap_get_TStringDynArray(struct soap *soap, TStringDynArray *p, const char *tag, const char *type)
{
	if ((p = soap_in_TStringDynArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void SOAP_ENC__Array::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->__ptr = NULL;
	this->__size = 0;
}

void SOAP_ENC__Array::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (this->__ptr && !soap_array_reference(soap, this, this->__ptr, this->__size, SOAP_TYPE_SOAP_ENC__Array))
	{	for (size_t i = 0; i < (size_t)this->__size; i++)
		{
		}
	}
#endif
}

int SOAP_ENC__Array::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_SOAP_ENC__Array(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENC__Array(struct soap *soap, const char *tag, int id, const SOAP_ENC__Array *a, const char *type)
{
	int i, n = a->__size;
	id = soap_element_id(soap, tag, id, a, a->__ptr, a->__size, type, SOAP_TYPE_SOAP_ENC__Array, NULL);
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		if (soap_outliteral(soap, "item", &a->__ptr[i], NULL))
			return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *SOAP_ENC__Array::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_SOAP_ENC__Array(soap, tag, this, type);
}

SOAP_FMAC3 SOAP_ENC__Array * SOAP_FMAC4 soap_in_SOAP_ENC__Array(struct soap *soap, const char *tag, SOAP_ENC__Array *a, const char *type)
{
	int i, j;
	char **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_array(soap, "") && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (SOAP_ENC__Array*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENC__Array, sizeof(SOAP_ENC__Array), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		if (*soap->arraySize)
		{
			soap_getsizes(soap->arraySize, &a->__size, 1);
			a->__size -= j = soap_getoffsets(soap->arrayOffset, &a->__size, NULL, 1);
			if ((size_t)a->__size > soap->maxoccurs)
			{	soap->error = SOAP_OCCURS;
				return NULL;
			}
			a->__ptr = (char **)soap_malloc(soap, sizeof(char *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_inliteral(soap, NULL, (char**)(a->__ptr + i)))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_alloc_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (char **)soap_push_block(soap, NULL, sizeof(char *));
				if (!p)
					break;
				*p = NULL;
				if (!soap_inliteral(soap, NULL, p))
				{	if (soap->error == SOAP_NO_TAG)
						soap->error = SOAP_OK;
					soap_pop_block(soap, NULL);
					break;
				}
				if ((size_t)a->__size > soap->maxoccurs)
				{	soap->error = SOAP_OCCURS;
					return NULL;
				}
			}
			a->__ptr = (char **)soap_save_block(soap, NULL, NULL, 1);
		}
		if (soap->error || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (SOAP_ENC__Array *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENC__Array, SOAP_TYPE_SOAP_ENC__Array, sizeof(SOAP_ENC__Array), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 SOAP_ENC__Array * SOAP_FMAC2 soap_instantiate_SOAP_ENC__Array(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENC__Array(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	SOAP_ENC__Array *p;
	size_t k = sizeof(SOAP_ENC__Array);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENC__Array, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, SOAP_ENC__Array);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, SOAP_ENC__Array, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated SOAP_ENC__Array location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int SOAP_ENC__Array::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_SOAP_ENC__Array(soap, tag ? tag : "SOAP-ENC:Array", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *SOAP_ENC__Array::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_SOAP_ENC__Array(soap, this, tag, type);
}

SOAP_FMAC3 SOAP_ENC__Array * SOAP_FMAC4 soap_get_SOAP_ENC__Array(struct soap *soap, SOAP_ENC__Array *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENC__Array(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->faultcode);
	soap_serialize_string(soap, (char*const*)&a->faultstring);
	soap_serialize_string(soap, (char*const*)&a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Node);
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode;
	soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)(void*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, (char*const*)&a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, (char*const*)&a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, (char*const*)&a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, (char*const*)&a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Fault*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__QName(soap, "faultcode", (char**)&a->faultcode, "xsd:QName"))
				{	soap_flag_faultcode--;
					continue;
				}
			}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "faultstring", (char**)&a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "faultactor", (char**)&a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Node", (char**)&a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Role", (char**)&a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Fault *p;
	size_t k = sizeof(struct SOAP_ENV__Fault);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Fault);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Fault, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Fault location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Fault(soap, tag ? tag : "SOAP-ENV:Fault", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Text);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, (char*const*)&a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Reason*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Text", (char**)&a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Reason *p;
	size_t k = sizeof(struct SOAP_ENV__Reason);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Reason);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Reason, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Reason location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Reason(soap, tag ? tag : "SOAP-ENV:Reason", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	a->__type = 0;
	a->fault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_markelement(soap, a->fault, a->__type);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->__any, NULL))
		return soap->error;
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag_fault = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Detail*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->fault = soap_getelement(soap, "fault", &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->__any))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Detail *p;
	size_t k = sizeof(struct SOAP_ENV__Detail);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Detail);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Detail, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Detail location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Detail(soap, tag ? tag : "SOAP-ENV:Detail", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value;
	soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)(void*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Code*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__QName(soap, "SOAP-ENV:Value", (char**)&a->SOAP_ENV__Value, "xsd:QName"))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Code *p;
	size_t k = sizeof(struct SOAP_ENV__Code);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Code);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Code, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Code location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Code(soap, tag ? tag : "SOAP-ENV:Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Header*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Header *p;
	size_t k = sizeof(struct SOAP_ENV__Header);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Header);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Header, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Header location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Header(soap, tag ? tag : "SOAP-ENV:Header", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__SetTestConfiguration(struct soap *soap, struct ns4__SetTestConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->Bench);
	soap_default_std__string(soap, &a->TestName);
	soap_default_std__string(soap, &a->Configuration);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__SetTestConfiguration(struct soap *soap, const struct ns4__SetTestConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Bench, SOAP_TYPE_int);
	soap_embedded(soap, &a->TestName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->TestName);
	soap_embedded(soap, &a->Configuration, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->Configuration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__SetTestConfiguration(struct soap *soap, const char *tag, int id, const struct ns4__SetTestConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__SetTestConfiguration), type))
		return soap->error;
	if (soap_out_int(soap, "Bench", -1, &a->Bench, ""))
		return soap->error;
	if (soap_out_std__string(soap, "TestName", -1, &a->TestName, ""))
		return soap->error;
	if (soap_out_std__string(soap, "Configuration", -1, &a->Configuration, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__SetTestConfiguration * SOAP_FMAC4 soap_in_ns4__SetTestConfiguration(struct soap *soap, const char *tag, struct ns4__SetTestConfiguration *a, const char *type)
{
	size_t soap_flag_Bench = 1;
	size_t soap_flag_TestName = 1;
	size_t soap_flag_Configuration = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns4__SetTestConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__SetTestConfiguration, sizeof(struct ns4__SetTestConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns4__SetTestConfiguration(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Bench && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "Bench", &a->Bench, "xsd:int"))
				{	soap_flag_Bench--;
					continue;
				}
			}
			if (soap_flag_TestName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "TestName", &a->TestName, "xsd:string"))
				{	soap_flag_TestName--;
					continue;
				}
			}
			if (soap_flag_Configuration && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "Configuration", &a->Configuration, "xsd:string"))
				{	soap_flag_Configuration--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Bench > 0 || soap_flag_TestName > 0 || soap_flag_Configuration > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns4__SetTestConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__SetTestConfiguration, SOAP_TYPE_ns4__SetTestConfiguration, sizeof(struct ns4__SetTestConfiguration), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns4__SetTestConfiguration * SOAP_FMAC2 soap_instantiate_ns4__SetTestConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__SetTestConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns4__SetTestConfiguration *p;
	size_t k = sizeof(struct ns4__SetTestConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns4__SetTestConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns4__SetTestConfiguration);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns4__SetTestConfiguration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns4__SetTestConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__SetTestConfiguration(struct soap *soap, const struct ns4__SetTestConfiguration *a, const char *tag, const char *type)
{
	if (soap_out_ns4__SetTestConfiguration(soap, tag ? tag : "ns4:SetTestConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__SetTestConfiguration * SOAP_FMAC4 soap_get_ns4__SetTestConfiguration(struct soap *soap, struct ns4__SetTestConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__SetTestConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__SetTestConfigurationResponse(struct soap *soap, struct ns4__SetTestConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns3__TResult(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__SetTestConfigurationResponse(struct soap *soap, const struct ns4__SetTestConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__SetTestConfigurationResponse(struct soap *soap, const char *tag, int id, const struct ns4__SetTestConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__SetTestConfigurationResponse), type))
		return soap->error;
	if (soap_out_ns3__TResult(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__SetTestConfigurationResponse * SOAP_FMAC4 soap_in_ns4__SetTestConfigurationResponse(struct soap *soap, const char *tag, struct ns4__SetTestConfigurationResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns4__SetTestConfigurationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__SetTestConfigurationResponse, sizeof(struct ns4__SetTestConfigurationResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__SetTestConfigurationResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_ns3__TResult(soap, "return", &a->return_, "ns3:TResult"))
				{	soap_flag_return_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_ > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns4__SetTestConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__SetTestConfigurationResponse, SOAP_TYPE_ns4__SetTestConfigurationResponse, sizeof(struct ns4__SetTestConfigurationResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns4__SetTestConfigurationResponse * SOAP_FMAC2 soap_instantiate_ns4__SetTestConfigurationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__SetTestConfigurationResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns4__SetTestConfigurationResponse *p;
	size_t k = sizeof(struct ns4__SetTestConfigurationResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns4__SetTestConfigurationResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns4__SetTestConfigurationResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns4__SetTestConfigurationResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns4__SetTestConfigurationResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__SetTestConfigurationResponse(struct soap *soap, const struct ns4__SetTestConfigurationResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns4__SetTestConfigurationResponse(soap, tag ? tag : "ns4:SetTestConfigurationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__SetTestConfigurationResponse * SOAP_FMAC4 soap_get_ns4__SetTestConfigurationResponse(struct soap *soap, struct ns4__SetTestConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__SetTestConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__GetTestConfiguration(struct soap *soap, struct ns4__GetTestConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->Bench);
	soap_default_std__string(soap, &a->TestName);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__GetTestConfiguration(struct soap *soap, const struct ns4__GetTestConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Bench, SOAP_TYPE_int);
	soap_embedded(soap, &a->TestName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->TestName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__GetTestConfiguration(struct soap *soap, const char *tag, int id, const struct ns4__GetTestConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__GetTestConfiguration), type))
		return soap->error;
	if (soap_out_int(soap, "Bench", -1, &a->Bench, ""))
		return soap->error;
	if (soap_out_std__string(soap, "TestName", -1, &a->TestName, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__GetTestConfiguration * SOAP_FMAC4 soap_in_ns4__GetTestConfiguration(struct soap *soap, const char *tag, struct ns4__GetTestConfiguration *a, const char *type)
{
	size_t soap_flag_Bench = 1;
	size_t soap_flag_TestName = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns4__GetTestConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__GetTestConfiguration, sizeof(struct ns4__GetTestConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns4__GetTestConfiguration(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Bench && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "Bench", &a->Bench, "xsd:int"))
				{	soap_flag_Bench--;
					continue;
				}
			}
			if (soap_flag_TestName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "TestName", &a->TestName, "xsd:string"))
				{	soap_flag_TestName--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Bench > 0 || soap_flag_TestName > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns4__GetTestConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__GetTestConfiguration, SOAP_TYPE_ns4__GetTestConfiguration, sizeof(struct ns4__GetTestConfiguration), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns4__GetTestConfiguration * SOAP_FMAC2 soap_instantiate_ns4__GetTestConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__GetTestConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns4__GetTestConfiguration *p;
	size_t k = sizeof(struct ns4__GetTestConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns4__GetTestConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns4__GetTestConfiguration);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns4__GetTestConfiguration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns4__GetTestConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__GetTestConfiguration(struct soap *soap, const struct ns4__GetTestConfiguration *a, const char *tag, const char *type)
{
	if (soap_out_ns4__GetTestConfiguration(soap, tag ? tag : "ns4:GetTestConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__GetTestConfiguration * SOAP_FMAC4 soap_get_ns4__GetTestConfiguration(struct soap *soap, struct ns4__GetTestConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__GetTestConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__GetTestConfigurationResponse(struct soap *soap, struct ns4__GetTestConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__GetTestConfigurationResponse(struct soap *soap, const struct ns4__GetTestConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->return_, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__GetTestConfigurationResponse(struct soap *soap, const char *tag, int id, const struct ns4__GetTestConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__GetTestConfigurationResponse), type))
		return soap->error;
	if (soap_out_std__string(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__GetTestConfigurationResponse * SOAP_FMAC4 soap_in_ns4__GetTestConfigurationResponse(struct soap *soap, const char *tag, struct ns4__GetTestConfigurationResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns4__GetTestConfigurationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__GetTestConfigurationResponse, sizeof(struct ns4__GetTestConfigurationResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns4__GetTestConfigurationResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "return", &a->return_, "xsd:string"))
				{	soap_flag_return_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_ > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns4__GetTestConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__GetTestConfigurationResponse, SOAP_TYPE_ns4__GetTestConfigurationResponse, sizeof(struct ns4__GetTestConfigurationResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns4__GetTestConfigurationResponse * SOAP_FMAC2 soap_instantiate_ns4__GetTestConfigurationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__GetTestConfigurationResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns4__GetTestConfigurationResponse *p;
	size_t k = sizeof(struct ns4__GetTestConfigurationResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns4__GetTestConfigurationResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns4__GetTestConfigurationResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns4__GetTestConfigurationResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns4__GetTestConfigurationResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__GetTestConfigurationResponse(struct soap *soap, const struct ns4__GetTestConfigurationResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns4__GetTestConfigurationResponse(soap, tag ? tag : "ns4:GetTestConfigurationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__GetTestConfigurationResponse * SOAP_FMAC4 soap_get_ns4__GetTestConfigurationResponse(struct soap *soap, struct ns4__GetTestConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__GetTestConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__GetPressTestResult(struct soap *soap, struct ns4__GetPressTestResult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->Bench);
	soap_default_std__string(soap, &a->TestName);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__GetPressTestResult(struct soap *soap, const struct ns4__GetPressTestResult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Bench, SOAP_TYPE_int);
	soap_embedded(soap, &a->TestName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->TestName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__GetPressTestResult(struct soap *soap, const char *tag, int id, const struct ns4__GetPressTestResult *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__GetPressTestResult), type))
		return soap->error;
	if (soap_out_int(soap, "Bench", -1, &a->Bench, ""))
		return soap->error;
	if (soap_out_std__string(soap, "TestName", -1, &a->TestName, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__GetPressTestResult * SOAP_FMAC4 soap_in_ns4__GetPressTestResult(struct soap *soap, const char *tag, struct ns4__GetPressTestResult *a, const char *type)
{
	size_t soap_flag_Bench = 1;
	size_t soap_flag_TestName = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns4__GetPressTestResult*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__GetPressTestResult, sizeof(struct ns4__GetPressTestResult), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns4__GetPressTestResult(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Bench && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "Bench", &a->Bench, "xsd:int"))
				{	soap_flag_Bench--;
					continue;
				}
			}
			if (soap_flag_TestName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "TestName", &a->TestName, "xsd:string"))
				{	soap_flag_TestName--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Bench > 0 || soap_flag_TestName > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns4__GetPressTestResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__GetPressTestResult, SOAP_TYPE_ns4__GetPressTestResult, sizeof(struct ns4__GetPressTestResult), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns4__GetPressTestResult * SOAP_FMAC2 soap_instantiate_ns4__GetPressTestResult(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__GetPressTestResult(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns4__GetPressTestResult *p;
	size_t k = sizeof(struct ns4__GetPressTestResult);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns4__GetPressTestResult, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns4__GetPressTestResult);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns4__GetPressTestResult, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns4__GetPressTestResult location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__GetPressTestResult(struct soap *soap, const struct ns4__GetPressTestResult *a, const char *tag, const char *type)
{
	if (soap_out_ns4__GetPressTestResult(soap, tag ? tag : "ns4:GetPressTestResult", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__GetPressTestResult * SOAP_FMAC4 soap_get_ns4__GetPressTestResult(struct soap *soap, struct ns4__GetPressTestResult *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__GetPressTestResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__GetPressTestResultResponse(struct soap *soap, struct ns4__GetPressTestResultResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__GetPressTestResultResponse(struct soap *soap, const struct ns4__GetPressTestResultResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons3__TPressTestResult(soap, &a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__GetPressTestResultResponse(struct soap *soap, const char *tag, int id, const struct ns4__GetPressTestResultResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__GetPressTestResultResponse), type))
		return soap->error;
	if (soap_out_PointerTons3__TPressTestResult(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__GetPressTestResultResponse * SOAP_FMAC4 soap_in_ns4__GetPressTestResultResponse(struct soap *soap, const char *tag, struct ns4__GetPressTestResultResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns4__GetPressTestResultResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__GetPressTestResultResponse, sizeof(struct ns4__GetPressTestResultResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__GetPressTestResultResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__TPressTestResult(soap, "return", &a->return_, "ns3:TPressTestResult"))
				{	soap_flag_return_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns4__GetPressTestResultResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__GetPressTestResultResponse, SOAP_TYPE_ns4__GetPressTestResultResponse, sizeof(struct ns4__GetPressTestResultResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns4__GetPressTestResultResponse * SOAP_FMAC2 soap_instantiate_ns4__GetPressTestResultResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__GetPressTestResultResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns4__GetPressTestResultResponse *p;
	size_t k = sizeof(struct ns4__GetPressTestResultResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns4__GetPressTestResultResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns4__GetPressTestResultResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns4__GetPressTestResultResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns4__GetPressTestResultResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__GetPressTestResultResponse(struct soap *soap, const struct ns4__GetPressTestResultResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns4__GetPressTestResultResponse(soap, tag ? tag : "ns4:GetPressTestResultResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__GetPressTestResultResponse * SOAP_FMAC4 soap_get_ns4__GetPressTestResultResponse(struct soap *soap, struct ns4__GetPressTestResultResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__GetPressTestResultResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__GetTestResult(struct soap *soap, struct ns4__GetTestResult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->Bench);
	soap_default_std__string(soap, &a->TestName);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__GetTestResult(struct soap *soap, const struct ns4__GetTestResult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Bench, SOAP_TYPE_int);
	soap_embedded(soap, &a->TestName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->TestName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__GetTestResult(struct soap *soap, const char *tag, int id, const struct ns4__GetTestResult *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__GetTestResult), type))
		return soap->error;
	if (soap_out_int(soap, "Bench", -1, &a->Bench, ""))
		return soap->error;
	if (soap_out_std__string(soap, "TestName", -1, &a->TestName, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__GetTestResult * SOAP_FMAC4 soap_in_ns4__GetTestResult(struct soap *soap, const char *tag, struct ns4__GetTestResult *a, const char *type)
{
	size_t soap_flag_Bench = 1;
	size_t soap_flag_TestName = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns4__GetTestResult*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__GetTestResult, sizeof(struct ns4__GetTestResult), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns4__GetTestResult(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Bench && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "Bench", &a->Bench, "xsd:int"))
				{	soap_flag_Bench--;
					continue;
				}
			}
			if (soap_flag_TestName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "TestName", &a->TestName, "xsd:string"))
				{	soap_flag_TestName--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Bench > 0 || soap_flag_TestName > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns4__GetTestResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__GetTestResult, SOAP_TYPE_ns4__GetTestResult, sizeof(struct ns4__GetTestResult), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns4__GetTestResult * SOAP_FMAC2 soap_instantiate_ns4__GetTestResult(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__GetTestResult(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns4__GetTestResult *p;
	size_t k = sizeof(struct ns4__GetTestResult);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns4__GetTestResult, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns4__GetTestResult);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns4__GetTestResult, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns4__GetTestResult location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__GetTestResult(struct soap *soap, const struct ns4__GetTestResult *a, const char *tag, const char *type)
{
	if (soap_out_ns4__GetTestResult(soap, tag ? tag : "ns4:GetTestResult", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__GetTestResult * SOAP_FMAC4 soap_get_ns4__GetTestResult(struct soap *soap, struct ns4__GetTestResult *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__GetTestResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__GetTestResultResponse(struct soap *soap, struct ns4__GetTestResultResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__GetTestResultResponse(struct soap *soap, const struct ns4__GetTestResultResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons3__TTestResult(soap, &a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__GetTestResultResponse(struct soap *soap, const char *tag, int id, const struct ns4__GetTestResultResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__GetTestResultResponse), type))
		return soap->error;
	if (soap_out_PointerTons3__TTestResult(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__GetTestResultResponse * SOAP_FMAC4 soap_in_ns4__GetTestResultResponse(struct soap *soap, const char *tag, struct ns4__GetTestResultResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns4__GetTestResultResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__GetTestResultResponse, sizeof(struct ns4__GetTestResultResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__GetTestResultResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__TTestResult(soap, "return", &a->return_, "ns3:TTestResult"))
				{	soap_flag_return_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns4__GetTestResultResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__GetTestResultResponse, SOAP_TYPE_ns4__GetTestResultResponse, sizeof(struct ns4__GetTestResultResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns4__GetTestResultResponse * SOAP_FMAC2 soap_instantiate_ns4__GetTestResultResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__GetTestResultResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns4__GetTestResultResponse *p;
	size_t k = sizeof(struct ns4__GetTestResultResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns4__GetTestResultResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns4__GetTestResultResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns4__GetTestResultResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns4__GetTestResultResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__GetTestResultResponse(struct soap *soap, const struct ns4__GetTestResultResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns4__GetTestResultResponse(soap, tag ? tag : "ns4:GetTestResultResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__GetTestResultResponse * SOAP_FMAC4 soap_get_ns4__GetTestResultResponse(struct soap *soap, struct ns4__GetTestResultResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__GetTestResultResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__GetMeterResult(struct soap *soap, struct ns4__GetMeterResult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->Bench);
	soap_default_std__string(soap, &a->TestName);
	soap_default_int(soap, &a->MeterPos);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__GetMeterResult(struct soap *soap, const struct ns4__GetMeterResult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Bench, SOAP_TYPE_int);
	soap_embedded(soap, &a->TestName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->TestName);
	soap_embedded(soap, &a->MeterPos, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__GetMeterResult(struct soap *soap, const char *tag, int id, const struct ns4__GetMeterResult *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__GetMeterResult), type))
		return soap->error;
	if (soap_out_int(soap, "Bench", -1, &a->Bench, ""))
		return soap->error;
	if (soap_out_std__string(soap, "TestName", -1, &a->TestName, ""))
		return soap->error;
	if (soap_out_int(soap, "MeterPos", -1, &a->MeterPos, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__GetMeterResult * SOAP_FMAC4 soap_in_ns4__GetMeterResult(struct soap *soap, const char *tag, struct ns4__GetMeterResult *a, const char *type)
{
	size_t soap_flag_Bench = 1;
	size_t soap_flag_TestName = 1;
	size_t soap_flag_MeterPos = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns4__GetMeterResult*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__GetMeterResult, sizeof(struct ns4__GetMeterResult), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns4__GetMeterResult(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Bench && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "Bench", &a->Bench, "xsd:int"))
				{	soap_flag_Bench--;
					continue;
				}
			}
			if (soap_flag_TestName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "TestName", &a->TestName, "xsd:string"))
				{	soap_flag_TestName--;
					continue;
				}
			}
			if (soap_flag_MeterPos && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "MeterPos", &a->MeterPos, "xsd:int"))
				{	soap_flag_MeterPos--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Bench > 0 || soap_flag_TestName > 0 || soap_flag_MeterPos > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns4__GetMeterResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__GetMeterResult, SOAP_TYPE_ns4__GetMeterResult, sizeof(struct ns4__GetMeterResult), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns4__GetMeterResult * SOAP_FMAC2 soap_instantiate_ns4__GetMeterResult(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__GetMeterResult(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns4__GetMeterResult *p;
	size_t k = sizeof(struct ns4__GetMeterResult);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns4__GetMeterResult, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns4__GetMeterResult);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns4__GetMeterResult, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns4__GetMeterResult location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__GetMeterResult(struct soap *soap, const struct ns4__GetMeterResult *a, const char *tag, const char *type)
{
	if (soap_out_ns4__GetMeterResult(soap, tag ? tag : "ns4:GetMeterResult", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__GetMeterResult * SOAP_FMAC4 soap_get_ns4__GetMeterResult(struct soap *soap, struct ns4__GetMeterResult *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__GetMeterResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__GetMeterResultResponse(struct soap *soap, struct ns4__GetMeterResultResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__GetMeterResultResponse(struct soap *soap, const struct ns4__GetMeterResultResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons3__TMeterResult(soap, &a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__GetMeterResultResponse(struct soap *soap, const char *tag, int id, const struct ns4__GetMeterResultResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__GetMeterResultResponse), type))
		return soap->error;
	if (soap_out_PointerTons3__TMeterResult(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__GetMeterResultResponse * SOAP_FMAC4 soap_in_ns4__GetMeterResultResponse(struct soap *soap, const char *tag, struct ns4__GetMeterResultResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns4__GetMeterResultResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__GetMeterResultResponse, sizeof(struct ns4__GetMeterResultResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__GetMeterResultResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__TMeterResult(soap, "return", &a->return_, "ns3:TMeterResult"))
				{	soap_flag_return_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns4__GetMeterResultResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__GetMeterResultResponse, SOAP_TYPE_ns4__GetMeterResultResponse, sizeof(struct ns4__GetMeterResultResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns4__GetMeterResultResponse * SOAP_FMAC2 soap_instantiate_ns4__GetMeterResultResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__GetMeterResultResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns4__GetMeterResultResponse *p;
	size_t k = sizeof(struct ns4__GetMeterResultResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns4__GetMeterResultResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns4__GetMeterResultResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns4__GetMeterResultResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns4__GetMeterResultResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__GetMeterResultResponse(struct soap *soap, const struct ns4__GetMeterResultResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns4__GetMeterResultResponse(soap, tag ? tag : "ns4:GetMeterResultResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__GetMeterResultResponse * SOAP_FMAC4 soap_get_ns4__GetMeterResultResponse(struct soap *soap, struct ns4__GetMeterResultResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__GetMeterResultResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__GetTestResults(struct soap *soap, struct ns4__GetTestResults *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->Bench);
	soap_default_std__string(soap, &a->TestName);
	a->MetersPos = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__GetTestResults(struct soap *soap, const struct ns4__GetTestResults *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Bench, SOAP_TYPE_int);
	soap_embedded(soap, &a->TestName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->TestName);
	soap_serialize_PointerToTIntegerDynArray(soap, &a->MetersPos);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__GetTestResults(struct soap *soap, const char *tag, int id, const struct ns4__GetTestResults *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__GetTestResults), type))
		return soap->error;
	if (soap_out_int(soap, "Bench", -1, &a->Bench, ""))
		return soap->error;
	if (soap_out_std__string(soap, "TestName", -1, &a->TestName, ""))
		return soap->error;
	if (soap_out_PointerToTIntegerDynArray(soap, "MetersPos", -1, &a->MetersPos, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__GetTestResults * SOAP_FMAC4 soap_in_ns4__GetTestResults(struct soap *soap, const char *tag, struct ns4__GetTestResults *a, const char *type)
{
	size_t soap_flag_Bench = 1;
	size_t soap_flag_TestName = 1;
	size_t soap_flag_MetersPos = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns4__GetTestResults*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__GetTestResults, sizeof(struct ns4__GetTestResults), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns4__GetTestResults(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Bench && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "Bench", &a->Bench, "xsd:int"))
				{	soap_flag_Bench--;
					continue;
				}
			}
			if (soap_flag_TestName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "TestName", &a->TestName, "xsd:string"))
				{	soap_flag_TestName--;
					continue;
				}
			}
			if (soap_flag_MetersPos && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToTIntegerDynArray(soap, "MetersPos", &a->MetersPos, "xsd:int"))
				{	soap_flag_MetersPos--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Bench > 0 || soap_flag_TestName > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns4__GetTestResults *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__GetTestResults, SOAP_TYPE_ns4__GetTestResults, sizeof(struct ns4__GetTestResults), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns4__GetTestResults * SOAP_FMAC2 soap_instantiate_ns4__GetTestResults(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__GetTestResults(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns4__GetTestResults *p;
	size_t k = sizeof(struct ns4__GetTestResults);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns4__GetTestResults, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns4__GetTestResults);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns4__GetTestResults, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns4__GetTestResults location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__GetTestResults(struct soap *soap, const struct ns4__GetTestResults *a, const char *tag, const char *type)
{
	if (soap_out_ns4__GetTestResults(soap, tag ? tag : "ns4:GetTestResults", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__GetTestResults * SOAP_FMAC4 soap_get_ns4__GetTestResults(struct soap *soap, struct ns4__GetTestResults *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__GetTestResults(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__GetTestResultsResponse(struct soap *soap, struct ns4__GetTestResultsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__GetTestResultsResponse(struct soap *soap, const struct ns4__GetTestResultsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons3__TTestResults(soap, &a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__GetTestResultsResponse(struct soap *soap, const char *tag, int id, const struct ns4__GetTestResultsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__GetTestResultsResponse), type))
		return soap->error;
	if (soap_out_PointerTons3__TTestResults(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__GetTestResultsResponse * SOAP_FMAC4 soap_in_ns4__GetTestResultsResponse(struct soap *soap, const char *tag, struct ns4__GetTestResultsResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns4__GetTestResultsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__GetTestResultsResponse, sizeof(struct ns4__GetTestResultsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__GetTestResultsResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__TTestResults(soap, "return", &a->return_, "ns3:TTestResults"))
				{	soap_flag_return_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns4__GetTestResultsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__GetTestResultsResponse, SOAP_TYPE_ns4__GetTestResultsResponse, sizeof(struct ns4__GetTestResultsResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns4__GetTestResultsResponse * SOAP_FMAC2 soap_instantiate_ns4__GetTestResultsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__GetTestResultsResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns4__GetTestResultsResponse *p;
	size_t k = sizeof(struct ns4__GetTestResultsResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns4__GetTestResultsResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns4__GetTestResultsResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns4__GetTestResultsResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns4__GetTestResultsResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__GetTestResultsResponse(struct soap *soap, const struct ns4__GetTestResultsResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns4__GetTestResultsResponse(soap, tag ? tag : "ns4:GetTestResultsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__GetTestResultsResponse * SOAP_FMAC4 soap_get_ns4__GetTestResultsResponse(struct soap *soap, struct ns4__GetTestResultsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__GetTestResultsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__GetMeasurementData(struct soap *soap, struct ns4__GetMeasurementData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->Bench);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__GetMeasurementData(struct soap *soap, const struct ns4__GetMeasurementData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Bench, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__GetMeasurementData(struct soap *soap, const char *tag, int id, const struct ns4__GetMeasurementData *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__GetMeasurementData), type))
		return soap->error;
	if (soap_out_int(soap, "Bench", -1, &a->Bench, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__GetMeasurementData * SOAP_FMAC4 soap_in_ns4__GetMeasurementData(struct soap *soap, const char *tag, struct ns4__GetMeasurementData *a, const char *type)
{
	size_t soap_flag_Bench = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns4__GetMeasurementData*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__GetMeasurementData, sizeof(struct ns4__GetMeasurementData), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__GetMeasurementData(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Bench && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "Bench", &a->Bench, "xsd:int"))
				{	soap_flag_Bench--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Bench > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns4__GetMeasurementData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__GetMeasurementData, SOAP_TYPE_ns4__GetMeasurementData, sizeof(struct ns4__GetMeasurementData), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns4__GetMeasurementData * SOAP_FMAC2 soap_instantiate_ns4__GetMeasurementData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__GetMeasurementData(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns4__GetMeasurementData *p;
	size_t k = sizeof(struct ns4__GetMeasurementData);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns4__GetMeasurementData, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns4__GetMeasurementData);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns4__GetMeasurementData, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns4__GetMeasurementData location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__GetMeasurementData(struct soap *soap, const struct ns4__GetMeasurementData *a, const char *tag, const char *type)
{
	if (soap_out_ns4__GetMeasurementData(soap, tag ? tag : "ns4:GetMeasurementData", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__GetMeasurementData * SOAP_FMAC4 soap_get_ns4__GetMeasurementData(struct soap *soap, struct ns4__GetMeasurementData *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__GetMeasurementData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__GetMeasurementDataResponse(struct soap *soap, struct ns4__GetMeasurementDataResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__GetMeasurementDataResponse(struct soap *soap, const struct ns4__GetMeasurementDataResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons3__TMeasurementData(soap, &a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__GetMeasurementDataResponse(struct soap *soap, const char *tag, int id, const struct ns4__GetMeasurementDataResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__GetMeasurementDataResponse), type))
		return soap->error;
	if (soap_out_PointerTons3__TMeasurementData(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__GetMeasurementDataResponse * SOAP_FMAC4 soap_in_ns4__GetMeasurementDataResponse(struct soap *soap, const char *tag, struct ns4__GetMeasurementDataResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns4__GetMeasurementDataResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__GetMeasurementDataResponse, sizeof(struct ns4__GetMeasurementDataResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__GetMeasurementDataResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__TMeasurementData(soap, "return", &a->return_, "ns3:TMeasurementData"))
				{	soap_flag_return_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns4__GetMeasurementDataResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__GetMeasurementDataResponse, SOAP_TYPE_ns4__GetMeasurementDataResponse, sizeof(struct ns4__GetMeasurementDataResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns4__GetMeasurementDataResponse * SOAP_FMAC2 soap_instantiate_ns4__GetMeasurementDataResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__GetMeasurementDataResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns4__GetMeasurementDataResponse *p;
	size_t k = sizeof(struct ns4__GetMeasurementDataResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns4__GetMeasurementDataResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns4__GetMeasurementDataResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns4__GetMeasurementDataResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns4__GetMeasurementDataResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__GetMeasurementDataResponse(struct soap *soap, const struct ns4__GetMeasurementDataResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns4__GetMeasurementDataResponse(soap, tag ? tag : "ns4:GetMeasurementDataResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__GetMeasurementDataResponse * SOAP_FMAC4 soap_get_ns4__GetMeasurementDataResponse(struct soap *soap, struct ns4__GetMeasurementDataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__GetMeasurementDataResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__GetMeterPositions(struct soap *soap, struct ns4__GetMeterPositions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->Bench);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__GetMeterPositions(struct soap *soap, const struct ns4__GetMeterPositions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Bench, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__GetMeterPositions(struct soap *soap, const char *tag, int id, const struct ns4__GetMeterPositions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__GetMeterPositions), type))
		return soap->error;
	if (soap_out_int(soap, "Bench", -1, &a->Bench, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__GetMeterPositions * SOAP_FMAC4 soap_in_ns4__GetMeterPositions(struct soap *soap, const char *tag, struct ns4__GetMeterPositions *a, const char *type)
{
	size_t soap_flag_Bench = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns4__GetMeterPositions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__GetMeterPositions, sizeof(struct ns4__GetMeterPositions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__GetMeterPositions(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Bench && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "Bench", &a->Bench, "xsd:int"))
				{	soap_flag_Bench--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Bench > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns4__GetMeterPositions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__GetMeterPositions, SOAP_TYPE_ns4__GetMeterPositions, sizeof(struct ns4__GetMeterPositions), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns4__GetMeterPositions * SOAP_FMAC2 soap_instantiate_ns4__GetMeterPositions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__GetMeterPositions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns4__GetMeterPositions *p;
	size_t k = sizeof(struct ns4__GetMeterPositions);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns4__GetMeterPositions, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns4__GetMeterPositions);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns4__GetMeterPositions, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns4__GetMeterPositions location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__GetMeterPositions(struct soap *soap, const struct ns4__GetMeterPositions *a, const char *tag, const char *type)
{
	if (soap_out_ns4__GetMeterPositions(soap, tag ? tag : "ns4:GetMeterPositions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__GetMeterPositions * SOAP_FMAC4 soap_get_ns4__GetMeterPositions(struct soap *soap, struct ns4__GetMeterPositions *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__GetMeterPositions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__GetMeterPositionsResponse(struct soap *soap, struct ns4__GetMeterPositionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__GetMeterPositionsResponse(struct soap *soap, const struct ns4__GetMeterPositionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToTBooleanDynArray(soap, &a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__GetMeterPositionsResponse(struct soap *soap, const char *tag, int id, const struct ns4__GetMeterPositionsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__GetMeterPositionsResponse), type))
		return soap->error;
	if (soap_out_PointerToTBooleanDynArray(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__GetMeterPositionsResponse * SOAP_FMAC4 soap_in_ns4__GetMeterPositionsResponse(struct soap *soap, const char *tag, struct ns4__GetMeterPositionsResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns4__GetMeterPositionsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__GetMeterPositionsResponse, sizeof(struct ns4__GetMeterPositionsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__GetMeterPositionsResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToTBooleanDynArray(soap, "return", &a->return_, "xsd:boolean"))
				{	soap_flag_return_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns4__GetMeterPositionsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__GetMeterPositionsResponse, SOAP_TYPE_ns4__GetMeterPositionsResponse, sizeof(struct ns4__GetMeterPositionsResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns4__GetMeterPositionsResponse * SOAP_FMAC2 soap_instantiate_ns4__GetMeterPositionsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__GetMeterPositionsResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns4__GetMeterPositionsResponse *p;
	size_t k = sizeof(struct ns4__GetMeterPositionsResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns4__GetMeterPositionsResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns4__GetMeterPositionsResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns4__GetMeterPositionsResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns4__GetMeterPositionsResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__GetMeterPositionsResponse(struct soap *soap, const struct ns4__GetMeterPositionsResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns4__GetMeterPositionsResponse(soap, tag ? tag : "ns4:GetMeterPositionsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__GetMeterPositionsResponse * SOAP_FMAC4 soap_get_ns4__GetMeterPositionsResponse(struct soap *soap, struct ns4__GetMeterPositionsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__GetMeterPositionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__SetMeterIndications(struct soap *soap, struct ns4__SetMeterIndications *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->Bench);
	soap_default_std__string(soap, &a->TestName);
	a->MeterIndications = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__SetMeterIndications(struct soap *soap, const struct ns4__SetMeterIndications *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Bench, SOAP_TYPE_int);
	soap_embedded(soap, &a->TestName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->TestName);
	soap_serialize_PointerToTMeterIndications(soap, &a->MeterIndications);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__SetMeterIndications(struct soap *soap, const char *tag, int id, const struct ns4__SetMeterIndications *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__SetMeterIndications), type))
		return soap->error;
	if (soap_out_int(soap, "Bench", -1, &a->Bench, ""))
		return soap->error;
	if (soap_out_std__string(soap, "TestName", -1, &a->TestName, ""))
		return soap->error;
	if (soap_out_PointerToTMeterIndications(soap, "MeterIndications", -1, &a->MeterIndications, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__SetMeterIndications * SOAP_FMAC4 soap_in_ns4__SetMeterIndications(struct soap *soap, const char *tag, struct ns4__SetMeterIndications *a, const char *type)
{
	size_t soap_flag_Bench = 1;
	size_t soap_flag_TestName = 1;
	size_t soap_flag_MeterIndications = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns4__SetMeterIndications*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__SetMeterIndications, sizeof(struct ns4__SetMeterIndications), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns4__SetMeterIndications(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Bench && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "Bench", &a->Bench, "xsd:int"))
				{	soap_flag_Bench--;
					continue;
				}
			}
			if (soap_flag_TestName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "TestName", &a->TestName, "xsd:string"))
				{	soap_flag_TestName--;
					continue;
				}
			}
			if (soap_flag_MeterIndications && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToTMeterIndications(soap, "MeterIndications", &a->MeterIndications, "ns3:TMeterIndication"))
				{	soap_flag_MeterIndications--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Bench > 0 || soap_flag_TestName > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns4__SetMeterIndications *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__SetMeterIndications, SOAP_TYPE_ns4__SetMeterIndications, sizeof(struct ns4__SetMeterIndications), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns4__SetMeterIndications * SOAP_FMAC2 soap_instantiate_ns4__SetMeterIndications(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__SetMeterIndications(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns4__SetMeterIndications *p;
	size_t k = sizeof(struct ns4__SetMeterIndications);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns4__SetMeterIndications, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns4__SetMeterIndications);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns4__SetMeterIndications, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns4__SetMeterIndications location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__SetMeterIndications(struct soap *soap, const struct ns4__SetMeterIndications *a, const char *tag, const char *type)
{
	if (soap_out_ns4__SetMeterIndications(soap, tag ? tag : "ns4:SetMeterIndications", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__SetMeterIndications * SOAP_FMAC4 soap_get_ns4__SetMeterIndications(struct soap *soap, struct ns4__SetMeterIndications *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__SetMeterIndications(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__SetMeterIndicationsResponse(struct soap *soap, struct ns4__SetMeterIndicationsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns3__TResult(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__SetMeterIndicationsResponse(struct soap *soap, const struct ns4__SetMeterIndicationsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__SetMeterIndicationsResponse(struct soap *soap, const char *tag, int id, const struct ns4__SetMeterIndicationsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__SetMeterIndicationsResponse), type))
		return soap->error;
	if (soap_out_ns3__TResult(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__SetMeterIndicationsResponse * SOAP_FMAC4 soap_in_ns4__SetMeterIndicationsResponse(struct soap *soap, const char *tag, struct ns4__SetMeterIndicationsResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns4__SetMeterIndicationsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__SetMeterIndicationsResponse, sizeof(struct ns4__SetMeterIndicationsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__SetMeterIndicationsResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_ns3__TResult(soap, "return", &a->return_, "ns3:TResult"))
				{	soap_flag_return_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_ > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns4__SetMeterIndicationsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__SetMeterIndicationsResponse, SOAP_TYPE_ns4__SetMeterIndicationsResponse, sizeof(struct ns4__SetMeterIndicationsResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns4__SetMeterIndicationsResponse * SOAP_FMAC2 soap_instantiate_ns4__SetMeterIndicationsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__SetMeterIndicationsResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns4__SetMeterIndicationsResponse *p;
	size_t k = sizeof(struct ns4__SetMeterIndicationsResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns4__SetMeterIndicationsResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns4__SetMeterIndicationsResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns4__SetMeterIndicationsResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns4__SetMeterIndicationsResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__SetMeterIndicationsResponse(struct soap *soap, const struct ns4__SetMeterIndicationsResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns4__SetMeterIndicationsResponse(soap, tag ? tag : "ns4:SetMeterIndicationsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__SetMeterIndicationsResponse * SOAP_FMAC4 soap_get_ns4__SetMeterIndicationsResponse(struct soap *soap, struct ns4__SetMeterIndicationsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__SetMeterIndicationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__GetMeterData(struct soap *soap, struct ns4__GetMeterData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->Bench);
	soap_default_int(soap, &a->MeterPos);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__GetMeterData(struct soap *soap, const struct ns4__GetMeterData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Bench, SOAP_TYPE_int);
	soap_embedded(soap, &a->MeterPos, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__GetMeterData(struct soap *soap, const char *tag, int id, const struct ns4__GetMeterData *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__GetMeterData), type))
		return soap->error;
	if (soap_out_int(soap, "Bench", -1, &a->Bench, ""))
		return soap->error;
	if (soap_out_int(soap, "MeterPos", -1, &a->MeterPos, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__GetMeterData * SOAP_FMAC4 soap_in_ns4__GetMeterData(struct soap *soap, const char *tag, struct ns4__GetMeterData *a, const char *type)
{
	size_t soap_flag_Bench = 1;
	size_t soap_flag_MeterPos = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns4__GetMeterData*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__GetMeterData, sizeof(struct ns4__GetMeterData), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__GetMeterData(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Bench && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "Bench", &a->Bench, "xsd:int"))
				{	soap_flag_Bench--;
					continue;
				}
			}
			if (soap_flag_MeterPos && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "MeterPos", &a->MeterPos, "xsd:int"))
				{	soap_flag_MeterPos--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Bench > 0 || soap_flag_MeterPos > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns4__GetMeterData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__GetMeterData, SOAP_TYPE_ns4__GetMeterData, sizeof(struct ns4__GetMeterData), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns4__GetMeterData * SOAP_FMAC2 soap_instantiate_ns4__GetMeterData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__GetMeterData(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns4__GetMeterData *p;
	size_t k = sizeof(struct ns4__GetMeterData);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns4__GetMeterData, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns4__GetMeterData);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns4__GetMeterData, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns4__GetMeterData location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__GetMeterData(struct soap *soap, const struct ns4__GetMeterData *a, const char *tag, const char *type)
{
	if (soap_out_ns4__GetMeterData(soap, tag ? tag : "ns4:GetMeterData", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__GetMeterData * SOAP_FMAC4 soap_get_ns4__GetMeterData(struct soap *soap, struct ns4__GetMeterData *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__GetMeterData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__GetMeterDataResponse(struct soap *soap, struct ns4__GetMeterDataResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__GetMeterDataResponse(struct soap *soap, const struct ns4__GetMeterDataResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons3__TMeterData(soap, &a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__GetMeterDataResponse(struct soap *soap, const char *tag, int id, const struct ns4__GetMeterDataResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__GetMeterDataResponse), type))
		return soap->error;
	if (soap_out_PointerTons3__TMeterData(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__GetMeterDataResponse * SOAP_FMAC4 soap_in_ns4__GetMeterDataResponse(struct soap *soap, const char *tag, struct ns4__GetMeterDataResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns4__GetMeterDataResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__GetMeterDataResponse, sizeof(struct ns4__GetMeterDataResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__GetMeterDataResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__TMeterData(soap, "return", &a->return_, "ns3:TMeterData"))
				{	soap_flag_return_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns4__GetMeterDataResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__GetMeterDataResponse, SOAP_TYPE_ns4__GetMeterDataResponse, sizeof(struct ns4__GetMeterDataResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns4__GetMeterDataResponse * SOAP_FMAC2 soap_instantiate_ns4__GetMeterDataResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__GetMeterDataResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns4__GetMeterDataResponse *p;
	size_t k = sizeof(struct ns4__GetMeterDataResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns4__GetMeterDataResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns4__GetMeterDataResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns4__GetMeterDataResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns4__GetMeterDataResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__GetMeterDataResponse(struct soap *soap, const struct ns4__GetMeterDataResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns4__GetMeterDataResponse(soap, tag ? tag : "ns4:GetMeterDataResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__GetMeterDataResponse * SOAP_FMAC4 soap_get_ns4__GetMeterDataResponse(struct soap *soap, struct ns4__GetMeterDataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__GetMeterDataResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__GetMetersData(struct soap *soap, struct ns4__GetMetersData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->Bench);
	a->MetersPos = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__GetMetersData(struct soap *soap, const struct ns4__GetMetersData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Bench, SOAP_TYPE_int);
	soap_serialize_PointerToTIntegerDynArray(soap, &a->MetersPos);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__GetMetersData(struct soap *soap, const char *tag, int id, const struct ns4__GetMetersData *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__GetMetersData), type))
		return soap->error;
	if (soap_out_int(soap, "Bench", -1, &a->Bench, ""))
		return soap->error;
	if (soap_out_PointerToTIntegerDynArray(soap, "MetersPos", -1, &a->MetersPos, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__GetMetersData * SOAP_FMAC4 soap_in_ns4__GetMetersData(struct soap *soap, const char *tag, struct ns4__GetMetersData *a, const char *type)
{
	size_t soap_flag_Bench = 1;
	size_t soap_flag_MetersPos = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns4__GetMetersData*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__GetMetersData, sizeof(struct ns4__GetMetersData), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__GetMetersData(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Bench && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "Bench", &a->Bench, "xsd:int"))
				{	soap_flag_Bench--;
					continue;
				}
			}
			if (soap_flag_MetersPos && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToTIntegerDynArray(soap, "MetersPos", &a->MetersPos, "xsd:int"))
				{	soap_flag_MetersPos--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Bench > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns4__GetMetersData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__GetMetersData, SOAP_TYPE_ns4__GetMetersData, sizeof(struct ns4__GetMetersData), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns4__GetMetersData * SOAP_FMAC2 soap_instantiate_ns4__GetMetersData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__GetMetersData(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns4__GetMetersData *p;
	size_t k = sizeof(struct ns4__GetMetersData);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns4__GetMetersData, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns4__GetMetersData);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns4__GetMetersData, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns4__GetMetersData location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__GetMetersData(struct soap *soap, const struct ns4__GetMetersData *a, const char *tag, const char *type)
{
	if (soap_out_ns4__GetMetersData(soap, tag ? tag : "ns4:GetMetersData", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__GetMetersData * SOAP_FMAC4 soap_get_ns4__GetMetersData(struct soap *soap, struct ns4__GetMetersData *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__GetMetersData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__GetMetersDataResponse(struct soap *soap, struct ns4__GetMetersDataResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__GetMetersDataResponse(struct soap *soap, const struct ns4__GetMetersDataResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToTMetersData(soap, &a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__GetMetersDataResponse(struct soap *soap, const char *tag, int id, const struct ns4__GetMetersDataResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__GetMetersDataResponse), type))
		return soap->error;
	if (soap_out_PointerToTMetersData(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__GetMetersDataResponse * SOAP_FMAC4 soap_in_ns4__GetMetersDataResponse(struct soap *soap, const char *tag, struct ns4__GetMetersDataResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns4__GetMetersDataResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__GetMetersDataResponse, sizeof(struct ns4__GetMetersDataResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__GetMetersDataResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToTMetersData(soap, "return", &a->return_, "ns3:TMeterData"))
				{	soap_flag_return_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns4__GetMetersDataResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__GetMetersDataResponse, SOAP_TYPE_ns4__GetMetersDataResponse, sizeof(struct ns4__GetMetersDataResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns4__GetMetersDataResponse * SOAP_FMAC2 soap_instantiate_ns4__GetMetersDataResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__GetMetersDataResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns4__GetMetersDataResponse *p;
	size_t k = sizeof(struct ns4__GetMetersDataResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns4__GetMetersDataResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns4__GetMetersDataResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns4__GetMetersDataResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns4__GetMetersDataResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__GetMetersDataResponse(struct soap *soap, const struct ns4__GetMetersDataResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns4__GetMetersDataResponse(soap, tag ? tag : "ns4:GetMetersDataResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__GetMetersDataResponse * SOAP_FMAC4 soap_get_ns4__GetMetersDataResponse(struct soap *soap, struct ns4__GetMetersDataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__GetMetersDataResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__SetMetersData(struct soap *soap, struct ns4__SetMetersData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->Bench);
	a->MetersData = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__SetMetersData(struct soap *soap, const struct ns4__SetMetersData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Bench, SOAP_TYPE_int);
	soap_serialize_PointerToTMetersData(soap, &a->MetersData);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__SetMetersData(struct soap *soap, const char *tag, int id, const struct ns4__SetMetersData *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__SetMetersData), type))
		return soap->error;
	if (soap_out_int(soap, "Bench", -1, &a->Bench, ""))
		return soap->error;
	if (soap_out_PointerToTMetersData(soap, "MetersData", -1, &a->MetersData, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__SetMetersData * SOAP_FMAC4 soap_in_ns4__SetMetersData(struct soap *soap, const char *tag, struct ns4__SetMetersData *a, const char *type)
{
	size_t soap_flag_Bench = 1;
	size_t soap_flag_MetersData = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns4__SetMetersData*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__SetMetersData, sizeof(struct ns4__SetMetersData), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__SetMetersData(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Bench && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "Bench", &a->Bench, "xsd:int"))
				{	soap_flag_Bench--;
					continue;
				}
			}
			if (soap_flag_MetersData && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToTMetersData(soap, "MetersData", &a->MetersData, "ns3:TMeterData"))
				{	soap_flag_MetersData--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Bench > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns4__SetMetersData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__SetMetersData, SOAP_TYPE_ns4__SetMetersData, sizeof(struct ns4__SetMetersData), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns4__SetMetersData * SOAP_FMAC2 soap_instantiate_ns4__SetMetersData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__SetMetersData(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns4__SetMetersData *p;
	size_t k = sizeof(struct ns4__SetMetersData);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns4__SetMetersData, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns4__SetMetersData);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns4__SetMetersData, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns4__SetMetersData location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__SetMetersData(struct soap *soap, const struct ns4__SetMetersData *a, const char *tag, const char *type)
{
	if (soap_out_ns4__SetMetersData(soap, tag ? tag : "ns4:SetMetersData", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__SetMetersData * SOAP_FMAC4 soap_get_ns4__SetMetersData(struct soap *soap, struct ns4__SetMetersData *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__SetMetersData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__SetMetersDataResponse(struct soap *soap, struct ns4__SetMetersDataResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns3__TResult(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__SetMetersDataResponse(struct soap *soap, const struct ns4__SetMetersDataResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__SetMetersDataResponse(struct soap *soap, const char *tag, int id, const struct ns4__SetMetersDataResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__SetMetersDataResponse), type))
		return soap->error;
	if (soap_out_ns3__TResult(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__SetMetersDataResponse * SOAP_FMAC4 soap_in_ns4__SetMetersDataResponse(struct soap *soap, const char *tag, struct ns4__SetMetersDataResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns4__SetMetersDataResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__SetMetersDataResponse, sizeof(struct ns4__SetMetersDataResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__SetMetersDataResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_ns3__TResult(soap, "return", &a->return_, "ns3:TResult"))
				{	soap_flag_return_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_ > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns4__SetMetersDataResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__SetMetersDataResponse, SOAP_TYPE_ns4__SetMetersDataResponse, sizeof(struct ns4__SetMetersDataResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns4__SetMetersDataResponse * SOAP_FMAC2 soap_instantiate_ns4__SetMetersDataResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__SetMetersDataResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns4__SetMetersDataResponse *p;
	size_t k = sizeof(struct ns4__SetMetersDataResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns4__SetMetersDataResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns4__SetMetersDataResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns4__SetMetersDataResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns4__SetMetersDataResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__SetMetersDataResponse(struct soap *soap, const struct ns4__SetMetersDataResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns4__SetMetersDataResponse(soap, tag ? tag : "ns4:SetMetersDataResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__SetMetersDataResponse * SOAP_FMAC4 soap_get_ns4__SetMetersDataResponse(struct soap *soap, struct ns4__SetMetersDataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__SetMetersDataResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__GetStatus(struct soap *soap, struct ns4__GetStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->Bench);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__GetStatus(struct soap *soap, const struct ns4__GetStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Bench, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__GetStatus(struct soap *soap, const char *tag, int id, const struct ns4__GetStatus *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__GetStatus), type))
		return soap->error;
	if (soap_out_int(soap, "Bench", -1, &a->Bench, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__GetStatus * SOAP_FMAC4 soap_in_ns4__GetStatus(struct soap *soap, const char *tag, struct ns4__GetStatus *a, const char *type)
{
	size_t soap_flag_Bench = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns4__GetStatus*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__GetStatus, sizeof(struct ns4__GetStatus), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__GetStatus(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Bench && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "Bench", &a->Bench, "xsd:int"))
				{	soap_flag_Bench--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Bench > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns4__GetStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__GetStatus, SOAP_TYPE_ns4__GetStatus, sizeof(struct ns4__GetStatus), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns4__GetStatus * SOAP_FMAC2 soap_instantiate_ns4__GetStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__GetStatus(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns4__GetStatus *p;
	size_t k = sizeof(struct ns4__GetStatus);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns4__GetStatus, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns4__GetStatus);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns4__GetStatus, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns4__GetStatus location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__GetStatus(struct soap *soap, const struct ns4__GetStatus *a, const char *tag, const char *type)
{
	if (soap_out_ns4__GetStatus(soap, tag ? tag : "ns4:GetStatus", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__GetStatus * SOAP_FMAC4 soap_get_ns4__GetStatus(struct soap *soap, struct ns4__GetStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__GetStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__GetStatusResponse(struct soap *soap, struct ns4__GetStatusResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__GetStatusResponse(struct soap *soap, const struct ns4__GetStatusResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons3__TStatus(soap, &a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__GetStatusResponse(struct soap *soap, const char *tag, int id, const struct ns4__GetStatusResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__GetStatusResponse), type))
		return soap->error;
	if (soap_out_PointerTons3__TStatus(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__GetStatusResponse * SOAP_FMAC4 soap_in_ns4__GetStatusResponse(struct soap *soap, const char *tag, struct ns4__GetStatusResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns4__GetStatusResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__GetStatusResponse, sizeof(struct ns4__GetStatusResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__GetStatusResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__TStatus(soap, "return", &a->return_, "ns3:TStatus"))
				{	soap_flag_return_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns4__GetStatusResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__GetStatusResponse, SOAP_TYPE_ns4__GetStatusResponse, sizeof(struct ns4__GetStatusResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns4__GetStatusResponse * SOAP_FMAC2 soap_instantiate_ns4__GetStatusResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__GetStatusResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns4__GetStatusResponse *p;
	size_t k = sizeof(struct ns4__GetStatusResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns4__GetStatusResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns4__GetStatusResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns4__GetStatusResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns4__GetStatusResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__GetStatusResponse(struct soap *soap, const struct ns4__GetStatusResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns4__GetStatusResponse(soap, tag ? tag : "ns4:GetStatusResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__GetStatusResponse * SOAP_FMAC4 soap_get_ns4__GetStatusResponse(struct soap *soap, struct ns4__GetStatusResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__GetStatusResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__Continue(struct soap *soap, struct ns4__Continue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->Bench);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__Continue(struct soap *soap, const struct ns4__Continue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Bench, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__Continue(struct soap *soap, const char *tag, int id, const struct ns4__Continue *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__Continue), type))
		return soap->error;
	if (soap_out_int(soap, "Bench", -1, &a->Bench, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__Continue * SOAP_FMAC4 soap_in_ns4__Continue(struct soap *soap, const char *tag, struct ns4__Continue *a, const char *type)
{
	size_t soap_flag_Bench = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns4__Continue*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__Continue, sizeof(struct ns4__Continue), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__Continue(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Bench && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "Bench", &a->Bench, "xsd:int"))
				{	soap_flag_Bench--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Bench > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns4__Continue *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__Continue, SOAP_TYPE_ns4__Continue, sizeof(struct ns4__Continue), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns4__Continue * SOAP_FMAC2 soap_instantiate_ns4__Continue(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__Continue(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns4__Continue *p;
	size_t k = sizeof(struct ns4__Continue);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns4__Continue, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns4__Continue);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns4__Continue, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns4__Continue location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__Continue(struct soap *soap, const struct ns4__Continue *a, const char *tag, const char *type)
{
	if (soap_out_ns4__Continue(soap, tag ? tag : "ns4:Continue", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__Continue * SOAP_FMAC4 soap_get_ns4__Continue(struct soap *soap, struct ns4__Continue *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__Continue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__ContinueResponse(struct soap *soap, struct ns4__ContinueResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns3__TResult(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__ContinueResponse(struct soap *soap, const struct ns4__ContinueResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__ContinueResponse(struct soap *soap, const char *tag, int id, const struct ns4__ContinueResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__ContinueResponse), type))
		return soap->error;
	if (soap_out_ns3__TResult(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__ContinueResponse * SOAP_FMAC4 soap_in_ns4__ContinueResponse(struct soap *soap, const char *tag, struct ns4__ContinueResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns4__ContinueResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__ContinueResponse, sizeof(struct ns4__ContinueResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__ContinueResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_ns3__TResult(soap, "return", &a->return_, "ns3:TResult"))
				{	soap_flag_return_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_ > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns4__ContinueResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__ContinueResponse, SOAP_TYPE_ns4__ContinueResponse, sizeof(struct ns4__ContinueResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns4__ContinueResponse * SOAP_FMAC2 soap_instantiate_ns4__ContinueResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__ContinueResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns4__ContinueResponse *p;
	size_t k = sizeof(struct ns4__ContinueResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns4__ContinueResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns4__ContinueResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns4__ContinueResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns4__ContinueResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__ContinueResponse(struct soap *soap, const struct ns4__ContinueResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns4__ContinueResponse(soap, tag ? tag : "ns4:ContinueResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__ContinueResponse * SOAP_FMAC4 soap_get_ns4__ContinueResponse(struct soap *soap, struct ns4__ContinueResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__ContinueResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__Stop(struct soap *soap, struct ns4__Stop *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->Bench);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__Stop(struct soap *soap, const struct ns4__Stop *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Bench, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__Stop(struct soap *soap, const char *tag, int id, const struct ns4__Stop *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__Stop), type))
		return soap->error;
	if (soap_out_int(soap, "Bench", -1, &a->Bench, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__Stop * SOAP_FMAC4 soap_in_ns4__Stop(struct soap *soap, const char *tag, struct ns4__Stop *a, const char *type)
{
	size_t soap_flag_Bench = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns4__Stop*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__Stop, sizeof(struct ns4__Stop), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__Stop(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Bench && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "Bench", &a->Bench, "xsd:int"))
				{	soap_flag_Bench--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Bench > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns4__Stop *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__Stop, SOAP_TYPE_ns4__Stop, sizeof(struct ns4__Stop), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns4__Stop * SOAP_FMAC2 soap_instantiate_ns4__Stop(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__Stop(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns4__Stop *p;
	size_t k = sizeof(struct ns4__Stop);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns4__Stop, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns4__Stop);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns4__Stop, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns4__Stop location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__Stop(struct soap *soap, const struct ns4__Stop *a, const char *tag, const char *type)
{
	if (soap_out_ns4__Stop(soap, tag ? tag : "ns4:Stop", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__Stop * SOAP_FMAC4 soap_get_ns4__Stop(struct soap *soap, struct ns4__Stop *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__Stop(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__StopResponse(struct soap *soap, struct ns4__StopResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns3__TResult(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__StopResponse(struct soap *soap, const struct ns4__StopResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__StopResponse(struct soap *soap, const char *tag, int id, const struct ns4__StopResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__StopResponse), type))
		return soap->error;
	if (soap_out_ns3__TResult(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__StopResponse * SOAP_FMAC4 soap_in_ns4__StopResponse(struct soap *soap, const char *tag, struct ns4__StopResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns4__StopResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__StopResponse, sizeof(struct ns4__StopResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__StopResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_ns3__TResult(soap, "return", &a->return_, "ns3:TResult"))
				{	soap_flag_return_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_ > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns4__StopResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__StopResponse, SOAP_TYPE_ns4__StopResponse, sizeof(struct ns4__StopResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns4__StopResponse * SOAP_FMAC2 soap_instantiate_ns4__StopResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__StopResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns4__StopResponse *p;
	size_t k = sizeof(struct ns4__StopResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns4__StopResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns4__StopResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns4__StopResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns4__StopResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__StopResponse(struct soap *soap, const struct ns4__StopResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns4__StopResponse(soap, tag ? tag : "ns4:StopResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__StopResponse * SOAP_FMAC4 soap_get_ns4__StopResponse(struct soap *soap, struct ns4__StopResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__StopResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__Start(struct soap *soap, struct ns4__Start *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->Bench);
	soap_default_std__string(soap, &a->TestName);
	a->WaitEvents = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__Start(struct soap *soap, const struct ns4__Start *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Bench, SOAP_TYPE_int);
	soap_embedded(soap, &a->TestName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->TestName);
	soap_serialize_PointerTons3__TWaitEvents(soap, &a->WaitEvents);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__Start(struct soap *soap, const char *tag, int id, const struct ns4__Start *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__Start), type))
		return soap->error;
	if (soap_out_int(soap, "Bench", -1, &a->Bench, ""))
		return soap->error;
	if (soap_out_std__string(soap, "TestName", -1, &a->TestName, ""))
		return soap->error;
	if (soap_out_PointerTons3__TWaitEvents(soap, "WaitEvents", -1, &a->WaitEvents, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__Start * SOAP_FMAC4 soap_in_ns4__Start(struct soap *soap, const char *tag, struct ns4__Start *a, const char *type)
{
	size_t soap_flag_Bench = 1;
	size_t soap_flag_TestName = 1;
	size_t soap_flag_WaitEvents = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns4__Start*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__Start, sizeof(struct ns4__Start), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns4__Start(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Bench && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "Bench", &a->Bench, "xsd:int"))
				{	soap_flag_Bench--;
					continue;
				}
			}
			if (soap_flag_TestName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "TestName", &a->TestName, "xsd:string"))
				{	soap_flag_TestName--;
					continue;
				}
			}
			if (soap_flag_WaitEvents && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__TWaitEvents(soap, "WaitEvents", &a->WaitEvents, "ns3:TWaitEvents"))
				{	soap_flag_WaitEvents--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Bench > 0 || soap_flag_TestName > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns4__Start *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__Start, SOAP_TYPE_ns4__Start, sizeof(struct ns4__Start), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns4__Start * SOAP_FMAC2 soap_instantiate_ns4__Start(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__Start(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns4__Start *p;
	size_t k = sizeof(struct ns4__Start);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns4__Start, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns4__Start);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns4__Start, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns4__Start location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__Start(struct soap *soap, const struct ns4__Start *a, const char *tag, const char *type)
{
	if (soap_out_ns4__Start(soap, tag ? tag : "ns4:Start", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__Start * SOAP_FMAC4 soap_get_ns4__Start(struct soap *soap, struct ns4__Start *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__Start(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__StartResponse(struct soap *soap, struct ns4__StartResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns3__TResult(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__StartResponse(struct soap *soap, const struct ns4__StartResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__StartResponse(struct soap *soap, const char *tag, int id, const struct ns4__StartResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__StartResponse), type))
		return soap->error;
	if (soap_out_ns3__TResult(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__StartResponse * SOAP_FMAC4 soap_in_ns4__StartResponse(struct soap *soap, const char *tag, struct ns4__StartResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns4__StartResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__StartResponse, sizeof(struct ns4__StartResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__StartResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_ns3__TResult(soap, "return", &a->return_, "ns3:TResult"))
				{	soap_flag_return_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_ > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns4__StartResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__StartResponse, SOAP_TYPE_ns4__StartResponse, sizeof(struct ns4__StartResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns4__StartResponse * SOAP_FMAC2 soap_instantiate_ns4__StartResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__StartResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns4__StartResponse *p;
	size_t k = sizeof(struct ns4__StartResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns4__StartResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns4__StartResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns4__StartResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns4__StartResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__StartResponse(struct soap *soap, const struct ns4__StartResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns4__StartResponse(soap, tag ? tag : "ns4:StartResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__StartResponse * SOAP_FMAC4 soap_get_ns4__StartResponse(struct soap *soap, struct ns4__StartResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__StartResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__SetPressTestParameters(struct soap *soap, struct ns4__SetPressTestParameters *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->Bench);
	soap_default_std__string(soap, &a->TestName);
	a->TestParameters = NULL;
	soap_default_bool(soap, &a->CreateTest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__SetPressTestParameters(struct soap *soap, const struct ns4__SetPressTestParameters *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Bench, SOAP_TYPE_int);
	soap_embedded(soap, &a->TestName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->TestName);
	soap_serialize_PointerTons3__TPressTestParameters(soap, &a->TestParameters);
	soap_embedded(soap, &a->CreateTest, SOAP_TYPE_bool);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__SetPressTestParameters(struct soap *soap, const char *tag, int id, const struct ns4__SetPressTestParameters *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__SetPressTestParameters), type))
		return soap->error;
	if (soap_out_int(soap, "Bench", -1, &a->Bench, ""))
		return soap->error;
	if (soap_out_std__string(soap, "TestName", -1, &a->TestName, ""))
		return soap->error;
	if (soap_out_PointerTons3__TPressTestParameters(soap, "TestParameters", -1, &a->TestParameters, ""))
		return soap->error;
	if (soap_out_bool(soap, "CreateTest", -1, &a->CreateTest, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__SetPressTestParameters * SOAP_FMAC4 soap_in_ns4__SetPressTestParameters(struct soap *soap, const char *tag, struct ns4__SetPressTestParameters *a, const char *type)
{
	size_t soap_flag_Bench = 1;
	size_t soap_flag_TestName = 1;
	size_t soap_flag_TestParameters = 1;
	size_t soap_flag_CreateTest = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns4__SetPressTestParameters*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__SetPressTestParameters, sizeof(struct ns4__SetPressTestParameters), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns4__SetPressTestParameters(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Bench && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "Bench", &a->Bench, "xsd:int"))
				{	soap_flag_Bench--;
					continue;
				}
			}
			if (soap_flag_TestName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "TestName", &a->TestName, "xsd:string"))
				{	soap_flag_TestName--;
					continue;
				}
			}
			if (soap_flag_TestParameters && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__TPressTestParameters(soap, "TestParameters", &a->TestParameters, "ns3:TPressTestParameters"))
				{	soap_flag_TestParameters--;
					continue;
				}
			}
			if (soap_flag_CreateTest && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "CreateTest", &a->CreateTest, "xsd:boolean"))
				{	soap_flag_CreateTest--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Bench > 0 || soap_flag_TestName > 0 || soap_flag_CreateTest > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns4__SetPressTestParameters *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__SetPressTestParameters, SOAP_TYPE_ns4__SetPressTestParameters, sizeof(struct ns4__SetPressTestParameters), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns4__SetPressTestParameters * SOAP_FMAC2 soap_instantiate_ns4__SetPressTestParameters(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__SetPressTestParameters(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns4__SetPressTestParameters *p;
	size_t k = sizeof(struct ns4__SetPressTestParameters);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns4__SetPressTestParameters, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns4__SetPressTestParameters);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns4__SetPressTestParameters, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns4__SetPressTestParameters location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__SetPressTestParameters(struct soap *soap, const struct ns4__SetPressTestParameters *a, const char *tag, const char *type)
{
	if (soap_out_ns4__SetPressTestParameters(soap, tag ? tag : "ns4:SetPressTestParameters", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__SetPressTestParameters * SOAP_FMAC4 soap_get_ns4__SetPressTestParameters(struct soap *soap, struct ns4__SetPressTestParameters *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__SetPressTestParameters(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__SetPressTestParametersResponse(struct soap *soap, struct ns4__SetPressTestParametersResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns3__TResult(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__SetPressTestParametersResponse(struct soap *soap, const struct ns4__SetPressTestParametersResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__SetPressTestParametersResponse(struct soap *soap, const char *tag, int id, const struct ns4__SetPressTestParametersResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__SetPressTestParametersResponse), type))
		return soap->error;
	if (soap_out_ns3__TResult(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__SetPressTestParametersResponse * SOAP_FMAC4 soap_in_ns4__SetPressTestParametersResponse(struct soap *soap, const char *tag, struct ns4__SetPressTestParametersResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns4__SetPressTestParametersResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__SetPressTestParametersResponse, sizeof(struct ns4__SetPressTestParametersResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__SetPressTestParametersResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_ns3__TResult(soap, "return", &a->return_, "ns3:TResult"))
				{	soap_flag_return_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_ > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns4__SetPressTestParametersResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__SetPressTestParametersResponse, SOAP_TYPE_ns4__SetPressTestParametersResponse, sizeof(struct ns4__SetPressTestParametersResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns4__SetPressTestParametersResponse * SOAP_FMAC2 soap_instantiate_ns4__SetPressTestParametersResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__SetPressTestParametersResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns4__SetPressTestParametersResponse *p;
	size_t k = sizeof(struct ns4__SetPressTestParametersResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns4__SetPressTestParametersResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns4__SetPressTestParametersResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns4__SetPressTestParametersResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns4__SetPressTestParametersResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__SetPressTestParametersResponse(struct soap *soap, const struct ns4__SetPressTestParametersResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns4__SetPressTestParametersResponse(soap, tag ? tag : "ns4:SetPressTestParametersResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__SetPressTestParametersResponse * SOAP_FMAC4 soap_get_ns4__SetPressTestParametersResponse(struct soap *soap, struct ns4__SetPressTestParametersResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__SetPressTestParametersResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__GetPressTestParameters(struct soap *soap, struct ns4__GetPressTestParameters *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->Bench);
	soap_default_std__string(soap, &a->TestName);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__GetPressTestParameters(struct soap *soap, const struct ns4__GetPressTestParameters *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Bench, SOAP_TYPE_int);
	soap_embedded(soap, &a->TestName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->TestName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__GetPressTestParameters(struct soap *soap, const char *tag, int id, const struct ns4__GetPressTestParameters *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__GetPressTestParameters), type))
		return soap->error;
	if (soap_out_int(soap, "Bench", -1, &a->Bench, ""))
		return soap->error;
	if (soap_out_std__string(soap, "TestName", -1, &a->TestName, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__GetPressTestParameters * SOAP_FMAC4 soap_in_ns4__GetPressTestParameters(struct soap *soap, const char *tag, struct ns4__GetPressTestParameters *a, const char *type)
{
	size_t soap_flag_Bench = 1;
	size_t soap_flag_TestName = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns4__GetPressTestParameters*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__GetPressTestParameters, sizeof(struct ns4__GetPressTestParameters), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns4__GetPressTestParameters(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Bench && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "Bench", &a->Bench, "xsd:int"))
				{	soap_flag_Bench--;
					continue;
				}
			}
			if (soap_flag_TestName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "TestName", &a->TestName, "xsd:string"))
				{	soap_flag_TestName--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Bench > 0 || soap_flag_TestName > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns4__GetPressTestParameters *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__GetPressTestParameters, SOAP_TYPE_ns4__GetPressTestParameters, sizeof(struct ns4__GetPressTestParameters), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns4__GetPressTestParameters * SOAP_FMAC2 soap_instantiate_ns4__GetPressTestParameters(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__GetPressTestParameters(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns4__GetPressTestParameters *p;
	size_t k = sizeof(struct ns4__GetPressTestParameters);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns4__GetPressTestParameters, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns4__GetPressTestParameters);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns4__GetPressTestParameters, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns4__GetPressTestParameters location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__GetPressTestParameters(struct soap *soap, const struct ns4__GetPressTestParameters *a, const char *tag, const char *type)
{
	if (soap_out_ns4__GetPressTestParameters(soap, tag ? tag : "ns4:GetPressTestParameters", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__GetPressTestParameters * SOAP_FMAC4 soap_get_ns4__GetPressTestParameters(struct soap *soap, struct ns4__GetPressTestParameters *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__GetPressTestParameters(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__GetPressTestParametersResponse(struct soap *soap, struct ns4__GetPressTestParametersResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__GetPressTestParametersResponse(struct soap *soap, const struct ns4__GetPressTestParametersResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons3__TPressTestParameters(soap, &a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__GetPressTestParametersResponse(struct soap *soap, const char *tag, int id, const struct ns4__GetPressTestParametersResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__GetPressTestParametersResponse), type))
		return soap->error;
	if (soap_out_PointerTons3__TPressTestParameters(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__GetPressTestParametersResponse * SOAP_FMAC4 soap_in_ns4__GetPressTestParametersResponse(struct soap *soap, const char *tag, struct ns4__GetPressTestParametersResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns4__GetPressTestParametersResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__GetPressTestParametersResponse, sizeof(struct ns4__GetPressTestParametersResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__GetPressTestParametersResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__TPressTestParameters(soap, "return", &a->return_, "ns3:TPressTestParameters"))
				{	soap_flag_return_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns4__GetPressTestParametersResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__GetPressTestParametersResponse, SOAP_TYPE_ns4__GetPressTestParametersResponse, sizeof(struct ns4__GetPressTestParametersResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns4__GetPressTestParametersResponse * SOAP_FMAC2 soap_instantiate_ns4__GetPressTestParametersResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__GetPressTestParametersResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns4__GetPressTestParametersResponse *p;
	size_t k = sizeof(struct ns4__GetPressTestParametersResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns4__GetPressTestParametersResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns4__GetPressTestParametersResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns4__GetPressTestParametersResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns4__GetPressTestParametersResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__GetPressTestParametersResponse(struct soap *soap, const struct ns4__GetPressTestParametersResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns4__GetPressTestParametersResponse(soap, tag ? tag : "ns4:GetPressTestParametersResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__GetPressTestParametersResponse * SOAP_FMAC4 soap_get_ns4__GetPressTestParametersResponse(struct soap *soap, struct ns4__GetPressTestParametersResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__GetPressTestParametersResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__SetTestParameters(struct soap *soap, struct ns4__SetTestParameters *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->Bench);
	soap_default_std__string(soap, &a->TestName);
	a->TestParameters = NULL;
	soap_default_bool(soap, &a->CreateTest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__SetTestParameters(struct soap *soap, const struct ns4__SetTestParameters *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Bench, SOAP_TYPE_int);
	soap_embedded(soap, &a->TestName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->TestName);
	soap_serialize_PointerTons3__TTestParameters(soap, &a->TestParameters);
	soap_embedded(soap, &a->CreateTest, SOAP_TYPE_bool);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__SetTestParameters(struct soap *soap, const char *tag, int id, const struct ns4__SetTestParameters *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__SetTestParameters), type))
		return soap->error;
	if (soap_out_int(soap, "Bench", -1, &a->Bench, ""))
		return soap->error;
	if (soap_out_std__string(soap, "TestName", -1, &a->TestName, ""))
		return soap->error;
	if (soap_out_PointerTons3__TTestParameters(soap, "TestParameters", -1, &a->TestParameters, ""))
		return soap->error;
	if (soap_out_bool(soap, "CreateTest", -1, &a->CreateTest, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__SetTestParameters * SOAP_FMAC4 soap_in_ns4__SetTestParameters(struct soap *soap, const char *tag, struct ns4__SetTestParameters *a, const char *type)
{
	size_t soap_flag_Bench = 1;
	size_t soap_flag_TestName = 1;
	size_t soap_flag_TestParameters = 1;
	size_t soap_flag_CreateTest = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns4__SetTestParameters*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__SetTestParameters, sizeof(struct ns4__SetTestParameters), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns4__SetTestParameters(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Bench && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "Bench", &a->Bench, "xsd:int"))
				{	soap_flag_Bench--;
					continue;
				}
			}
			if (soap_flag_TestName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "TestName", &a->TestName, "xsd:string"))
				{	soap_flag_TestName--;
					continue;
				}
			}
			if (soap_flag_TestParameters && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__TTestParameters(soap, "TestParameters", &a->TestParameters, "ns3:TTestParameters"))
				{	soap_flag_TestParameters--;
					continue;
				}
			}
			if (soap_flag_CreateTest && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "CreateTest", &a->CreateTest, "xsd:boolean"))
				{	soap_flag_CreateTest--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Bench > 0 || soap_flag_TestName > 0 || soap_flag_CreateTest > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns4__SetTestParameters *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__SetTestParameters, SOAP_TYPE_ns4__SetTestParameters, sizeof(struct ns4__SetTestParameters), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns4__SetTestParameters * SOAP_FMAC2 soap_instantiate_ns4__SetTestParameters(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__SetTestParameters(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns4__SetTestParameters *p;
	size_t k = sizeof(struct ns4__SetTestParameters);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns4__SetTestParameters, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns4__SetTestParameters);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns4__SetTestParameters, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns4__SetTestParameters location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__SetTestParameters(struct soap *soap, const struct ns4__SetTestParameters *a, const char *tag, const char *type)
{
	if (soap_out_ns4__SetTestParameters(soap, tag ? tag : "ns4:SetTestParameters", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__SetTestParameters * SOAP_FMAC4 soap_get_ns4__SetTestParameters(struct soap *soap, struct ns4__SetTestParameters *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__SetTestParameters(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__SetTestParametersResponse(struct soap *soap, struct ns4__SetTestParametersResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns3__TResult(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__SetTestParametersResponse(struct soap *soap, const struct ns4__SetTestParametersResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__SetTestParametersResponse(struct soap *soap, const char *tag, int id, const struct ns4__SetTestParametersResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__SetTestParametersResponse), type))
		return soap->error;
	if (soap_out_ns3__TResult(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__SetTestParametersResponse * SOAP_FMAC4 soap_in_ns4__SetTestParametersResponse(struct soap *soap, const char *tag, struct ns4__SetTestParametersResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns4__SetTestParametersResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__SetTestParametersResponse, sizeof(struct ns4__SetTestParametersResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__SetTestParametersResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_ns3__TResult(soap, "return", &a->return_, "ns3:TResult"))
				{	soap_flag_return_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_ > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns4__SetTestParametersResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__SetTestParametersResponse, SOAP_TYPE_ns4__SetTestParametersResponse, sizeof(struct ns4__SetTestParametersResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns4__SetTestParametersResponse * SOAP_FMAC2 soap_instantiate_ns4__SetTestParametersResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__SetTestParametersResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns4__SetTestParametersResponse *p;
	size_t k = sizeof(struct ns4__SetTestParametersResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns4__SetTestParametersResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns4__SetTestParametersResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns4__SetTestParametersResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns4__SetTestParametersResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__SetTestParametersResponse(struct soap *soap, const struct ns4__SetTestParametersResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns4__SetTestParametersResponse(soap, tag ? tag : "ns4:SetTestParametersResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__SetTestParametersResponse * SOAP_FMAC4 soap_get_ns4__SetTestParametersResponse(struct soap *soap, struct ns4__SetTestParametersResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__SetTestParametersResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__GetTestParameters(struct soap *soap, struct ns4__GetTestParameters *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->Bench);
	soap_default_std__string(soap, &a->TestName);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__GetTestParameters(struct soap *soap, const struct ns4__GetTestParameters *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Bench, SOAP_TYPE_int);
	soap_embedded(soap, &a->TestName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->TestName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__GetTestParameters(struct soap *soap, const char *tag, int id, const struct ns4__GetTestParameters *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__GetTestParameters), type))
		return soap->error;
	if (soap_out_int(soap, "Bench", -1, &a->Bench, ""))
		return soap->error;
	if (soap_out_std__string(soap, "TestName", -1, &a->TestName, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__GetTestParameters * SOAP_FMAC4 soap_in_ns4__GetTestParameters(struct soap *soap, const char *tag, struct ns4__GetTestParameters *a, const char *type)
{
	size_t soap_flag_Bench = 1;
	size_t soap_flag_TestName = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns4__GetTestParameters*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__GetTestParameters, sizeof(struct ns4__GetTestParameters), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns4__GetTestParameters(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Bench && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "Bench", &a->Bench, "xsd:int"))
				{	soap_flag_Bench--;
					continue;
				}
			}
			if (soap_flag_TestName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "TestName", &a->TestName, "xsd:string"))
				{	soap_flag_TestName--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Bench > 0 || soap_flag_TestName > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns4__GetTestParameters *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__GetTestParameters, SOAP_TYPE_ns4__GetTestParameters, sizeof(struct ns4__GetTestParameters), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns4__GetTestParameters * SOAP_FMAC2 soap_instantiate_ns4__GetTestParameters(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__GetTestParameters(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns4__GetTestParameters *p;
	size_t k = sizeof(struct ns4__GetTestParameters);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns4__GetTestParameters, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns4__GetTestParameters);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns4__GetTestParameters, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns4__GetTestParameters location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__GetTestParameters(struct soap *soap, const struct ns4__GetTestParameters *a, const char *tag, const char *type)
{
	if (soap_out_ns4__GetTestParameters(soap, tag ? tag : "ns4:GetTestParameters", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__GetTestParameters * SOAP_FMAC4 soap_get_ns4__GetTestParameters(struct soap *soap, struct ns4__GetTestParameters *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__GetTestParameters(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__GetTestParametersResponse(struct soap *soap, struct ns4__GetTestParametersResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__GetTestParametersResponse(struct soap *soap, const struct ns4__GetTestParametersResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons3__TTestParameters(soap, &a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__GetTestParametersResponse(struct soap *soap, const char *tag, int id, const struct ns4__GetTestParametersResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__GetTestParametersResponse), type))
		return soap->error;
	if (soap_out_PointerTons3__TTestParameters(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__GetTestParametersResponse * SOAP_FMAC4 soap_in_ns4__GetTestParametersResponse(struct soap *soap, const char *tag, struct ns4__GetTestParametersResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns4__GetTestParametersResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__GetTestParametersResponse, sizeof(struct ns4__GetTestParametersResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__GetTestParametersResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__TTestParameters(soap, "return", &a->return_, "ns3:TTestParameters"))
				{	soap_flag_return_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns4__GetTestParametersResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__GetTestParametersResponse, SOAP_TYPE_ns4__GetTestParametersResponse, sizeof(struct ns4__GetTestParametersResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns4__GetTestParametersResponse * SOAP_FMAC2 soap_instantiate_ns4__GetTestParametersResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__GetTestParametersResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns4__GetTestParametersResponse *p;
	size_t k = sizeof(struct ns4__GetTestParametersResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns4__GetTestParametersResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns4__GetTestParametersResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns4__GetTestParametersResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns4__GetTestParametersResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__GetTestParametersResponse(struct soap *soap, const struct ns4__GetTestParametersResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns4__GetTestParametersResponse(soap, tag ? tag : "ns4:GetTestParametersResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__GetTestParametersResponse * SOAP_FMAC4 soap_get_ns4__GetTestParametersResponse(struct soap *soap, struct ns4__GetTestParametersResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__GetTestParametersResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__NewMeasurement(struct soap *soap, struct ns4__NewMeasurement *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->Bench);
	soap_default_std__string(soap, &a->TypeName);
	soap_default_bool(soap, &a->ArchiveData);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__NewMeasurement(struct soap *soap, const struct ns4__NewMeasurement *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Bench, SOAP_TYPE_int);
	soap_embedded(soap, &a->TypeName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->TypeName);
	soap_embedded(soap, &a->ArchiveData, SOAP_TYPE_bool);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__NewMeasurement(struct soap *soap, const char *tag, int id, const struct ns4__NewMeasurement *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__NewMeasurement), type))
		return soap->error;
	if (soap_out_int(soap, "Bench", -1, &a->Bench, ""))
		return soap->error;
	if (soap_out_std__string(soap, "TypeName", -1, &a->TypeName, ""))
		return soap->error;
	if (soap_out_bool(soap, "ArchiveData", -1, &a->ArchiveData, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__NewMeasurement * SOAP_FMAC4 soap_in_ns4__NewMeasurement(struct soap *soap, const char *tag, struct ns4__NewMeasurement *a, const char *type)
{
	size_t soap_flag_Bench = 1;
	size_t soap_flag_TypeName = 1;
	size_t soap_flag_ArchiveData = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns4__NewMeasurement*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__NewMeasurement, sizeof(struct ns4__NewMeasurement), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns4__NewMeasurement(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Bench && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "Bench", &a->Bench, "xsd:int"))
				{	soap_flag_Bench--;
					continue;
				}
			}
			if (soap_flag_TypeName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "TypeName", &a->TypeName, "xsd:string"))
				{	soap_flag_TypeName--;
					continue;
				}
			}
			if (soap_flag_ArchiveData && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "ArchiveData", &a->ArchiveData, "xsd:boolean"))
				{	soap_flag_ArchiveData--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Bench > 0 || soap_flag_TypeName > 0 || soap_flag_ArchiveData > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns4__NewMeasurement *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__NewMeasurement, SOAP_TYPE_ns4__NewMeasurement, sizeof(struct ns4__NewMeasurement), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns4__NewMeasurement * SOAP_FMAC2 soap_instantiate_ns4__NewMeasurement(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__NewMeasurement(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns4__NewMeasurement *p;
	size_t k = sizeof(struct ns4__NewMeasurement);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns4__NewMeasurement, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns4__NewMeasurement);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns4__NewMeasurement, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns4__NewMeasurement location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__NewMeasurement(struct soap *soap, const struct ns4__NewMeasurement *a, const char *tag, const char *type)
{
	if (soap_out_ns4__NewMeasurement(soap, tag ? tag : "ns4:NewMeasurement", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__NewMeasurement * SOAP_FMAC4 soap_get_ns4__NewMeasurement(struct soap *soap, struct ns4__NewMeasurement *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__NewMeasurement(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__NewMeasurementResponse(struct soap *soap, struct ns4__NewMeasurementResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns3__TResult(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__NewMeasurementResponse(struct soap *soap, const struct ns4__NewMeasurementResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__NewMeasurementResponse(struct soap *soap, const char *tag, int id, const struct ns4__NewMeasurementResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__NewMeasurementResponse), type))
		return soap->error;
	if (soap_out_ns3__TResult(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__NewMeasurementResponse * SOAP_FMAC4 soap_in_ns4__NewMeasurementResponse(struct soap *soap, const char *tag, struct ns4__NewMeasurementResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns4__NewMeasurementResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__NewMeasurementResponse, sizeof(struct ns4__NewMeasurementResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__NewMeasurementResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_ns3__TResult(soap, "return", &a->return_, "ns3:TResult"))
				{	soap_flag_return_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_ > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns4__NewMeasurementResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__NewMeasurementResponse, SOAP_TYPE_ns4__NewMeasurementResponse, sizeof(struct ns4__NewMeasurementResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns4__NewMeasurementResponse * SOAP_FMAC2 soap_instantiate_ns4__NewMeasurementResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__NewMeasurementResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns4__NewMeasurementResponse *p;
	size_t k = sizeof(struct ns4__NewMeasurementResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns4__NewMeasurementResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns4__NewMeasurementResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns4__NewMeasurementResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns4__NewMeasurementResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__NewMeasurementResponse(struct soap *soap, const struct ns4__NewMeasurementResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns4__NewMeasurementResponse(soap, tag ? tag : "ns4:NewMeasurementResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__NewMeasurementResponse * SOAP_FMAC4 soap_get_ns4__NewMeasurementResponse(struct soap *soap, struct ns4__NewMeasurementResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__NewMeasurementResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__GetTypeList(struct soap *soap, struct ns4__GetTypeList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__GetTypeList(struct soap *soap, const struct ns4__GetTypeList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__GetTypeList(struct soap *soap, const char *tag, int id, const struct ns4__GetTypeList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__GetTypeList), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__GetTypeList * SOAP_FMAC4 soap_in_ns4__GetTypeList(struct soap *soap, const char *tag, struct ns4__GetTypeList *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns4__GetTypeList*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__GetTypeList, sizeof(struct ns4__GetTypeList), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__GetTypeList(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns4__GetTypeList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__GetTypeList, SOAP_TYPE_ns4__GetTypeList, sizeof(struct ns4__GetTypeList), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns4__GetTypeList * SOAP_FMAC2 soap_instantiate_ns4__GetTypeList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__GetTypeList(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns4__GetTypeList *p;
	size_t k = sizeof(struct ns4__GetTypeList);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns4__GetTypeList, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns4__GetTypeList);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns4__GetTypeList, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns4__GetTypeList location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__GetTypeList(struct soap *soap, const struct ns4__GetTypeList *a, const char *tag, const char *type)
{
	if (soap_out_ns4__GetTypeList(soap, tag ? tag : "ns4:GetTypeList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__GetTypeList * SOAP_FMAC4 soap_get_ns4__GetTypeList(struct soap *soap, struct ns4__GetTypeList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__GetTypeList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__GetTypeListResponse(struct soap *soap, struct ns4__GetTypeListResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__GetTypeListResponse(struct soap *soap, const struct ns4__GetTypeListResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToTStringDynArray(soap, &a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__GetTypeListResponse(struct soap *soap, const char *tag, int id, const struct ns4__GetTypeListResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__GetTypeListResponse), type))
		return soap->error;
	if (soap_out_PointerToTStringDynArray(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__GetTypeListResponse * SOAP_FMAC4 soap_in_ns4__GetTypeListResponse(struct soap *soap, const char *tag, struct ns4__GetTypeListResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns4__GetTypeListResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__GetTypeListResponse, sizeof(struct ns4__GetTypeListResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__GetTypeListResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToTStringDynArray(soap, "return", &a->return_, "xsd:string"))
				{	soap_flag_return_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns4__GetTypeListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__GetTypeListResponse, SOAP_TYPE_ns4__GetTypeListResponse, sizeof(struct ns4__GetTypeListResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns4__GetTypeListResponse * SOAP_FMAC2 soap_instantiate_ns4__GetTypeListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__GetTypeListResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns4__GetTypeListResponse *p;
	size_t k = sizeof(struct ns4__GetTypeListResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns4__GetTypeListResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns4__GetTypeListResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns4__GetTypeListResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns4__GetTypeListResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__GetTypeListResponse(struct soap *soap, const struct ns4__GetTypeListResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns4__GetTypeListResponse(soap, tag ? tag : "ns4:GetTypeListResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__GetTypeListResponse * SOAP_FMAC4 soap_get_ns4__GetTypeListResponse(struct soap *soap, struct ns4__GetTypeListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__GetTypeListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag ? tag : "SOAP-ENV:Reason", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag ? tag : "SOAP-ENV:Detail", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code, &mark);
	if (id < 0)
		return soap->error;
	(void)soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag ? tag : "SOAP-ENV:Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__TPressTestResult(struct soap *soap, ns3__TPressTestResult *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__TPressTestResult))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__TPressTestResult(struct soap *soap, const char *tag, int id, ns3__TPressTestResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__TPressTestResult, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns3__TPressTestResult ? type : NULL);
}

SOAP_FMAC3 ns3__TPressTestResult ** SOAP_FMAC4 soap_in_PointerTons3__TPressTestResult(struct soap *soap, const char *tag, ns3__TPressTestResult **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__TPressTestResult **)soap_malloc(soap, sizeof(ns3__TPressTestResult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__TPressTestResult *)soap_instantiate_ns3__TPressTestResult(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns3__TPressTestResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__TPressTestResult, sizeof(ns3__TPressTestResult), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__TPressTestResult(struct soap *soap, ns3__TPressTestResult *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__TPressTestResult(soap, tag ? tag : "ns3:TPressTestResult", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__TPressTestResult ** SOAP_FMAC4 soap_get_PointerTons3__TPressTestResult(struct soap *soap, ns3__TPressTestResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__TPressTestResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__TTestResult(struct soap *soap, ns3__TTestResult *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__TTestResult))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__TTestResult(struct soap *soap, const char *tag, int id, ns3__TTestResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__TTestResult, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns3__TTestResult ? type : NULL);
}

SOAP_FMAC3 ns3__TTestResult ** SOAP_FMAC4 soap_in_PointerTons3__TTestResult(struct soap *soap, const char *tag, ns3__TTestResult **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__TTestResult **)soap_malloc(soap, sizeof(ns3__TTestResult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__TTestResult *)soap_instantiate_ns3__TTestResult(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns3__TTestResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__TTestResult, sizeof(ns3__TTestResult), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__TTestResult(struct soap *soap, ns3__TTestResult *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__TTestResult(soap, tag ? tag : "ns3:TTestResult", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__TTestResult ** SOAP_FMAC4 soap_get_PointerTons3__TTestResult(struct soap *soap, ns3__TTestResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__TTestResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__TTestResults(struct soap *soap, ns3__TTestResults *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__TTestResults))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__TTestResults(struct soap *soap, const char *tag, int id, ns3__TTestResults *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__TTestResults, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns3__TTestResults ? type : NULL);
}

SOAP_FMAC3 ns3__TTestResults ** SOAP_FMAC4 soap_in_PointerTons3__TTestResults(struct soap *soap, const char *tag, ns3__TTestResults **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__TTestResults **)soap_malloc(soap, sizeof(ns3__TTestResults *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__TTestResults *)soap_instantiate_ns3__TTestResults(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns3__TTestResults **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__TTestResults, sizeof(ns3__TTestResults), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__TTestResults(struct soap *soap, ns3__TTestResults *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__TTestResults(soap, tag ? tag : "ns3:TTestResults", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__TTestResults ** SOAP_FMAC4 soap_get_PointerTons3__TTestResults(struct soap *soap, ns3__TTestResults **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__TTestResults(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__TMeasurementData(struct soap *soap, ns3__TMeasurementData *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__TMeasurementData))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__TMeasurementData(struct soap *soap, const char *tag, int id, ns3__TMeasurementData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__TMeasurementData, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns3__TMeasurementData ? type : NULL);
}

SOAP_FMAC3 ns3__TMeasurementData ** SOAP_FMAC4 soap_in_PointerTons3__TMeasurementData(struct soap *soap, const char *tag, ns3__TMeasurementData **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__TMeasurementData **)soap_malloc(soap, sizeof(ns3__TMeasurementData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__TMeasurementData *)soap_instantiate_ns3__TMeasurementData(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns3__TMeasurementData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__TMeasurementData, sizeof(ns3__TMeasurementData), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__TMeasurementData(struct soap *soap, ns3__TMeasurementData *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__TMeasurementData(soap, tag ? tag : "ns3:TMeasurementData", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__TMeasurementData ** SOAP_FMAC4 soap_get_PointerTons3__TMeasurementData(struct soap *soap, ns3__TMeasurementData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__TMeasurementData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToTBooleanDynArray(struct soap *soap, TBooleanDynArray *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (*a)
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToTBooleanDynArray(struct soap *soap, const char *tag, int id, TBooleanDynArray *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, *a ? (*a)->__ptr : NULL, *a ? (*a)->__size : 0, type, SOAP_TYPE_TBooleanDynArray, NULL);
	if (!*a || id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_TBooleanDynArray ? type : NULL);
}

SOAP_FMAC3 TBooleanDynArray ** SOAP_FMAC4 soap_in_PointerToTBooleanDynArray(struct soap *soap, const char *tag, TBooleanDynArray **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (TBooleanDynArray **)soap_malloc(soap, sizeof(TBooleanDynArray *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (TBooleanDynArray *)soap_instantiate_TBooleanDynArray(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (TBooleanDynArray **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TBooleanDynArray, sizeof(TBooleanDynArray), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToTBooleanDynArray(struct soap *soap, TBooleanDynArray *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToTBooleanDynArray(soap, tag ? tag : "SOAP-ENC:Array", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 TBooleanDynArray ** SOAP_FMAC4 soap_get_PointerToTBooleanDynArray(struct soap *soap, TBooleanDynArray **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToTBooleanDynArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToTMeterIndications(struct soap *soap, TMeterIndications *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (*a)
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToTMeterIndications(struct soap *soap, const char *tag, int id, TMeterIndications *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, *a ? (*a)->__ptr : NULL, *a ? (*a)->__size : 0, type, SOAP_TYPE_TMeterIndications, NULL);
	if (!*a || id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_TMeterIndications ? type : NULL);
}

SOAP_FMAC3 TMeterIndications ** SOAP_FMAC4 soap_in_PointerToTMeterIndications(struct soap *soap, const char *tag, TMeterIndications **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (TMeterIndications **)soap_malloc(soap, sizeof(TMeterIndications *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (TMeterIndications *)soap_instantiate_TMeterIndications(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (TMeterIndications **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TMeterIndications, sizeof(TMeterIndications), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToTMeterIndications(struct soap *soap, TMeterIndications *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToTMeterIndications(soap, tag ? tag : "SOAP-ENC:Array", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 TMeterIndications ** SOAP_FMAC4 soap_get_PointerToTMeterIndications(struct soap *soap, TMeterIndications **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToTMeterIndications(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToTIntegerDynArray(struct soap *soap, TIntegerDynArray *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (*a)
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToTIntegerDynArray(struct soap *soap, const char *tag, int id, TIntegerDynArray *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, *a ? (*a)->__ptr : NULL, *a ? (*a)->__size : 0, type, SOAP_TYPE_TIntegerDynArray, NULL);
	if (!*a || id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_TIntegerDynArray ? type : NULL);
}

SOAP_FMAC3 TIntegerDynArray ** SOAP_FMAC4 soap_in_PointerToTIntegerDynArray(struct soap *soap, const char *tag, TIntegerDynArray **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (TIntegerDynArray **)soap_malloc(soap, sizeof(TIntegerDynArray *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (TIntegerDynArray *)soap_instantiate_TIntegerDynArray(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (TIntegerDynArray **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TIntegerDynArray, sizeof(TIntegerDynArray), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToTIntegerDynArray(struct soap *soap, TIntegerDynArray *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToTIntegerDynArray(soap, tag ? tag : "SOAP-ENC:Array", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 TIntegerDynArray ** SOAP_FMAC4 soap_get_PointerToTIntegerDynArray(struct soap *soap, TIntegerDynArray **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToTIntegerDynArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToTMetersData(struct soap *soap, TMetersData *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (*a)
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToTMetersData(struct soap *soap, const char *tag, int id, TMetersData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, *a ? (*a)->__ptr : NULL, *a ? (*a)->__size : 0, type, SOAP_TYPE_TMetersData, NULL);
	if (!*a || id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_TMetersData ? type : NULL);
}

SOAP_FMAC3 TMetersData ** SOAP_FMAC4 soap_in_PointerToTMetersData(struct soap *soap, const char *tag, TMetersData **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (TMetersData **)soap_malloc(soap, sizeof(TMetersData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (TMetersData *)soap_instantiate_TMetersData(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (TMetersData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TMetersData, sizeof(TMetersData), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToTMetersData(struct soap *soap, TMetersData *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToTMetersData(soap, tag ? tag : "SOAP-ENC:Array", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 TMetersData ** SOAP_FMAC4 soap_get_PointerToTMetersData(struct soap *soap, TMetersData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToTMetersData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__TStatus(struct soap *soap, ns3__TStatus *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__TStatus))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__TStatus(struct soap *soap, const char *tag, int id, ns3__TStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__TStatus, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns3__TStatus ? type : NULL);
}

SOAP_FMAC3 ns3__TStatus ** SOAP_FMAC4 soap_in_PointerTons3__TStatus(struct soap *soap, const char *tag, ns3__TStatus **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__TStatus **)soap_malloc(soap, sizeof(ns3__TStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__TStatus *)soap_instantiate_ns3__TStatus(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns3__TStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__TStatus, sizeof(ns3__TStatus), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__TStatus(struct soap *soap, ns3__TStatus *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__TStatus(soap, tag ? tag : "ns3:TStatus", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__TStatus ** SOAP_FMAC4 soap_get_PointerTons3__TStatus(struct soap *soap, ns3__TStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__TStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__TWaitEvents(struct soap *soap, ns3__TWaitEvents *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__TWaitEvents))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__TWaitEvents(struct soap *soap, const char *tag, int id, ns3__TWaitEvents *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__TWaitEvents, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns3__TWaitEvents ? type : NULL);
}

SOAP_FMAC3 ns3__TWaitEvents ** SOAP_FMAC4 soap_in_PointerTons3__TWaitEvents(struct soap *soap, const char *tag, ns3__TWaitEvents **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__TWaitEvents **)soap_malloc(soap, sizeof(ns3__TWaitEvents *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__TWaitEvents *)soap_instantiate_ns3__TWaitEvents(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns3__TWaitEvents **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__TWaitEvents, sizeof(ns3__TWaitEvents), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__TWaitEvents(struct soap *soap, ns3__TWaitEvents *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__TWaitEvents(soap, tag ? tag : "ns3:TWaitEvents", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__TWaitEvents ** SOAP_FMAC4 soap_get_PointerTons3__TWaitEvents(struct soap *soap, ns3__TWaitEvents **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__TWaitEvents(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__TPressTestParameters(struct soap *soap, ns3__TPressTestParameters *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__TPressTestParameters))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__TPressTestParameters(struct soap *soap, const char *tag, int id, ns3__TPressTestParameters *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__TPressTestParameters, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns3__TPressTestParameters ? type : NULL);
}

SOAP_FMAC3 ns3__TPressTestParameters ** SOAP_FMAC4 soap_in_PointerTons3__TPressTestParameters(struct soap *soap, const char *tag, ns3__TPressTestParameters **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__TPressTestParameters **)soap_malloc(soap, sizeof(ns3__TPressTestParameters *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__TPressTestParameters *)soap_instantiate_ns3__TPressTestParameters(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns3__TPressTestParameters **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__TPressTestParameters, sizeof(ns3__TPressTestParameters), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__TPressTestParameters(struct soap *soap, ns3__TPressTestParameters *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__TPressTestParameters(soap, tag ? tag : "ns3:TPressTestParameters", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__TPressTestParameters ** SOAP_FMAC4 soap_get_PointerTons3__TPressTestParameters(struct soap *soap, ns3__TPressTestParameters **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__TPressTestParameters(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__TTestParameters(struct soap *soap, ns3__TTestParameters *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__TTestParameters))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__TTestParameters(struct soap *soap, const char *tag, int id, ns3__TTestParameters *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__TTestParameters, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns3__TTestParameters ? type : NULL);
}

SOAP_FMAC3 ns3__TTestParameters ** SOAP_FMAC4 soap_in_PointerTons3__TTestParameters(struct soap *soap, const char *tag, ns3__TTestParameters **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__TTestParameters **)soap_malloc(soap, sizeof(ns3__TTestParameters *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__TTestParameters *)soap_instantiate_ns3__TTestParameters(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns3__TTestParameters **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__TTestParameters, sizeof(ns3__TTestParameters), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__TTestParameters(struct soap *soap, ns3__TTestParameters *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__TTestParameters(soap, tag ? tag : "ns3:TTestParameters", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__TTestParameters ** SOAP_FMAC4 soap_get_PointerTons3__TTestParameters(struct soap *soap, ns3__TTestParameters **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__TTestParameters(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons3__TMeterResult(struct soap *soap, ns3__TMeterResult **const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons3__TMeterResult))
		soap_serialize_PointerTons3__TMeterResult(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons3__TMeterResult(struct soap *soap, const char *tag, int id, ns3__TMeterResult **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons3__TMeterResult, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons3__TMeterResult(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns3__TMeterResult *** SOAP_FMAC4 soap_in_PointerToPointerTons3__TMeterResult(struct soap *soap, const char *tag, ns3__TMeterResult ***a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__TMeterResult ***)soap_malloc(soap, sizeof(ns3__TMeterResult **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons3__TMeterResult(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns3__TMeterResult ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__TMeterResult, sizeof(ns3__TMeterResult), 1, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons3__TMeterResult(struct soap *soap, ns3__TMeterResult **const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToPointerTons3__TMeterResult(soap, tag ? tag : "ns3:TMeterResult", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__TMeterResult *** SOAP_FMAC4 soap_get_PointerToPointerTons3__TMeterResult(struct soap *soap, ns3__TMeterResult ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons3__TMeterResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__TMeterResult(struct soap *soap, ns3__TMeterResult *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__TMeterResult))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__TMeterResult(struct soap *soap, const char *tag, int id, ns3__TMeterResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__TMeterResult, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns3__TMeterResult ? type : NULL);
}

SOAP_FMAC3 ns3__TMeterResult ** SOAP_FMAC4 soap_in_PointerTons3__TMeterResult(struct soap *soap, const char *tag, ns3__TMeterResult **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__TMeterResult **)soap_malloc(soap, sizeof(ns3__TMeterResult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__TMeterResult *)soap_instantiate_ns3__TMeterResult(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns3__TMeterResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__TMeterResult, sizeof(ns3__TMeterResult), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__TMeterResult(struct soap *soap, ns3__TMeterResult *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__TMeterResult(soap, tag ? tag : "ns3:TMeterResult", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__TMeterResult ** SOAP_FMAC4 soap_get_PointerTons3__TMeterResult(struct soap *soap, ns3__TMeterResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__TMeterResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons3__TMeterIndication(struct soap *soap, ns3__TMeterIndication **const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons3__TMeterIndication))
		soap_serialize_PointerTons3__TMeterIndication(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons3__TMeterIndication(struct soap *soap, const char *tag, int id, ns3__TMeterIndication **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons3__TMeterIndication, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons3__TMeterIndication(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns3__TMeterIndication *** SOAP_FMAC4 soap_in_PointerToPointerTons3__TMeterIndication(struct soap *soap, const char *tag, ns3__TMeterIndication ***a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__TMeterIndication ***)soap_malloc(soap, sizeof(ns3__TMeterIndication **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons3__TMeterIndication(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns3__TMeterIndication ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__TMeterIndication, sizeof(ns3__TMeterIndication), 1, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons3__TMeterIndication(struct soap *soap, ns3__TMeterIndication **const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToPointerTons3__TMeterIndication(soap, tag ? tag : "ns3:TMeterIndication", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__TMeterIndication *** SOAP_FMAC4 soap_get_PointerToPointerTons3__TMeterIndication(struct soap *soap, ns3__TMeterIndication ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons3__TMeterIndication(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__TMeterIndication(struct soap *soap, ns3__TMeterIndication *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__TMeterIndication))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__TMeterIndication(struct soap *soap, const char *tag, int id, ns3__TMeterIndication *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__TMeterIndication, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns3__TMeterIndication ? type : NULL);
}

SOAP_FMAC3 ns3__TMeterIndication ** SOAP_FMAC4 soap_in_PointerTons3__TMeterIndication(struct soap *soap, const char *tag, ns3__TMeterIndication **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__TMeterIndication **)soap_malloc(soap, sizeof(ns3__TMeterIndication *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__TMeterIndication *)soap_instantiate_ns3__TMeterIndication(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns3__TMeterIndication **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__TMeterIndication, sizeof(ns3__TMeterIndication), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__TMeterIndication(struct soap *soap, ns3__TMeterIndication *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__TMeterIndication(soap, tag ? tag : "ns3:TMeterIndication", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__TMeterIndication ** SOAP_FMAC4 soap_get_PointerTons3__TMeterIndication(struct soap *soap, ns3__TMeterIndication **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__TMeterIndication(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons3__TMeterData(struct soap *soap, ns3__TMeterData **const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons3__TMeterData))
		soap_serialize_PointerTons3__TMeterData(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons3__TMeterData(struct soap *soap, const char *tag, int id, ns3__TMeterData **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons3__TMeterData, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons3__TMeterData(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns3__TMeterData *** SOAP_FMAC4 soap_in_PointerToPointerTons3__TMeterData(struct soap *soap, const char *tag, ns3__TMeterData ***a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__TMeterData ***)soap_malloc(soap, sizeof(ns3__TMeterData **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons3__TMeterData(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns3__TMeterData ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__TMeterData, sizeof(ns3__TMeterData), 1, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons3__TMeterData(struct soap *soap, ns3__TMeterData **const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToPointerTons3__TMeterData(soap, tag ? tag : "ns3:TMeterData", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__TMeterData *** SOAP_FMAC4 soap_get_PointerToPointerTons3__TMeterData(struct soap *soap, ns3__TMeterData ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons3__TMeterData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__TMeterData(struct soap *soap, ns3__TMeterData *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__TMeterData))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__TMeterData(struct soap *soap, const char *tag, int id, ns3__TMeterData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__TMeterData, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns3__TMeterData ? type : NULL);
}

SOAP_FMAC3 ns3__TMeterData ** SOAP_FMAC4 soap_in_PointerTons3__TMeterData(struct soap *soap, const char *tag, ns3__TMeterData **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__TMeterData **)soap_malloc(soap, sizeof(ns3__TMeterData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__TMeterData *)soap_instantiate_ns3__TMeterData(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns3__TMeterData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__TMeterData, sizeof(ns3__TMeterData), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__TMeterData(struct soap *soap, ns3__TMeterData *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__TMeterData(soap, tag ? tag : "ns3:TMeterData", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__TMeterData ** SOAP_FMAC4 soap_get_PointerTons3__TMeterData(struct soap *soap, ns3__TMeterData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__TMeterData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobool(struct soap *soap, bool *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_bool);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobool(struct soap *soap, const char *tag, int id, bool *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bool, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_bool(soap, tag, id, *a, type);
}

SOAP_FMAC3 bool ** SOAP_FMAC4 soap_in_PointerTobool(struct soap *soap, const char *tag, bool **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (bool **)soap_malloc(soap, sizeof(bool *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bool(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (bool **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bool, sizeof(bool), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobool(struct soap *soap, bool *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTobool(soap, tag ? tag : "boolean", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 bool ** SOAP_FMAC4 soap_get_PointerTobool(struct soap *soap, bool **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToint(struct soap *soap, int *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToint(struct soap *soap, const char *tag, int id, int *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_int, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_int(soap, tag, id, *a, type);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_in_PointerToint(struct soap *soap, const char *tag, int **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (int **)soap_malloc(soap, sizeof(int *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_int(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (int **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_int, sizeof(int), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToint(struct soap *soap, int *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToint(soap, tag ? tag : "int", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_get_PointerToint(struct soap *soap, int **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__string(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_std__string))
		soap_serialize_std__string(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__string(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_std__string, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_std__string(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTostd__string(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_std__string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_std__string, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__string(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTostd__string(soap, tag ? tag : "string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTostd__string(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToTMeterResults(struct soap *soap, TMeterResults *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (*a)
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToTMeterResults(struct soap *soap, const char *tag, int id, TMeterResults *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, *a ? (*a)->__ptr : NULL, *a ? (*a)->__size : 0, type, SOAP_TYPE_TMeterResults, NULL);
	if (!*a || id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_TMeterResults ? type : NULL);
}

SOAP_FMAC3 TMeterResults ** SOAP_FMAC4 soap_in_PointerToTMeterResults(struct soap *soap, const char *tag, TMeterResults **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (TMeterResults **)soap_malloc(soap, sizeof(TMeterResults *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (TMeterResults *)soap_instantiate_TMeterResults(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (TMeterResults **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TMeterResults, sizeof(TMeterResults), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToTMeterResults(struct soap *soap, TMeterResults *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToTMeterResults(soap, tag ? tag : "SOAP-ENC:Array", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 TMeterResults ** SOAP_FMAC4 soap_get_PointerToTMeterResults(struct soap *soap, TMeterResults **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToTMeterResults(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToTStringDynArray(struct soap *soap, TStringDynArray *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (*a)
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToTStringDynArray(struct soap *soap, const char *tag, int id, TStringDynArray *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, *a ? (*a)->__ptr : NULL, *a ? (*a)->__size : 0, type, SOAP_TYPE_TStringDynArray, NULL);
	if (!*a || id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_TStringDynArray ? type : NULL);
}

SOAP_FMAC3 TStringDynArray ** SOAP_FMAC4 soap_in_PointerToTStringDynArray(struct soap *soap, const char *tag, TStringDynArray **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (TStringDynArray **)soap_malloc(soap, sizeof(TStringDynArray *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (TStringDynArray *)soap_instantiate_TStringDynArray(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (TStringDynArray **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TStringDynArray, sizeof(TStringDynArray), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToTStringDynArray(struct soap *soap, TStringDynArray *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToTStringDynArray(soap, tag ? tag : "SOAP-ENC:Array", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 TStringDynArray ** SOAP_FMAC4 soap_get_PointerToTStringDynArray(struct soap *soap, TStringDynArray **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToTStringDynArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE__QName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__QName(soap, tag ? tag : "QName", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_string);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_new_string(struct soap *soap, int n)
{
	char * *a = static_cast<char * *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(char *)));
	for (char * *p = a; p && n--; ++p)
		soap_default_string(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_string(soap, tag ? tag : "string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.cpp */
