/* soapStub.h
   Generated by gSOAP 2.8.111 for .\testbench.h

gSOAP XML Web services tools
Copyright (C) 2000-2021, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#include <vector>
#define SOAP_NAMESPACE_OF_ns2	"http://www.borland.com/namespaces/Types"
#define SOAP_NAMESPACE_OF_ns3	"urn:JusWTBServiceIntf"

#ifndef soapStub_H
#define soapStub_H
#include "stdsoap2.h"
#if GSOAP_VERSION != 208111
# error "GSOAP VERSION 208111 MISMATCH IN GENERATED CODE VERSUS LIBRARY CODE: PLEASE REINSTALL PACKAGE"
#endif


/******************************************************************************\
 *                                                                            *
 * Enumeration Types                                                          *
 *                                                                            *
\******************************************************************************/


/* .\testbench.h:235 */
#ifndef SOAP_TYPE_ns3__TResult
#define SOAP_TYPE_ns3__TResult (27)
/* ns3:TResult */
enum ns3__TResult {
	ns3__TResult__rsOK = 0,
	ns3__TResult__rsPositionOutOfRange = 1,
	ns3__TResult__rsNotApplicable = 2,
	ns3__TResult__rsTestNotFound = 3,
	ns3__TResult__rsInvalidParameter = 4,
	ns3__TResult__rsTestAlreadyExists = 5,
	ns3__TResult__rsTypeNotFound = 6,
	ns3__TResult__rsBenchNotFound = 7
};
#endif

/* .\testbench.h:250 */
#ifndef SOAP_TYPE_ns3__TProofMethod
#define SOAP_TYPE_ns3__TProofMethod (28)
/* ns3:TProofMethod */
enum ns3__TProofMethod {
    ns3__TProofMethod__pmFlyGra = 0,
    ns3__TProofMethod__pmFlyMID = 1,
    ns3__TProofMethod__pmStdGra = 2,
    ns3__TProofMethod__pmStdMid = 3,
    PMETHODSNUM = 4
};
#endif

/* .\testbench.h:261 */
#ifndef SOAP_TYPE_ns3__TMeterIndicationMethod
#define SOAP_TYPE_ns3__TMeterIndicationMethod (29)
/* ns3:TMeterIndicationMethod */
enum ns3__TMeterIndicationMethod {
	ns3__TMeterIndicationMethod__miPulses = 0,
	ns3__TMeterIndicationMethod__miSyncPulses = 1,
	ns3__TMeterIndicationMethod__miInterpPulses = 2,
	ns3__TMeterIndicationMethod__miManual = 3,
	ns3__TMeterIndicationMethod__miNone = 4
};
#endif

/* .\testbench.h:273 */
#ifndef SOAP_TYPE_ns3__TStatusCode
#define SOAP_TYPE_ns3__TStatusCode (30)
/* ns3:TStatusCode */
enum ns3__TStatusCode {
	ns3__TStatusCode__stReady = 0,
	ns3__TStatusCode__stError = 1,
	ns3__TStatusCode__stPrepare = 2,
	ns3__TStatusCode__stTest = 3,
	ns3__TStatusCode__stStartTestWait = 4,
	ns3__TStatusCode__stStopTestWait = 5,
	ns3__TStatusCode__stBusy = 6
};
#endif

/* .\testbench.h:287 */
#ifndef SOAP_TYPE_ns3__TPulseCheck
#define SOAP_TYPE_ns3__TPulseCheck (31)
/* ns3:TPulseCheck */
enum ns3__TPulseCheck {
	ns3__TPulseCheck__pcNotUsed = 0,
	ns3__TPulseCheck__pcPass = 1,
	ns3__TPulseCheck__pcFail = 2
};
#endif

/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Classes, Structs and Unions                                                *
 *                                                                            *
\******************************************************************************/

class SOAP_ENC__Array;	/* .\testbench.h:157 */
class ns3__TTestParameters;	/* .\testbench.h:179 */
class ns3__TPressTestParameters;	/* .\testbench.h:181 */
class ns3__TWaitEvents;	/* .\testbench.h:183 */
class ns3__TStatus;	/* .\testbench.h:185 */
class ns3__TMeterData;	/* .\testbench.h:189 */
class ns3__TMeterIndication;	/* .\testbench.h:193 */
class ns3__TMeasurementData;	/* .\testbench.h:195 */
class ns3__TTestResults;	/* .\testbench.h:197 */
class ns3__TMeterResult;	/* .\testbench.h:201 */
class ns3__TTestResult;	/* .\testbench.h:203 */
class ns3__TPressTestResult;	/* .\testbench.h:205 */
class TStringDynArray;	/* .\testbench.h:173 */
class TIntegerDynArray;	/* .\testbench.h:175 */
class TBooleanDynArray;	/* .\testbench.h:177 */
class TMetersData;	/* .\testbench.h:187 */
class TMeterIndications;	/* .\testbench.h:191 */
class TMeterResults;	/* .\testbench.h:199 */
struct ns4__GetTypeListResponse;	/* .\testbench.h:985 */
struct ns4__GetTypeList;	/* .\testbench.h:1046 */
struct ns4__NewMeasurementResponse;	/* .\testbench.h:1057 */
struct ns4__NewMeasurement;	/* .\testbench.h:1127 */
struct ns4__GetTestParametersResponse;	/* .\testbench.h:1138 */
struct ns4__GetTestParameters;	/* .\testbench.h:1205 */
struct ns4__SetTestParametersResponse;	/* .\testbench.h:1216 */
struct ns4__SetTestParameters;	/* .\testbench.h:1289 */
struct ns4__GetPressTestParametersResponse;	/* .\testbench.h:1300 */
struct ns4__GetPressTestParameters;	/* .\testbench.h:1367 */
struct ns4__SetPressTestParametersResponse;	/* .\testbench.h:1378 */
struct ns4__SetPressTestParameters;	/* .\testbench.h:1451 */
struct ns4__StartResponse;	/* .\testbench.h:1462 */
struct ns4__Start;	/* .\testbench.h:1532 */
struct ns4__StopResponse;	/* .\testbench.h:1543 */
struct ns4__Stop;	/* .\testbench.h:1607 */
struct ns4__ContinueResponse;	/* .\testbench.h:1618 */
struct ns4__Continue;	/* .\testbench.h:1682 */
struct ns4__GetStatusResponse;	/* .\testbench.h:1693 */
struct ns4__GetStatus;	/* .\testbench.h:1757 */
struct ns4__SetMetersDataResponse;	/* .\testbench.h:1768 */
struct ns4__SetMetersData;	/* .\testbench.h:1835 */
struct ns4__GetMetersDataResponse;	/* .\testbench.h:1846 */
struct ns4__GetMetersData;	/* .\testbench.h:1913 */
struct ns4__GetMeterDataResponse;	/* .\testbench.h:1924 */
struct ns4__GetMeterData;	/* .\testbench.h:1991 */
struct ns4__SetMeterIndicationsResponse;	/* .\testbench.h:2002 */
struct ns4__SetMeterIndications;	/* .\testbench.h:2072 */
struct ns4__GetMeterPositionsResponse;	/* .\testbench.h:2083 */
struct ns4__GetMeterPositions;	/* .\testbench.h:2147 */
struct ns4__GetMeasurementDataResponse;	/* .\testbench.h:2158 */
struct ns4__GetMeasurementData;	/* .\testbench.h:2222 */
struct ns4__GetTestResultsResponse;	/* .\testbench.h:2233 */
struct ns4__GetTestResults;	/* .\testbench.h:2303 */
struct ns4__GetMeterResultResponse;	/* .\testbench.h:2314 */
struct ns4__GetMeterResult;	/* .\testbench.h:2384 */
struct ns4__GetTestResultResponse;	/* .\testbench.h:2395 */
struct ns4__GetTestResult;	/* .\testbench.h:2462 */
struct ns4__GetPressTestResultResponse;	/* .\testbench.h:2473 */
struct ns4__GetPressTestResult;	/* .\testbench.h:2540 */
struct ns4__GetTestConfigurationResponse;	/* .\testbench.h:2613 */
struct ns4__GetTestConfiguration;	/* .\testbench.h:2613 */
struct ns4__SetTestConfigurationResponse;	/* .\testbench.h:2624 */
struct ns4__SetTestConfiguration;	/* .\testbench.h:2694 */

/* .\testbench.h:157 */
#ifndef SOAP_TYPE_SOAP_ENC__Array
#define SOAP_TYPE_SOAP_ENC__Array (8)
/* Sequence of SOAP-ENC:Array schema type: */
class SOAP_CMAC SOAP_ENC__Array {
      public:
        char **__ptr;
        int __size;
      public:
        /// Return unique type id SOAP_TYPE_SOAP_ENC__Array
        virtual long soap_type(void) const { return SOAP_TYPE_SOAP_ENC__Array; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type SOAP_ENC__Array, default initialized and not managed by a soap context
        virtual SOAP_ENC__Array *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(SOAP_ENC__Array); }
      public:
        /// Constructor with default initializations
        SOAP_ENC__Array() : __ptr(), __size() { }
        virtual ~SOAP_ENC__Array() { }
        /// Friend allocator used by soap_new_SOAP_ENC__Array(struct soap*, int)
        friend SOAP_FMAC1 SOAP_ENC__Array * SOAP_FMAC2 soap_instantiate_SOAP_ENC__Array(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* .\testbench.h:179 */
#ifndef SOAP_TYPE_ns3__TTestParameters
#define SOAP_TYPE_ns3__TTestParameters (13)
/* complex XML schema type 'ns3:TTestParameters': */
class SOAP_CMAC ns3__TTestParameters {
      public:
        /// Required element 'MinFlowrate' of XML schema type 'xsd:double'
        double MinFlowrate;
        /// Required element 'MaxFlowrate' of XML schema type 'xsd:double'
        double MaxFlowrate;
        /// Required element 'MinTemperature' of XML schema type 'xsd:double'
        double MinTemperature;
        /// Required element 'MaxTemperature' of XML schema type 'xsd:double'
        double MaxTemperature;
        /// Required element 'MinVolume' of XML schema type 'xsd:double'
        double MinVolume;
        /// Required element 'ProofMethod' of XML schema type 'ns3:TProofMethod'
        enum ns3__TProofMethod ProofMethod;
        /// Required element 'MeterIndicationMethod' of XML schema type 'ns3:TMeterIndicationMethod'
        enum ns3__TMeterIndicationMethod MeterIndicationMethod;
        /// Required element 'MinError' of XML schema type 'xsd:double'
        double MinError;
        /// Required element 'MaxError' of XML schema type 'xsd:double'
        double MaxError;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__TTestParameters
        virtual long soap_type(void) const { return SOAP_TYPE_ns3__TTestParameters; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__TTestParameters, default initialized and not managed by a soap context
        virtual ns3__TTestParameters *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns3__TTestParameters); }
      public:
        /// Constructor with default initializations
        ns3__TTestParameters() : MinFlowrate(), MaxFlowrate(), MinTemperature(), MaxTemperature(), MinVolume(), ProofMethod(), MeterIndicationMethod(), MinError(), MaxError(), soap() { }
        virtual ~ns3__TTestParameters() { }
        /// Friend allocator used by soap_new_ns3__TTestParameters(struct soap*, int)
        friend SOAP_FMAC1 ns3__TTestParameters * SOAP_FMAC2 soap_instantiate_ns3__TTestParameters(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* .\testbench.h:181 */
#ifndef SOAP_TYPE_ns3__TPressTestParameters
#define SOAP_TYPE_ns3__TPressTestParameters (14)
/* complex XML schema type 'ns3:TPressTestParameters': */
class SOAP_CMAC ns3__TPressTestParameters {
      public:
        /// Required element 'StartPress' of XML schema type 'xsd:double'
        double StartPress;
        /// Required element 'Duration' of XML schema type 'xsd:double'
        double Duration;
        /// Required element 'MaxFall' of XML schema type 'xsd:double'
        double MaxFall;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__TPressTestParameters
        virtual long soap_type(void) const { return SOAP_TYPE_ns3__TPressTestParameters; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__TPressTestParameters, default initialized and not managed by a soap context
        virtual ns3__TPressTestParameters *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns3__TPressTestParameters); }
      public:
        /// Constructor with default initializations
        ns3__TPressTestParameters() : StartPress(), Duration(), MaxFall(), soap() { }
        virtual ~ns3__TPressTestParameters() { }
        /// Friend allocator used by soap_new_ns3__TPressTestParameters(struct soap*, int)
        friend SOAP_FMAC1 ns3__TPressTestParameters * SOAP_FMAC2 soap_instantiate_ns3__TPressTestParameters(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* .\testbench.h:183 */
#ifndef SOAP_TYPE_ns3__TWaitEvents
#define SOAP_TYPE_ns3__TWaitEvents (15)
/* complex XML schema type 'ns3:TWaitEvents': */
class SOAP_CMAC ns3__TWaitEvents {
      public:
        /// Required element 'StartTest' of XML schema type 'xsd:boolean'
        bool StartTest;
        /// Required element 'StopTest' of XML schema type 'xsd:boolean'
        bool StopTest;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__TWaitEvents
        virtual long soap_type(void) const { return SOAP_TYPE_ns3__TWaitEvents; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__TWaitEvents, default initialized and not managed by a soap context
        virtual ns3__TWaitEvents *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns3__TWaitEvents); }
      public:
        /// Constructor with default initializations
        ns3__TWaitEvents() : StartTest(), StopTest(), soap() { }
        virtual ~ns3__TWaitEvents() { }
        /// Friend allocator used by soap_new_ns3__TWaitEvents(struct soap*, int)
        friend SOAP_FMAC1 ns3__TWaitEvents * SOAP_FMAC2 soap_instantiate_ns3__TWaitEvents(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* .\testbench.h:185 */
#ifndef SOAP_TYPE_ns3__TStatus
#define SOAP_TYPE_ns3__TStatus (16)
/* complex XML schema type 'ns3:TStatus': */
class SOAP_CMAC ns3__TStatus {
      public:
        /// Required element 'StatusCode' of XML schema type 'ns3:TStatusCode'
        enum ns3__TStatusCode StatusCode;
        /// Required element 'TestName' of XML schema type 'xsd:string'
        std::string TestName;
        /// Required element 'InitializationEvent' of XML schema type 'xsd:boolean'
        bool InitializationEvent;
        /// Required element 'CanceledEvent' of XML schema type 'xsd:boolean'
        bool CanceledEvent;
        /// Required element 'FinishEvent' of XML schema type 'xsd:boolean'
        bool FinishEvent;
        /// Required element 'FinishTestEvent' of XML schema type 'xsd:boolean'
        bool FinishTestEvent;
        /// Required element 'StatusMessage' of XML schema type 'xsd:string'
        std::string StatusMessage;
        /// Required element 'CancelMessage' of XML schema type 'xsd:string'
        std::string CancelMessage;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__TStatus
        virtual long soap_type(void) const { return SOAP_TYPE_ns3__TStatus; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__TStatus, default initialized and not managed by a soap context
        virtual ns3__TStatus *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns3__TStatus); }
      public:
        /// Constructor with default initializations
        ns3__TStatus() : StatusCode(), TestName(), InitializationEvent(), CanceledEvent(), FinishEvent(), FinishTestEvent(), StatusMessage(), CancelMessage(), soap() { }
        virtual ~ns3__TStatus() { }
        /// Friend allocator used by soap_new_ns3__TStatus(struct soap*, int)
        friend SOAP_FMAC1 ns3__TStatus * SOAP_FMAC2 soap_instantiate_ns3__TStatus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* .\testbench.h:189 */
#ifndef SOAP_TYPE_ns3__TMeterData
#define SOAP_TYPE_ns3__TMeterData (18)
/* complex XML schema type 'ns3:TMeterData': */
class SOAP_CMAC ns3__TMeterData {
      public:
        /// Required element 'Position' of XML schema type 'xsd:int'
        int Position;
        /// Required element 'ProdNr' of XML schema type 'xsd:string'
        std::string ProdNr;
        /// Required element 'MeterConstant' of XML schema type 'xsd:double'
        double MeterConstant;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__TMeterData
        virtual long soap_type(void) const { return SOAP_TYPE_ns3__TMeterData; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__TMeterData, default initialized and not managed by a soap context
        virtual ns3__TMeterData *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns3__TMeterData); }
      public:
        /// Constructor with default initializations
        ns3__TMeterData() : Position(), ProdNr(), MeterConstant(), soap() { }
        virtual ~ns3__TMeterData() { }
        /// Friend allocator used by soap_new_ns3__TMeterData(struct soap*, int)
        friend SOAP_FMAC1 ns3__TMeterData * SOAP_FMAC2 soap_instantiate_ns3__TMeterData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* .\testbench.h:193 */
#ifndef SOAP_TYPE_ns3__TMeterIndication
#define SOAP_TYPE_ns3__TMeterIndication (20)
/* complex XML schema type 'ns3:TMeterIndication': */
class SOAP_CMAC ns3__TMeterIndication {
      public:
        /// Required element 'Position' of XML schema type 'xsd:int'
        int Position;
        /// Required element 'StartVolume' of XML schema type 'xsd:double'
        double StartVolume;
        /// Required element 'StopVolume' of XML schema type 'xsd:double'
        double StopVolume;
        /// Required element 'IndicatedVolume' of XML schema type 'xsd:double'
        double IndicatedVolume;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__TMeterIndication
        virtual long soap_type(void) const { return SOAP_TYPE_ns3__TMeterIndication; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__TMeterIndication, default initialized and not managed by a soap context
        virtual ns3__TMeterIndication *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns3__TMeterIndication); }
      public:
        /// Constructor with default initializations
        ns3__TMeterIndication() : Position(), StartVolume(), StopVolume(), IndicatedVolume(), soap() { }
        virtual ~ns3__TMeterIndication() { }
        /// Friend allocator used by soap_new_ns3__TMeterIndication(struct soap*, int)
        friend SOAP_FMAC1 ns3__TMeterIndication * SOAP_FMAC2 soap_instantiate_ns3__TMeterIndication(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* .\testbench.h:195 */
#ifndef SOAP_TYPE_ns3__TMeasurementData
#define SOAP_TYPE_ns3__TMeasurementData (21)
/* complex XML schema type 'ns3:TMeasurementData': */
class SOAP_CMAC ns3__TMeasurementData {
      public:
        /// Required element 'Done' of XML schema type 'xsd:boolean'
        bool Done;
        /// Required element 'TestNames' of XML schema type 'ArrayOfstring'
        TStringDynArray *TestNames;
        /// Required element 'ProtocolNumber' of XML schema type 'xsd:string'
        std::string ProtocolNumber;
        /// Required element 'TestBench' of XML schema type 'xsd:string'
        std::string TestBench;
        /// Required element 'Tester' of XML schema type 'xsd:string'
        std::string Tester;
        /// Required element 'TypeName' of XML schema type 'xsd:string'
        std::string TypeName;
        /// Required element 'TypeApprovalNumber' of XML schema type 'xsd:string'
        std::string TypeApprovalNumber;
        /// Required element 'TypeClass' of XML schema type 'xsd:string'
        std::string TypeClass;
        /// Required element 'TypeNominalSize' of XML schema type 'xsd:int'
        int TypeNominalSize;
        /// Required element 'TypeTestNames' of XML schema type 'ArrayOfstring'
        TStringDynArray *TypeTestNames;
        /// Required element 'TypeMeterConst' of XML schema type 'xsd:double'
        double TypeMeterConst;
        /// Required element 'TypeNominalFlowrate' of XML schema type 'xsd:double'
        double TypeNominalFlowrate;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__TMeasurementData
        virtual long soap_type(void) const { return SOAP_TYPE_ns3__TMeasurementData; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__TMeasurementData, default initialized and not managed by a soap context
        virtual ns3__TMeasurementData *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns3__TMeasurementData); }
      public:
        /// Constructor with default initializations
        ns3__TMeasurementData() : Done(), TestNames(), ProtocolNumber(), TestBench(), Tester(), TypeName(), TypeApprovalNumber(), TypeClass(), TypeNominalSize(), TypeTestNames(), TypeMeterConst(), TypeNominalFlowrate(), soap() { }
        virtual ~ns3__TMeasurementData() { }
        /// Friend allocator used by soap_new_ns3__TMeasurementData(struct soap*, int)
        friend SOAP_FMAC1 ns3__TMeasurementData * SOAP_FMAC2 soap_instantiate_ns3__TMeasurementData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* .\testbench.h:197 */
#ifndef SOAP_TYPE_ns3__TTestResults
#define SOAP_TYPE_ns3__TTestResults (22)
/* complex XML schema type 'ns3:TTestResults': */
class SOAP_CMAC ns3__TTestResults {
      public:
        /// Required element 'TestName' of XML schema type 'xsd:string'
        std::string TestName;
        /// Required element 'Flowrate' of XML schema type 'xsd:double'
        double Flowrate;
        /// Required element 'Weight' of XML schema type 'xsd:double'
        double Weight;
        /// Required element 'InletTemp' of XML schema type 'xsd:double'
        double InletTemp;
        /// Required element 'OutletTemp' of XML schema type 'xsd:double'
        double OutletTemp;
        /// Required element 'MIDTemp' of XML schema type 'xsd:double'
        double MIDTemp;
        /// Required element 'MIDPulseConst' of XML schema type 'xsd:double'
        double MIDPulseConst;
        /// Required element 'MIDVolume' of XML schema type 'xsd:double'
        double MIDVolume;
        /// Required element 'MIDError' of XML schema type 'xsd:double'
        double MIDError;
        /// Required element 'Duration' of XML schema type 'xsd:double'
        double Duration;
        /// Required element 'MeterResults' of XML schema type 'ArrayOfTMeterResult'
        TMeterResults *MeterResults;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__TTestResults
        virtual long soap_type(void) const { return SOAP_TYPE_ns3__TTestResults; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__TTestResults, default initialized and not managed by a soap context
        virtual ns3__TTestResults *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns3__TTestResults); }
      public:
        /// Constructor with default initializations
        ns3__TTestResults() : TestName(), Flowrate(), Weight(), InletTemp(), OutletTemp(), MIDTemp(), MIDPulseConst(), MIDVolume(), MIDError(), Duration(), MeterResults(), soap() { }
        virtual ~ns3__TTestResults() { }
        /// Friend allocator used by soap_new_ns3__TTestResults(struct soap*, int)
        friend SOAP_FMAC1 ns3__TTestResults * SOAP_FMAC2 soap_instantiate_ns3__TTestResults(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* .\testbench.h:201 */
#ifndef SOAP_TYPE_ns3__TMeterResult
#define SOAP_TYPE_ns3__TMeterResult (24)
/* complex XML schema type 'ns3:TMeterResult': */
class SOAP_CMAC ns3__TMeterResult {
      public:
        /// Required element 'Position' of XML schema type 'xsd:int'
        int Position;
        /// Required element 'Temperature' of XML schema type 'xsd:double'
        double Temperature;
        /// Required element 'Pressure' of XML schema type 'xsd:double'
        double Pressure;
        /// Required element 'Density' of XML schema type 'xsd:double'
        double Density;
        /// Required element 'GatedMIDPulses' of XML schema type 'xsd:int'
        int GatedMIDPulses;
        /// Required element 'NominalVolume' of XML schema type 'xsd:double'
        double NominalVolume;
        /// Required element 'Pulses' of XML schema type 'xsd:double'
        double Pulses;
        /// Required element 'PulseConst' of XML schema type 'xsd:double'
        double PulseConst;
        /// Required element 'StartVolume' of XML schema type 'xsd:double'
        double StartVolume;
        /// Required element 'StopVolume' of XML schema type 'xsd:double'
        double StopVolume;
        /// Required element 'IndicatedVolume' of XML schema type 'xsd:double'
        double IndicatedVolume;
        /// Required element 'Error' of XML schema type 'xsd:double'
        double Error;
        /// Required element 'PulseCheck' of XML schema type 'ns3:TPulseCheck'
        enum ns3__TPulseCheck PulseCheck;
        /// Required element 'Passed' of XML schema type 'xsd:boolean'
        bool Passed;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__TMeterResult
        virtual long soap_type(void) const { return SOAP_TYPE_ns3__TMeterResult; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__TMeterResult, default initialized and not managed by a soap context
        virtual ns3__TMeterResult *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns3__TMeterResult); }
      public:
        /// Constructor with default initializations
        ns3__TMeterResult() : Position(), Temperature(), Pressure(), Density(), GatedMIDPulses(), NominalVolume(), Pulses(), PulseConst(), StartVolume(), StopVolume(), IndicatedVolume(), Error(), PulseCheck(), Passed(), soap() { }
        virtual ~ns3__TMeterResult() { }
        /// Friend allocator used by soap_new_ns3__TMeterResult(struct soap*, int)
        friend SOAP_FMAC1 ns3__TMeterResult * SOAP_FMAC2 soap_instantiate_ns3__TMeterResult(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* .\testbench.h:203 */
#ifndef SOAP_TYPE_ns3__TTestResult
#define SOAP_TYPE_ns3__TTestResult (25)
/* complex XML schema type 'ns3:TTestResult': */
class SOAP_CMAC ns3__TTestResult {
      public:
        /// Required element 'Done' of XML schema type 'xsd:boolean'
        bool Done;
        /// Required element 'TestName' of XML schema type 'xsd:string'
        std::string TestName;
        /// Required element 'Flowrate' of XML schema type 'xsd:double'
        double Flowrate;
        /// Required element 'Weight' of XML schema type 'xsd:double'
        double Weight;
        /// Required element 'InletTemp' of XML schema type 'xsd:double'
        double InletTemp;
        /// Required element 'OutletTemp' of XML schema type 'xsd:double'
        double OutletTemp;
        /// Required element 'InletPressure' of XML schema type 'xsd:double'
        double InletPressure;
        /// Required element 'OutletPressure' of XML schema type 'xsd:double'
        double OutletPressure;
        /// Required element 'Lambda' of XML schema type 'xsd:double'
        double Lambda;
        /// Required element 'MIDTemp' of XML schema type 'xsd:double'
        double MIDTemp;
        /// Required element 'MIDPulseConst' of XML schema type 'xsd:double'
        double MIDPulseConst;
        /// Required element 'MIDVolume' of XML schema type 'xsd:double'
        double MIDVolume;
        /// Required element 'MIDError' of XML schema type 'xsd:double'
        double MIDError;
        /// Required element 'Duration' of XML schema type 'xsd:double'
        double Duration;
        /// Required element 'AdditiveLambda' of XML schema type 'xsd:double'
        double AdditiveLambda;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__TTestResult
        virtual long soap_type(void) const { return SOAP_TYPE_ns3__TTestResult; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__TTestResult, default initialized and not managed by a soap context
        virtual ns3__TTestResult *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns3__TTestResult); }
      public:
        /// Constructor with default initializations
        ns3__TTestResult() : Done(), TestName(), Flowrate(), Weight(), InletTemp(), OutletTemp(), InletPressure(), OutletPressure(), Lambda(), MIDTemp(), MIDPulseConst(), MIDVolume(), MIDError(), Duration(), AdditiveLambda(), soap() { }
        virtual ~ns3__TTestResult() { }
        /// Friend allocator used by soap_new_ns3__TTestResult(struct soap*, int)
        friend SOAP_FMAC1 ns3__TTestResult * SOAP_FMAC2 soap_instantiate_ns3__TTestResult(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* .\testbench.h:205 */
#ifndef SOAP_TYPE_ns3__TPressTestResult
#define SOAP_TYPE_ns3__TPressTestResult (26)
/* complex XML schema type 'ns3:TPressTestResult': */
class SOAP_CMAC ns3__TPressTestResult {
      public:
        /// Required element 'Done' of XML schema type 'xsd:boolean'
        bool Done;
        /// Required element 'TestName' of XML schema type 'xsd:string'
        std::string TestName;
        /// Required element 'StartPress' of XML schema type 'xsd:double'
        double StartPress;
        /// Required element 'PressDrop' of XML schema type 'xsd:double'
        double PressDrop;
        /// Required element 'Passed' of XML schema type 'xsd:boolean'
        bool Passed;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__TPressTestResult
        virtual long soap_type(void) const { return SOAP_TYPE_ns3__TPressTestResult; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__TPressTestResult, default initialized and not managed by a soap context
        virtual ns3__TPressTestResult *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns3__TPressTestResult); }
      public:
        /// Constructor with default initializations
        ns3__TPressTestResult() : Done(), TestName(), StartPress(), PressDrop(), Passed(), soap() { }
        virtual ~ns3__TPressTestResult() { }
        /// Friend allocator used by soap_new_ns3__TPressTestResult(struct soap*, int)
        friend SOAP_FMAC1 ns3__TPressTestResult * SOAP_FMAC2 soap_instantiate_ns3__TPressTestResult(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* .\testbench.h:173 */
#ifndef SOAP_TYPE_TStringDynArray
#define SOAP_TYPE_TStringDynArray (10)
/* SOAP encoded array of xsd:string schema type: */
class SOAP_CMAC TStringDynArray {
      public:
        std::string *__ptr;
        int __size;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_TStringDynArray
        virtual long soap_type(void) const { return SOAP_TYPE_TStringDynArray; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type TStringDynArray, default initialized and not managed by a soap context
        virtual TStringDynArray *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(TStringDynArray); }
      public:
        /// Constructor with default initializations
        TStringDynArray() : __ptr(), __size(), soap() { }
        virtual ~TStringDynArray() { }
        /// Friend allocator used by soap_new_TStringDynArray(struct soap*, int)
        friend SOAP_FMAC1 TStringDynArray * SOAP_FMAC2 soap_instantiate_TStringDynArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* .\testbench.h:175 */
#ifndef SOAP_TYPE_TIntegerDynArray
#define SOAP_TYPE_TIntegerDynArray (11)
/* SOAP encoded array of xsd:int schema type: */
class SOAP_CMAC TIntegerDynArray {
      public:
        int *__ptr;
        int __size;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_TIntegerDynArray
        virtual long soap_type(void) const { return SOAP_TYPE_TIntegerDynArray; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type TIntegerDynArray, default initialized and not managed by a soap context
        virtual TIntegerDynArray *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(TIntegerDynArray); }
      public:
        /// Constructor with default initializations
        TIntegerDynArray() : __ptr(), __size(), soap() { }
        virtual ~TIntegerDynArray() { }
        /// Friend allocator used by soap_new_TIntegerDynArray(struct soap*, int)
        friend SOAP_FMAC1 TIntegerDynArray * SOAP_FMAC2 soap_instantiate_TIntegerDynArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* .\testbench.h:177 */
#ifndef SOAP_TYPE_TBooleanDynArray
#define SOAP_TYPE_TBooleanDynArray (12)
/* SOAP encoded array of xsd:boolean schema type: */
class SOAP_CMAC TBooleanDynArray {
      public:
        bool *__ptr;
        int __size;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_TBooleanDynArray
        virtual long soap_type(void) const { return SOAP_TYPE_TBooleanDynArray; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type TBooleanDynArray, default initialized and not managed by a soap context
        virtual TBooleanDynArray *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(TBooleanDynArray); }
      public:
        /// Constructor with default initializations
        TBooleanDynArray() : __ptr(), __size(), soap() { }
        virtual ~TBooleanDynArray() { }
        /// Friend allocator used by soap_new_TBooleanDynArray(struct soap*, int)
        friend SOAP_FMAC1 TBooleanDynArray * SOAP_FMAC2 soap_instantiate_TBooleanDynArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* .\testbench.h:187 */
#ifndef SOAP_TYPE_TMetersData
#define SOAP_TYPE_TMetersData (17)
/* SOAP encoded array of ns3:TMeterData schema type: */
class SOAP_CMAC TMetersData {
      public:
        ns3__TMeterData **__ptr;
        int __size;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_TMetersData
        virtual long soap_type(void) const { return SOAP_TYPE_TMetersData; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type TMetersData, default initialized and not managed by a soap context
        virtual TMetersData *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(TMetersData); }
      public:
        /// Constructor with default initializations
        TMetersData() : __ptr(), __size(), soap() { }
        virtual ~TMetersData() { }
        /// Friend allocator used by soap_new_TMetersData(struct soap*, int)
        friend SOAP_FMAC1 TMetersData * SOAP_FMAC2 soap_instantiate_TMetersData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* .\testbench.h:191 */
#ifndef SOAP_TYPE_TMeterIndications
#define SOAP_TYPE_TMeterIndications (19)
/* SOAP encoded array of ns3:TMeterIndication schema type: */
class SOAP_CMAC TMeterIndications {
      public:
        ns3__TMeterIndication **__ptr;
        int __size;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_TMeterIndications
        virtual long soap_type(void) const { return SOAP_TYPE_TMeterIndications; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type TMeterIndications, default initialized and not managed by a soap context
        virtual TMeterIndications *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(TMeterIndications); }
      public:
        /// Constructor with default initializations
        TMeterIndications() : __ptr(), __size(), soap() { }
        virtual ~TMeterIndications() { }
        /// Friend allocator used by soap_new_TMeterIndications(struct soap*, int)
        friend SOAP_FMAC1 TMeterIndications * SOAP_FMAC2 soap_instantiate_TMeterIndications(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* .\testbench.h:199 */
#ifndef SOAP_TYPE_TMeterResults
#define SOAP_TYPE_TMeterResults (23)
/* SOAP encoded array of ns3:TMeterResult schema type: */
class SOAP_CMAC TMeterResults {
      public:
        ns3__TMeterResult **__ptr;
        int __size;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_TMeterResults
        virtual long soap_type(void) const { return SOAP_TYPE_TMeterResults; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type TMeterResults, default initialized and not managed by a soap context
        virtual TMeterResults *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(TMeterResults); }
      public:
        /// Constructor with default initializations
        TMeterResults() : __ptr(), __size(), soap() { }
        virtual ~TMeterResults() { }
        /// Friend allocator used by soap_new_TMeterResults(struct soap*, int)
        friend SOAP_FMAC1 TMeterResults * SOAP_FMAC2 soap_instantiate_TMeterResults(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* .\testbench.h:985 */
#ifndef SOAP_TYPE_ns4__GetTypeListResponse
#define SOAP_TYPE_ns4__GetTypeListResponse (47)
/* complex XML schema type 'ns4:GetTypeListResponse': */
struct SOAP_CMAC ns4__GetTypeListResponse {
      public:
        /** Optional element 'return' of XML schema type 'ArrayOfstring' */
        TStringDynArray *return_;
      public:
        /** Return unique type id SOAP_TYPE_ns4__GetTypeListResponse */
        long soap_type() const { return SOAP_TYPE_ns4__GetTypeListResponse; }
        /** Constructor with member initializations */
        ns4__GetTypeListResponse() : return_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns4__GetTypeListResponse * SOAP_FMAC2 soap_instantiate_ns4__GetTypeListResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* .\testbench.h:1046 */
#ifndef SOAP_TYPE_ns4__GetTypeList
#define SOAP_TYPE_ns4__GetTypeList (50)
/* complex XML schema type 'ns4:GetTypeList': */
struct SOAP_CMAC ns4__GetTypeList {
      public:
        /** Return unique type id SOAP_TYPE_ns4__GetTypeList */
        long soap_type() const { return SOAP_TYPE_ns4__GetTypeList; }
        /** Constructor with member initializations */
        ns4__GetTypeList() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns4__GetTypeList * SOAP_FMAC2 soap_instantiate_ns4__GetTypeList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* .\testbench.h:1057 */
#ifndef SOAP_TYPE_ns4__NewMeasurementResponse
#define SOAP_TYPE_ns4__NewMeasurementResponse (51)
/* complex XML schema type 'ns4:NewMeasurementResponse': */
struct SOAP_CMAC ns4__NewMeasurementResponse {
      public:
        /** Required element 'return' of XML schema type 'ns3:TResult' */
        enum ns3__TResult return_;
      public:
        /** Return unique type id SOAP_TYPE_ns4__NewMeasurementResponse */
        long soap_type() const { return SOAP_TYPE_ns4__NewMeasurementResponse; }
        /** Constructor with member initializations */
        ns4__NewMeasurementResponse() : return_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns4__NewMeasurementResponse * SOAP_FMAC2 soap_instantiate_ns4__NewMeasurementResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* .\testbench.h:1127 */
#ifndef SOAP_TYPE_ns4__NewMeasurement
#define SOAP_TYPE_ns4__NewMeasurement (54)
/* complex XML schema type 'ns4:NewMeasurement': */
struct SOAP_CMAC ns4__NewMeasurement {
      public:
        /** Required element 'Bench' of XML schema type 'xsd:int' */
        int Bench;
        /** Required element 'TypeName' of XML schema type 'xsd:string' */
        std::string TypeName;
        /** Required element 'ArchiveData' of XML schema type 'xsd:boolean' */
        bool ArchiveData;
      public:
        /** Return unique type id SOAP_TYPE_ns4__NewMeasurement */
        long soap_type() const { return SOAP_TYPE_ns4__NewMeasurement; }
        /** Constructor with member initializations */
        ns4__NewMeasurement() : Bench(), TypeName(), ArchiveData() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns4__NewMeasurement * SOAP_FMAC2 soap_instantiate_ns4__NewMeasurement(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* .\testbench.h:1138 */
#ifndef SOAP_TYPE_ns4__GetTestParametersResponse
#define SOAP_TYPE_ns4__GetTestParametersResponse (55)
/* complex XML schema type 'ns4:GetTestParametersResponse': */
struct SOAP_CMAC ns4__GetTestParametersResponse {
      public:
        /** Optional element 'return' of XML schema type 'ns3:TTestParameters' */
        ns3__TTestParameters *return_;
      public:
        /** Return unique type id SOAP_TYPE_ns4__GetTestParametersResponse */
        long soap_type() const { return SOAP_TYPE_ns4__GetTestParametersResponse; }
        /** Constructor with member initializations */
        ns4__GetTestParametersResponse() : return_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns4__GetTestParametersResponse * SOAP_FMAC2 soap_instantiate_ns4__GetTestParametersResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* .\testbench.h:1205 */
#ifndef SOAP_TYPE_ns4__GetTestParameters
#define SOAP_TYPE_ns4__GetTestParameters (59)
/* complex XML schema type 'ns4:GetTestParameters': */
struct SOAP_CMAC ns4__GetTestParameters {
      public:
        /** Required element 'Bench' of XML schema type 'xsd:int' */
        int Bench;
        /** Required element 'TestName' of XML schema type 'xsd:string' */
        std::string TestName;
      public:
        /** Return unique type id SOAP_TYPE_ns4__GetTestParameters */
        long soap_type() const { return SOAP_TYPE_ns4__GetTestParameters; }
        /** Constructor with member initializations */
        ns4__GetTestParameters() : Bench(), TestName() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns4__GetTestParameters * SOAP_FMAC2 soap_instantiate_ns4__GetTestParameters(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* .\testbench.h:1216 */
#ifndef SOAP_TYPE_ns4__SetTestParametersResponse
#define SOAP_TYPE_ns4__SetTestParametersResponse (60)
/* complex XML schema type 'ns4:SetTestParametersResponse': */
struct SOAP_CMAC ns4__SetTestParametersResponse {
      public:
        /** Required element 'return' of XML schema type 'ns3:TResult' */
        enum ns3__TResult return_;
      public:
        /** Return unique type id SOAP_TYPE_ns4__SetTestParametersResponse */
        long soap_type() const { return SOAP_TYPE_ns4__SetTestParametersResponse; }
        /** Constructor with member initializations */
        ns4__SetTestParametersResponse() : return_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns4__SetTestParametersResponse * SOAP_FMAC2 soap_instantiate_ns4__SetTestParametersResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* .\testbench.h:1289 */
#ifndef SOAP_TYPE_ns4__SetTestParameters
#define SOAP_TYPE_ns4__SetTestParameters (63)
/* complex XML schema type 'ns4:SetTestParameters': */
struct SOAP_CMAC ns4__SetTestParameters {
      public:
        /** Required element 'Bench' of XML schema type 'xsd:int' */
        int Bench;
        /** Required element 'TestName' of XML schema type 'xsd:string' */
        std::string TestName;
        /** Optional element 'TestParameters' of XML schema type 'ns3:TTestParameters' */
        ns3__TTestParameters *TestParameters;
        /** Required element 'CreateTest' of XML schema type 'xsd:boolean' */
        bool CreateTest;
      public:
        /** Return unique type id SOAP_TYPE_ns4__SetTestParameters */
        long soap_type() const { return SOAP_TYPE_ns4__SetTestParameters; }
        /** Constructor with member initializations */
        ns4__SetTestParameters() : Bench(), TestName(), TestParameters(), CreateTest() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns4__SetTestParameters * SOAP_FMAC2 soap_instantiate_ns4__SetTestParameters(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* .\testbench.h:1300 */
#ifndef SOAP_TYPE_ns4__GetPressTestParametersResponse
#define SOAP_TYPE_ns4__GetPressTestParametersResponse (64)
/* complex XML schema type 'ns4:GetPressTestParametersResponse': */
struct SOAP_CMAC ns4__GetPressTestParametersResponse {
      public:
        /** Optional element 'return' of XML schema type 'ns3:TPressTestParameters' */
        ns3__TPressTestParameters *return_;
      public:
        /** Return unique type id SOAP_TYPE_ns4__GetPressTestParametersResponse */
        long soap_type() const { return SOAP_TYPE_ns4__GetPressTestParametersResponse; }
        /** Constructor with member initializations */
        ns4__GetPressTestParametersResponse() : return_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns4__GetPressTestParametersResponse * SOAP_FMAC2 soap_instantiate_ns4__GetPressTestParametersResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* .\testbench.h:1367 */
#ifndef SOAP_TYPE_ns4__GetPressTestParameters
#define SOAP_TYPE_ns4__GetPressTestParameters (68)
/* complex XML schema type 'ns4:GetPressTestParameters': */
struct SOAP_CMAC ns4__GetPressTestParameters {
      public:
        /** Required element 'Bench' of XML schema type 'xsd:int' */
        int Bench;
        /** Required element 'TestName' of XML schema type 'xsd:string' */
        std::string TestName;
      public:
        /** Return unique type id SOAP_TYPE_ns4__GetPressTestParameters */
        long soap_type() const { return SOAP_TYPE_ns4__GetPressTestParameters; }
        /** Constructor with member initializations */
        ns4__GetPressTestParameters() : Bench(), TestName() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns4__GetPressTestParameters * SOAP_FMAC2 soap_instantiate_ns4__GetPressTestParameters(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* .\testbench.h:1378 */
#ifndef SOAP_TYPE_ns4__SetPressTestParametersResponse
#define SOAP_TYPE_ns4__SetPressTestParametersResponse (69)
/* complex XML schema type 'ns4:SetPressTestParametersResponse': */
struct SOAP_CMAC ns4__SetPressTestParametersResponse {
      public:
        /** Required element 'return' of XML schema type 'ns3:TResult' */
        enum ns3__TResult return_;
      public:
        /** Return unique type id SOAP_TYPE_ns4__SetPressTestParametersResponse */
        long soap_type() const { return SOAP_TYPE_ns4__SetPressTestParametersResponse; }
        /** Constructor with member initializations */
        ns4__SetPressTestParametersResponse() : return_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns4__SetPressTestParametersResponse * SOAP_FMAC2 soap_instantiate_ns4__SetPressTestParametersResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* .\testbench.h:1451 */
#ifndef SOAP_TYPE_ns4__SetPressTestParameters
#define SOAP_TYPE_ns4__SetPressTestParameters (72)
/* complex XML schema type 'ns4:SetPressTestParameters': */
struct SOAP_CMAC ns4__SetPressTestParameters {
      public:
        /** Required element 'Bench' of XML schema type 'xsd:int' */
        int Bench;
        /** Required element 'TestName' of XML schema type 'xsd:string' */
        std::string TestName;
        /** Optional element 'TestParameters' of XML schema type 'ns3:TPressTestParameters' */
        ns3__TPressTestParameters *TestParameters;
        /** Required element 'CreateTest' of XML schema type 'xsd:boolean' */
        bool CreateTest;
      public:
        /** Return unique type id SOAP_TYPE_ns4__SetPressTestParameters */
        long soap_type() const { return SOAP_TYPE_ns4__SetPressTestParameters; }
        /** Constructor with member initializations */
        ns4__SetPressTestParameters() : Bench(), TestName(), TestParameters(), CreateTest() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns4__SetPressTestParameters * SOAP_FMAC2 soap_instantiate_ns4__SetPressTestParameters(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* .\testbench.h:1462 */
#ifndef SOAP_TYPE_ns4__StartResponse
#define SOAP_TYPE_ns4__StartResponse (73)
/* complex XML schema type 'ns4:StartResponse': */
struct SOAP_CMAC ns4__StartResponse {
      public:
        /** Required element 'return' of XML schema type 'ns3:TResult' */
        enum ns3__TResult return_;
      public:
        /** Return unique type id SOAP_TYPE_ns4__StartResponse */
        long soap_type() const { return SOAP_TYPE_ns4__StartResponse; }
        /** Constructor with member initializations */
        ns4__StartResponse() : return_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns4__StartResponse * SOAP_FMAC2 soap_instantiate_ns4__StartResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* .\testbench.h:1532 */
#ifndef SOAP_TYPE_ns4__Start
#define SOAP_TYPE_ns4__Start (77)
/* complex XML schema type 'ns4:Start': */
struct SOAP_CMAC ns4__Start {
      public:
        /** Required element 'Bench' of XML schema type 'xsd:int' */
        int Bench;
        /** Required element 'TestName' of XML schema type 'xsd:string' */
        std::string TestName;
        /** Optional element 'WaitEvents' of XML schema type 'ns3:TWaitEvents' */
        ns3__TWaitEvents *WaitEvents;
      public:
        /** Return unique type id SOAP_TYPE_ns4__Start */
        long soap_type() const { return SOAP_TYPE_ns4__Start; }
        /** Constructor with member initializations */
        ns4__Start() : Bench(), TestName(), WaitEvents() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns4__Start * SOAP_FMAC2 soap_instantiate_ns4__Start(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* .\testbench.h:1543 */
#ifndef SOAP_TYPE_ns4__StopResponse
#define SOAP_TYPE_ns4__StopResponse (78)
/* complex XML schema type 'ns4:StopResponse': */
struct SOAP_CMAC ns4__StopResponse {
      public:
        /** Required element 'return' of XML schema type 'ns3:TResult' */
        enum ns3__TResult return_;
      public:
        /** Return unique type id SOAP_TYPE_ns4__StopResponse */
        long soap_type() const { return SOAP_TYPE_ns4__StopResponse; }
        /** Constructor with member initializations */
        ns4__StopResponse() : return_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns4__StopResponse * SOAP_FMAC2 soap_instantiate_ns4__StopResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* .\testbench.h:1607 */
#ifndef SOAP_TYPE_ns4__Stop
#define SOAP_TYPE_ns4__Stop (81)
/* complex XML schema type 'ns4:Stop': */
struct SOAP_CMAC ns4__Stop {
      public:
        /** Required element 'Bench' of XML schema type 'xsd:int' */
        int Bench;
      public:
        /** Return unique type id SOAP_TYPE_ns4__Stop */
        long soap_type() const { return SOAP_TYPE_ns4__Stop; }
        /** Constructor with member initializations */
        ns4__Stop() : Bench() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns4__Stop * SOAP_FMAC2 soap_instantiate_ns4__Stop(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* .\testbench.h:1618 */
#ifndef SOAP_TYPE_ns4__ContinueResponse
#define SOAP_TYPE_ns4__ContinueResponse (82)
/* complex XML schema type 'ns4:ContinueResponse': */
struct SOAP_CMAC ns4__ContinueResponse {
      public:
        /** Required element 'return' of XML schema type 'ns3:TResult' */
        enum ns3__TResult return_;
      public:
        /** Return unique type id SOAP_TYPE_ns4__ContinueResponse */
        long soap_type() const { return SOAP_TYPE_ns4__ContinueResponse; }
        /** Constructor with member initializations */
        ns4__ContinueResponse() : return_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns4__ContinueResponse * SOAP_FMAC2 soap_instantiate_ns4__ContinueResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* .\testbench.h:1682 */
#ifndef SOAP_TYPE_ns4__Continue
#define SOAP_TYPE_ns4__Continue (85)
/* complex XML schema type 'ns4:Continue': */
struct SOAP_CMAC ns4__Continue {
      public:
        /** Required element 'Bench' of XML schema type 'xsd:int' */
        int Bench;
      public:
        /** Return unique type id SOAP_TYPE_ns4__Continue */
        long soap_type() const { return SOAP_TYPE_ns4__Continue; }
        /** Constructor with member initializations */
        ns4__Continue() : Bench() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns4__Continue * SOAP_FMAC2 soap_instantiate_ns4__Continue(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* .\testbench.h:1693 */
#ifndef SOAP_TYPE_ns4__GetStatusResponse
#define SOAP_TYPE_ns4__GetStatusResponse (86)
/* complex XML schema type 'ns4:GetStatusResponse': */
struct SOAP_CMAC ns4__GetStatusResponse {
      public:
        /** Optional element 'return' of XML schema type 'ns3:TStatus' */
        ns3__TStatus *return_;
      public:
        /** Return unique type id SOAP_TYPE_ns4__GetStatusResponse */
        long soap_type() const { return SOAP_TYPE_ns4__GetStatusResponse; }
        /** Constructor with member initializations */
        ns4__GetStatusResponse() : return_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns4__GetStatusResponse * SOAP_FMAC2 soap_instantiate_ns4__GetStatusResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* .\testbench.h:1757 */
#ifndef SOAP_TYPE_ns4__GetStatus
#define SOAP_TYPE_ns4__GetStatus (90)
/* complex XML schema type 'ns4:GetStatus': */
struct SOAP_CMAC ns4__GetStatus {
      public:
        /** Required element 'Bench' of XML schema type 'xsd:int' */
        int Bench;
      public:
        /** Return unique type id SOAP_TYPE_ns4__GetStatus */
        long soap_type() const { return SOAP_TYPE_ns4__GetStatus; }
        /** Constructor with member initializations */
        ns4__GetStatus() : Bench() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns4__GetStatus * SOAP_FMAC2 soap_instantiate_ns4__GetStatus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* .\testbench.h:1768 */
#ifndef SOAP_TYPE_ns4__SetMetersDataResponse
#define SOAP_TYPE_ns4__SetMetersDataResponse (91)
/* complex XML schema type 'ns4:SetMetersDataResponse': */
struct SOAP_CMAC ns4__SetMetersDataResponse {
      public:
        /** Required element 'return' of XML schema type 'ns3:TResult' */
        enum ns3__TResult return_;
      public:
        /** Return unique type id SOAP_TYPE_ns4__SetMetersDataResponse */
        long soap_type() const { return SOAP_TYPE_ns4__SetMetersDataResponse; }
        /** Constructor with member initializations */
        ns4__SetMetersDataResponse() : return_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns4__SetMetersDataResponse * SOAP_FMAC2 soap_instantiate_ns4__SetMetersDataResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* .\testbench.h:1835 */
#ifndef SOAP_TYPE_ns4__SetMetersData
#define SOAP_TYPE_ns4__SetMetersData (95)
/* complex XML schema type 'ns4:SetMetersData': */
struct SOAP_CMAC ns4__SetMetersData {
      public:
        /** Required element 'Bench' of XML schema type 'xsd:int' */
        int Bench;
        /** Optional element 'MetersData' of XML schema type 'ArrayOfTMeterData' */
        TMetersData *MetersData;
      public:
        /** Return unique type id SOAP_TYPE_ns4__SetMetersData */
        long soap_type() const { return SOAP_TYPE_ns4__SetMetersData; }
        /** Constructor with member initializations */
        ns4__SetMetersData() : Bench(), MetersData() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns4__SetMetersData * SOAP_FMAC2 soap_instantiate_ns4__SetMetersData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* .\testbench.h:1846 */
#ifndef SOAP_TYPE_ns4__GetMetersDataResponse
#define SOAP_TYPE_ns4__GetMetersDataResponse (96)
/* complex XML schema type 'ns4:GetMetersDataResponse': */
struct SOAP_CMAC ns4__GetMetersDataResponse {
      public:
        /** Optional element 'return' of XML schema type 'ArrayOfTMeterData' */
        TMetersData *return_;
      public:
        /** Return unique type id SOAP_TYPE_ns4__GetMetersDataResponse */
        long soap_type() const { return SOAP_TYPE_ns4__GetMetersDataResponse; }
        /** Constructor with member initializations */
        ns4__GetMetersDataResponse() : return_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns4__GetMetersDataResponse * SOAP_FMAC2 soap_instantiate_ns4__GetMetersDataResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* .\testbench.h:1913 */
#ifndef SOAP_TYPE_ns4__GetMetersData
#define SOAP_TYPE_ns4__GetMetersData (100)
/* complex XML schema type 'ns4:GetMetersData': */
struct SOAP_CMAC ns4__GetMetersData {
      public:
        /** Required element 'Bench' of XML schema type 'xsd:int' */
        int Bench;
        /** Optional element 'MetersPos' of XML schema type 'ArrayOfint' */
        TIntegerDynArray *MetersPos;
      public:
        /** Return unique type id SOAP_TYPE_ns4__GetMetersData */
        long soap_type() const { return SOAP_TYPE_ns4__GetMetersData; }
        /** Constructor with member initializations */
        ns4__GetMetersData() : Bench(), MetersPos() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns4__GetMetersData * SOAP_FMAC2 soap_instantiate_ns4__GetMetersData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* .\testbench.h:1924 */
#ifndef SOAP_TYPE_ns4__GetMeterDataResponse
#define SOAP_TYPE_ns4__GetMeterDataResponse (101)
/* complex XML schema type 'ns4:GetMeterDataResponse': */
struct SOAP_CMAC ns4__GetMeterDataResponse {
      public:
        /** Optional element 'return' of XML schema type 'ns3:TMeterData' */
        ns3__TMeterData *return_;
      public:
        /** Return unique type id SOAP_TYPE_ns4__GetMeterDataResponse */
        long soap_type() const { return SOAP_TYPE_ns4__GetMeterDataResponse; }
        /** Constructor with member initializations */
        ns4__GetMeterDataResponse() : return_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns4__GetMeterDataResponse * SOAP_FMAC2 soap_instantiate_ns4__GetMeterDataResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* .\testbench.h:1991 */
#ifndef SOAP_TYPE_ns4__GetMeterData
#define SOAP_TYPE_ns4__GetMeterData (104)
/* complex XML schema type 'ns4:GetMeterData': */
struct SOAP_CMAC ns4__GetMeterData {
      public:
        /** Required element 'Bench' of XML schema type 'xsd:int' */
        int Bench;
        /** Required element 'MeterPos' of XML schema type 'xsd:int' */
        int MeterPos;
      public:
        /** Return unique type id SOAP_TYPE_ns4__GetMeterData */
        long soap_type() const { return SOAP_TYPE_ns4__GetMeterData; }
        /** Constructor with member initializations */
        ns4__GetMeterData() : Bench(), MeterPos() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns4__GetMeterData * SOAP_FMAC2 soap_instantiate_ns4__GetMeterData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* .\testbench.h:2002 */
#ifndef SOAP_TYPE_ns4__SetMeterIndicationsResponse
#define SOAP_TYPE_ns4__SetMeterIndicationsResponse (105)
/* complex XML schema type 'ns4:SetMeterIndicationsResponse': */
struct SOAP_CMAC ns4__SetMeterIndicationsResponse {
      public:
        /** Required element 'return' of XML schema type 'ns3:TResult' */
        enum ns3__TResult return_;
      public:
        /** Return unique type id SOAP_TYPE_ns4__SetMeterIndicationsResponse */
        long soap_type() const { return SOAP_TYPE_ns4__SetMeterIndicationsResponse; }
        /** Constructor with member initializations */
        ns4__SetMeterIndicationsResponse() : return_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns4__SetMeterIndicationsResponse * SOAP_FMAC2 soap_instantiate_ns4__SetMeterIndicationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* .\testbench.h:2072 */
#ifndef SOAP_TYPE_ns4__SetMeterIndications
#define SOAP_TYPE_ns4__SetMeterIndications (109)
/* complex XML schema type 'ns4:SetMeterIndications': */
struct SOAP_CMAC ns4__SetMeterIndications {
      public:
        /** Required element 'Bench' of XML schema type 'xsd:int' */
        int Bench;
        /** Required element 'TestName' of XML schema type 'xsd:string' */
        std::string TestName;
        /** Optional element 'MeterIndications' of XML schema type 'ArrayOfTMeterIndication' */
        TMeterIndications *MeterIndications;
      public:
        /** Return unique type id SOAP_TYPE_ns4__SetMeterIndications */
        long soap_type() const { return SOAP_TYPE_ns4__SetMeterIndications; }
        /** Constructor with member initializations */
        ns4__SetMeterIndications() : Bench(), TestName(), MeterIndications() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns4__SetMeterIndications * SOAP_FMAC2 soap_instantiate_ns4__SetMeterIndications(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* .\testbench.h:2083 */
#ifndef SOAP_TYPE_ns4__GetMeterPositionsResponse
#define SOAP_TYPE_ns4__GetMeterPositionsResponse (110)
/* complex XML schema type 'ns4:GetMeterPositionsResponse': */
struct SOAP_CMAC ns4__GetMeterPositionsResponse {
      public:
        /** Optional element 'return' of XML schema type 'ArrayOfboolean' */
        TBooleanDynArray *return_;
      public:
        /** Return unique type id SOAP_TYPE_ns4__GetMeterPositionsResponse */
        long soap_type() const { return SOAP_TYPE_ns4__GetMeterPositionsResponse; }
        /** Constructor with member initializations */
        ns4__GetMeterPositionsResponse() : return_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns4__GetMeterPositionsResponse * SOAP_FMAC2 soap_instantiate_ns4__GetMeterPositionsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* .\testbench.h:2147 */
#ifndef SOAP_TYPE_ns4__GetMeterPositions
#define SOAP_TYPE_ns4__GetMeterPositions (114)
/* complex XML schema type 'ns4:GetMeterPositions': */
struct SOAP_CMAC ns4__GetMeterPositions {
      public:
        /** Required element 'Bench' of XML schema type 'xsd:int' */
        int Bench;
      public:
        /** Return unique type id SOAP_TYPE_ns4__GetMeterPositions */
        long soap_type() const { return SOAP_TYPE_ns4__GetMeterPositions; }
        /** Constructor with member initializations */
        ns4__GetMeterPositions() : Bench() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns4__GetMeterPositions * SOAP_FMAC2 soap_instantiate_ns4__GetMeterPositions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* .\testbench.h:2158 */
#ifndef SOAP_TYPE_ns4__GetMeasurementDataResponse
#define SOAP_TYPE_ns4__GetMeasurementDataResponse (115)
/* complex XML schema type 'ns4:GetMeasurementDataResponse': */
struct SOAP_CMAC ns4__GetMeasurementDataResponse {
      public:
        /** Optional element 'return' of XML schema type 'ns3:TMeasurementData' */
        ns3__TMeasurementData *return_;
      public:
        /** Return unique type id SOAP_TYPE_ns4__GetMeasurementDataResponse */
        long soap_type() const { return SOAP_TYPE_ns4__GetMeasurementDataResponse; }
        /** Constructor with member initializations */
        ns4__GetMeasurementDataResponse() : return_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns4__GetMeasurementDataResponse * SOAP_FMAC2 soap_instantiate_ns4__GetMeasurementDataResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* .\testbench.h:2222 */
#ifndef SOAP_TYPE_ns4__GetMeasurementData
#define SOAP_TYPE_ns4__GetMeasurementData (119)
/* complex XML schema type 'ns4:GetMeasurementData': */
struct SOAP_CMAC ns4__GetMeasurementData {
      public:
        /** Required element 'Bench' of XML schema type 'xsd:int' */
        int Bench;
      public:
        /** Return unique type id SOAP_TYPE_ns4__GetMeasurementData */
        long soap_type() const { return SOAP_TYPE_ns4__GetMeasurementData; }
        /** Constructor with member initializations */
        ns4__GetMeasurementData() : Bench() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns4__GetMeasurementData * SOAP_FMAC2 soap_instantiate_ns4__GetMeasurementData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* .\testbench.h:2233 */
#ifndef SOAP_TYPE_ns4__GetTestResultsResponse
#define SOAP_TYPE_ns4__GetTestResultsResponse (120)
/* complex XML schema type 'ns4:GetTestResultsResponse': */
struct SOAP_CMAC ns4__GetTestResultsResponse {
      public:
        /** Optional element 'return' of XML schema type 'ns3:TTestResults' */
        ns3__TTestResults *return_;
      public:
        /** Return unique type id SOAP_TYPE_ns4__GetTestResultsResponse */
        long soap_type() const { return SOAP_TYPE_ns4__GetTestResultsResponse; }
        /** Constructor with member initializations */
        ns4__GetTestResultsResponse() : return_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns4__GetTestResultsResponse * SOAP_FMAC2 soap_instantiate_ns4__GetTestResultsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* .\testbench.h:2303 */
#ifndef SOAP_TYPE_ns4__GetTestResults
#define SOAP_TYPE_ns4__GetTestResults (124)
/* complex XML schema type 'ns4:GetTestResults': */
struct SOAP_CMAC ns4__GetTestResults {
      public:
        /** Required element 'Bench' of XML schema type 'xsd:int' */
        int Bench;
        /** Required element 'TestName' of XML schema type 'xsd:string' */
        std::string TestName;
        /** Optional element 'MetersPos' of XML schema type 'ArrayOfint' */
        TIntegerDynArray *MetersPos;
      public:
        /** Return unique type id SOAP_TYPE_ns4__GetTestResults */
        long soap_type() const { return SOAP_TYPE_ns4__GetTestResults; }
        /** Constructor with member initializations */
        ns4__GetTestResults() : Bench(), TestName(), MetersPos() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns4__GetTestResults * SOAP_FMAC2 soap_instantiate_ns4__GetTestResults(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* .\testbench.h:2314 */
#ifndef SOAP_TYPE_ns4__GetMeterResultResponse
#define SOAP_TYPE_ns4__GetMeterResultResponse (125)
/* complex XML schema type 'ns4:GetMeterResultResponse': */
struct SOAP_CMAC ns4__GetMeterResultResponse {
      public:
        /** Optional element 'return' of XML schema type 'ns3:TMeterResult' */
        ns3__TMeterResult *return_;
      public:
        /** Return unique type id SOAP_TYPE_ns4__GetMeterResultResponse */
        long soap_type() const { return SOAP_TYPE_ns4__GetMeterResultResponse; }
        /** Constructor with member initializations */
        ns4__GetMeterResultResponse() : return_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns4__GetMeterResultResponse * SOAP_FMAC2 soap_instantiate_ns4__GetMeterResultResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* .\testbench.h:2384 */
#ifndef SOAP_TYPE_ns4__GetMeterResult
#define SOAP_TYPE_ns4__GetMeterResult (128)
/* complex XML schema type 'ns4:GetMeterResult': */
struct SOAP_CMAC ns4__GetMeterResult {
      public:
        /** Required element 'Bench' of XML schema type 'xsd:int' */
        int Bench;
        /** Required element 'TestName' of XML schema type 'xsd:string' */
        std::string TestName;
        /** Required element 'MeterPos' of XML schema type 'xsd:int' */
        int MeterPos;
      public:
        /** Return unique type id SOAP_TYPE_ns4__GetMeterResult */
        long soap_type() const { return SOAP_TYPE_ns4__GetMeterResult; }
        /** Constructor with member initializations */
        ns4__GetMeterResult() : Bench(), TestName(), MeterPos() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns4__GetMeterResult * SOAP_FMAC2 soap_instantiate_ns4__GetMeterResult(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* .\testbench.h:2395 */
#ifndef SOAP_TYPE_ns4__GetTestResultResponse
#define SOAP_TYPE_ns4__GetTestResultResponse (129)
/* complex XML schema type 'ns4:GetTestResultResponse': */
struct SOAP_CMAC ns4__GetTestResultResponse {
      public:
        /** Optional element 'return' of XML schema type 'ns3:TTestResult' */
        ns3__TTestResult *return_;
      public:
        /** Return unique type id SOAP_TYPE_ns4__GetTestResultResponse */
        long soap_type() const { return SOAP_TYPE_ns4__GetTestResultResponse; }
        /** Constructor with member initializations */
        ns4__GetTestResultResponse() : return_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns4__GetTestResultResponse * SOAP_FMAC2 soap_instantiate_ns4__GetTestResultResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* .\testbench.h:2462 */
#ifndef SOAP_TYPE_ns4__GetTestResult
#define SOAP_TYPE_ns4__GetTestResult (133)
/* complex XML schema type 'ns4:GetTestResult': */
struct SOAP_CMAC ns4__GetTestResult {
      public:
        /** Required element 'Bench' of XML schema type 'xsd:int' */
        int Bench;
        /** Required element 'TestName' of XML schema type 'xsd:string' */
        std::string TestName;
      public:
        /** Return unique type id SOAP_TYPE_ns4__GetTestResult */
        long soap_type() const { return SOAP_TYPE_ns4__GetTestResult; }
        /** Constructor with member initializations */
        ns4__GetTestResult() : Bench(), TestName() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns4__GetTestResult * SOAP_FMAC2 soap_instantiate_ns4__GetTestResult(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* .\testbench.h:2473 */
#ifndef SOAP_TYPE_ns4__GetPressTestResultResponse
#define SOAP_TYPE_ns4__GetPressTestResultResponse (134)
/* complex XML schema type 'ns4:GetPressTestResultResponse': */
struct SOAP_CMAC ns4__GetPressTestResultResponse {
      public:
        /** Optional element 'return' of XML schema type 'ns3:TPressTestResult' */
        ns3__TPressTestResult *return_;
      public:
        /** Return unique type id SOAP_TYPE_ns4__GetPressTestResultResponse */
        long soap_type() const { return SOAP_TYPE_ns4__GetPressTestResultResponse; }
        /** Constructor with member initializations */
        ns4__GetPressTestResultResponse() : return_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns4__GetPressTestResultResponse * SOAP_FMAC2 soap_instantiate_ns4__GetPressTestResultResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* .\testbench.h:2540 */
#ifndef SOAP_TYPE_ns4__GetPressTestResult
#define SOAP_TYPE_ns4__GetPressTestResult (138)
/* complex XML schema type 'ns4:GetPressTestResult': */
struct SOAP_CMAC ns4__GetPressTestResult {
      public:
        /** Required element 'Bench' of XML schema type 'xsd:int' */
        int Bench;
        /** Required element 'TestName' of XML schema type 'xsd:string' */
        std::string TestName;
      public:
        /** Return unique type id SOAP_TYPE_ns4__GetPressTestResult */
        long soap_type() const { return SOAP_TYPE_ns4__GetPressTestResult; }
        /** Constructor with member initializations */
        ns4__GetPressTestResult() : Bench(), TestName() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns4__GetPressTestResult * SOAP_FMAC2 soap_instantiate_ns4__GetPressTestResult(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* .\testbench.h:2613 */
#ifndef SOAP_TYPE_ns4__GetTestConfigurationResponse
#define SOAP_TYPE_ns4__GetTestConfigurationResponse (141)
/* complex XML schema type 'ns4:GetTestConfigurationResponse': */
struct SOAP_CMAC ns4__GetTestConfigurationResponse {
      public:
        /** Required element 'return' of XML schema type 'xsd:string' */
        std::string return_;
      public:
        /** Return unique type id SOAP_TYPE_ns4__GetTestConfigurationResponse */
        long soap_type() const { return SOAP_TYPE_ns4__GetTestConfigurationResponse; }
        /** Constructor with member initializations */
        ns4__GetTestConfigurationResponse() : return_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns4__GetTestConfigurationResponse * SOAP_FMAC2 soap_instantiate_ns4__GetTestConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* .\testbench.h:2613 */
#ifndef SOAP_TYPE_ns4__GetTestConfiguration
#define SOAP_TYPE_ns4__GetTestConfiguration (142)
/* complex XML schema type 'ns4:GetTestConfiguration': */
struct SOAP_CMAC ns4__GetTestConfiguration {
      public:
        /** Required element 'Bench' of XML schema type 'xsd:int' */
        int Bench;
        /** Required element 'TestName' of XML schema type 'xsd:string' */
        std::string TestName;
      public:
        /** Return unique type id SOAP_TYPE_ns4__GetTestConfiguration */
        long soap_type() const { return SOAP_TYPE_ns4__GetTestConfiguration; }
        /** Constructor with member initializations */
        ns4__GetTestConfiguration() : Bench(), TestName() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns4__GetTestConfiguration * SOAP_FMAC2 soap_instantiate_ns4__GetTestConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* .\testbench.h:2624 */
#ifndef SOAP_TYPE_ns4__SetTestConfigurationResponse
#define SOAP_TYPE_ns4__SetTestConfigurationResponse (143)
/* complex XML schema type 'ns4:SetTestConfigurationResponse': */
struct SOAP_CMAC ns4__SetTestConfigurationResponse {
      public:
        /** Required element 'return' of XML schema type 'ns3:TResult' */
        enum ns3__TResult return_;
      public:
        /** Return unique type id SOAP_TYPE_ns4__SetTestConfigurationResponse */
        long soap_type() const { return SOAP_TYPE_ns4__SetTestConfigurationResponse; }
        /** Constructor with member initializations */
        ns4__SetTestConfigurationResponse() : return_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns4__SetTestConfigurationResponse * SOAP_FMAC2 soap_instantiate_ns4__SetTestConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* .\testbench.h:2694 */
#ifndef SOAP_TYPE_ns4__SetTestConfiguration
#define SOAP_TYPE_ns4__SetTestConfiguration (146)
/* complex XML schema type 'ns4:SetTestConfiguration': */
struct SOAP_CMAC ns4__SetTestConfiguration {
      public:
        /** Required element 'Bench' of XML schema type 'xsd:int' */
        int Bench;
        /** Required element 'TestName' of XML schema type 'xsd:string' */
        std::string TestName;
        /** Required element 'Configuration' of XML schema type 'xsd:string' */
        std::string Configuration;
      public:
        /** Return unique type id SOAP_TYPE_ns4__SetTestConfiguration */
        long soap_type() const { return SOAP_TYPE_ns4__SetTestConfiguration; }
        /** Constructor with member initializations */
        ns4__SetTestConfiguration() : Bench(), TestName(), Configuration() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns4__SetTestConfiguration * SOAP_FMAC2 soap_instantiate_ns4__SetTestConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* .\testbench.h:2761 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (147)
/* SOAP_ENV__Header: */
struct SOAP_CMAC SOAP_ENV__Header {
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Header */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Header; }
        /** Constructor with member initializations */
        SOAP_ENV__Header() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* .\testbench.h:2761 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (148)
/* Type SOAP_ENV__Code is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* SOAP_ENV__Code: */
struct SOAP_CMAC SOAP_ENV__Code {
      public:
        /** Optional element 'SOAP-ENV:Value' of XML schema type 'xsd:QName' */
        char *SOAP_ENV__Value;
        /** Optional element 'SOAP-ENV:Subcode' of XML schema type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Subcode;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Code */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Code; }
        /** Constructor with member initializations */
        SOAP_ENV__Code() : SOAP_ENV__Value(), SOAP_ENV__Subcode() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* .\testbench.h:2761 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (150)
/* SOAP_ENV__Detail: */
struct SOAP_CMAC SOAP_ENV__Detail {
      public:
        char *__any;
        /** Any type of element 'fault' assigned to fault with its SOAP_TYPE_<typename> assigned to __type */
        /** Do not create a cyclic data structure through this member unless SOAP encoding or SOAP_XML_GRAPH are used for id-ref serialization */
        int __type;
        void *fault;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Detail */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Detail; }
        /** Constructor with member initializations */
        SOAP_ENV__Detail() : __any(), __type(), fault() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* .\testbench.h:2761 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (153)
/* SOAP_ENV__Reason: */
struct SOAP_CMAC SOAP_ENV__Reason {
      public:
        /** Optional element 'SOAP-ENV:Text' of XML schema type 'xsd:string' */
        char *SOAP_ENV__Text;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Reason */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Reason; }
        /** Constructor with member initializations */
        SOAP_ENV__Reason() : SOAP_ENV__Text() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* .\testbench.h:2761 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (154)
/* SOAP_ENV__Fault: */
struct SOAP_CMAC SOAP_ENV__Fault {
      public:
        /** Optional element 'faultcode' of XML schema type 'xsd:QName' */
        char *faultcode;
        /** Optional element 'faultstring' of XML schema type 'xsd:string' */
        char *faultstring;
        /** Optional element 'faultactor' of XML schema type 'xsd:string' */
        char *faultactor;
        /** Optional element 'detail' of XML schema type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *detail;
        /** Optional element 'SOAP-ENV:Code' of XML schema type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Code;
        /** Optional element 'SOAP-ENV:Reason' of XML schema type 'SOAP-ENV:Reason' */
        struct SOAP_ENV__Reason *SOAP_ENV__Reason;
        /** Optional element 'SOAP-ENV:Node' of XML schema type 'xsd:string' */
        char *SOAP_ENV__Node;
        /** Optional element 'SOAP-ENV:Role' of XML schema type 'xsd:string' */
        char *SOAP_ENV__Role;
        /** Optional element 'SOAP-ENV:Detail' of XML schema type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *SOAP_ENV__Detail;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Fault */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Fault; }
        /** Constructor with member initializations */
        SOAP_ENV__Fault() : faultcode(), faultstring(), faultactor(), detail(), SOAP_ENV__Code(), SOAP_ENV__Reason(), SOAP_ENV__Node(), SOAP_ENV__Role(), SOAP_ENV__Detail() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/


/* (built-in):0 */
#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (5)
typedef char *_XML;
#endif

/* (built-in):0 */
#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (6)
typedef char *_QName;
#endif

/******************************************************************************\
 *                                                                            *
 * Serializable Types                                                         *
 *                                                                            *
\******************************************************************************/


/* char has binding name 'byte' for type 'xsd:byte' */
#ifndef SOAP_TYPE_byte
#define SOAP_TYPE_byte (3)
#endif

/* int has binding name 'int' for type 'xsd:int' */
#ifndef SOAP_TYPE_int
#define SOAP_TYPE_int (1)
#endif

/* double has binding name 'double' for type 'xsd:double' */
#ifndef SOAP_TYPE_double
#define SOAP_TYPE_double (32)
#endif

/* bool has binding name 'bool' for type 'xsd:boolean' */
#ifndef SOAP_TYPE_bool
#define SOAP_TYPE_bool (34)
#endif

/* enum ns3__TPulseCheck has binding name 'ns3__TPulseCheck' for type 'ns3:TPulseCheck' */
#ifndef SOAP_TYPE_ns3__TPulseCheck
#define SOAP_TYPE_ns3__TPulseCheck (31)
#endif

/* enum ns3__TStatusCode has binding name 'ns3__TStatusCode' for type 'ns3:TStatusCode' */
#ifndef SOAP_TYPE_ns3__TStatusCode
#define SOAP_TYPE_ns3__TStatusCode (30)
#endif

/* enum ns3__TMeterIndicationMethod has binding name 'ns3__TMeterIndicationMethod' for type 'ns3:TMeterIndicationMethod' */
#ifndef SOAP_TYPE_ns3__TMeterIndicationMethod
#define SOAP_TYPE_ns3__TMeterIndicationMethod (29)
#endif

/* enum ns3__TProofMethod has binding name 'ns3__TProofMethod' for type 'ns3:TProofMethod' */
#ifndef SOAP_TYPE_ns3__TProofMethod
#define SOAP_TYPE_ns3__TProofMethod (28)
#endif

/* enum ns3__TResult has binding name 'ns3__TResult' for type 'ns3:TResult' */
#ifndef SOAP_TYPE_ns3__TResult
#define SOAP_TYPE_ns3__TResult (27)
#endif

/* std::string has binding name 'std__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_std__string
#define SOAP_TYPE_std__string (35)
#endif

/* ns3__TPressTestResult has binding name 'ns3__TPressTestResult' for type 'ns3:TPressTestResult' */
#ifndef SOAP_TYPE_ns3__TPressTestResult
#define SOAP_TYPE_ns3__TPressTestResult (26)
#endif

/* ns3__TTestResult has binding name 'ns3__TTestResult' for type 'ns3:TTestResult' */
#ifndef SOAP_TYPE_ns3__TTestResult
#define SOAP_TYPE_ns3__TTestResult (25)
#endif

/* ns3__TMeterResult has binding name 'ns3__TMeterResult' for type 'ns3:TMeterResult' */
#ifndef SOAP_TYPE_ns3__TMeterResult
#define SOAP_TYPE_ns3__TMeterResult (24)
#endif

/* TMeterResults has binding name 'TMeterResults' for type 'ns3:TMeterResult' */
#ifndef SOAP_TYPE_TMeterResults
#define SOAP_TYPE_TMeterResults (23)
#endif

/* ns3__TTestResults has binding name 'ns3__TTestResults' for type 'ns3:TTestResults' */
#ifndef SOAP_TYPE_ns3__TTestResults
#define SOAP_TYPE_ns3__TTestResults (22)
#endif

/* ns3__TMeasurementData has binding name 'ns3__TMeasurementData' for type 'ns3:TMeasurementData' */
#ifndef SOAP_TYPE_ns3__TMeasurementData
#define SOAP_TYPE_ns3__TMeasurementData (21)
#endif

/* ns3__TMeterIndication has binding name 'ns3__TMeterIndication' for type 'ns3:TMeterIndication' */
#ifndef SOAP_TYPE_ns3__TMeterIndication
#define SOAP_TYPE_ns3__TMeterIndication (20)
#endif

/* TMeterIndications has binding name 'TMeterIndications' for type 'ns3:TMeterIndication' */
#ifndef SOAP_TYPE_TMeterIndications
#define SOAP_TYPE_TMeterIndications (19)
#endif

/* ns3__TMeterData has binding name 'ns3__TMeterData' for type 'ns3:TMeterData' */
#ifndef SOAP_TYPE_ns3__TMeterData
#define SOAP_TYPE_ns3__TMeterData (18)
#endif

/* TMetersData has binding name 'TMetersData' for type 'ns3:TMeterData' */
#ifndef SOAP_TYPE_TMetersData
#define SOAP_TYPE_TMetersData (17)
#endif

/* ns3__TStatus has binding name 'ns3__TStatus' for type 'ns3:TStatus' */
#ifndef SOAP_TYPE_ns3__TStatus
#define SOAP_TYPE_ns3__TStatus (16)
#endif

/* ns3__TWaitEvents has binding name 'ns3__TWaitEvents' for type 'ns3:TWaitEvents' */
#ifndef SOAP_TYPE_ns3__TWaitEvents
#define SOAP_TYPE_ns3__TWaitEvents (15)
#endif

/* ns3__TPressTestParameters has binding name 'ns3__TPressTestParameters' for type 'ns3:TPressTestParameters' */
#ifndef SOAP_TYPE_ns3__TPressTestParameters
#define SOAP_TYPE_ns3__TPressTestParameters (14)
#endif

/* ns3__TTestParameters has binding name 'ns3__TTestParameters' for type 'ns3:TTestParameters' */
#ifndef SOAP_TYPE_ns3__TTestParameters
#define SOAP_TYPE_ns3__TTestParameters (13)
#endif

/* TBooleanDynArray has binding name 'TBooleanDynArray' for type 'xsd:boolean' */
#ifndef SOAP_TYPE_TBooleanDynArray
#define SOAP_TYPE_TBooleanDynArray (12)
#endif

/* TIntegerDynArray has binding name 'TIntegerDynArray' for type 'xsd:int' */
#ifndef SOAP_TYPE_TIntegerDynArray
#define SOAP_TYPE_TIntegerDynArray (11)
#endif

/* TStringDynArray has binding name 'TStringDynArray' for type 'xsd:string' */
#ifndef SOAP_TYPE_TStringDynArray
#define SOAP_TYPE_TStringDynArray (10)
#endif

/* SOAP_ENC__Array has binding name 'SOAP_ENC__Array' for type 'SOAP-ENC:Array' */
#ifndef SOAP_TYPE_SOAP_ENC__Array
#define SOAP_TYPE_SOAP_ENC__Array (8)
#endif

/* struct SOAP_ENV__Fault has binding name 'SOAP_ENV__Fault' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (154)
#endif

/* struct SOAP_ENV__Reason has binding name 'SOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (153)
#endif

/* struct SOAP_ENV__Detail has binding name 'SOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (150)
#endif

/* struct SOAP_ENV__Code has binding name 'SOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (148)
#endif

/* struct SOAP_ENV__Header has binding name 'SOAP_ENV__Header' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (147)
#endif

/* struct ns4__SetTestConfiguration has binding name 'ns4__SetTestConfiguration' for type 'ns4:SetTestConfiguration' */
#ifndef SOAP_TYPE_ns4__SetTestConfiguration
#define SOAP_TYPE_ns4__SetTestConfiguration (146)
#endif

/* struct ns4__SetTestConfigurationResponse has binding name 'ns4__SetTestConfigurationResponse' for type 'ns4:SetTestConfigurationResponse' */
#ifndef SOAP_TYPE_ns4__SetTestConfigurationResponse
#define SOAP_TYPE_ns4__SetTestConfigurationResponse (143)
#endif

/* struct ns4__GetTestConfiguration has binding name 'ns4__GetTestConfiguration' for type 'ns4:GetTestConfiguration' */
#ifndef SOAP_TYPE_ns4__GetTestConfiguration
#define SOAP_TYPE_ns4__GetTestConfiguration (142)
#endif

/* struct ns4__GetTestConfigurationResponse has binding name 'ns4__GetTestConfigurationResponse' for type 'ns4:GetTestConfigurationResponse' */
#ifndef SOAP_TYPE_ns4__GetTestConfigurationResponse
#define SOAP_TYPE_ns4__GetTestConfigurationResponse (141)
#endif

/* struct ns4__GetPressTestResult has binding name 'ns4__GetPressTestResult' for type 'ns4:GetPressTestResult' */
#ifndef SOAP_TYPE_ns4__GetPressTestResult
#define SOAP_TYPE_ns4__GetPressTestResult (138)
#endif

/* struct ns4__GetPressTestResultResponse has binding name 'ns4__GetPressTestResultResponse' for type 'ns4:GetPressTestResultResponse' */
#ifndef SOAP_TYPE_ns4__GetPressTestResultResponse
#define SOAP_TYPE_ns4__GetPressTestResultResponse (134)
#endif

/* struct ns4__GetTestResult has binding name 'ns4__GetTestResult' for type 'ns4:GetTestResult' */
#ifndef SOAP_TYPE_ns4__GetTestResult
#define SOAP_TYPE_ns4__GetTestResult (133)
#endif

/* struct ns4__GetTestResultResponse has binding name 'ns4__GetTestResultResponse' for type 'ns4:GetTestResultResponse' */
#ifndef SOAP_TYPE_ns4__GetTestResultResponse
#define SOAP_TYPE_ns4__GetTestResultResponse (129)
#endif

/* struct ns4__GetMeterResult has binding name 'ns4__GetMeterResult' for type 'ns4:GetMeterResult' */
#ifndef SOAP_TYPE_ns4__GetMeterResult
#define SOAP_TYPE_ns4__GetMeterResult (128)
#endif

/* struct ns4__GetMeterResultResponse has binding name 'ns4__GetMeterResultResponse' for type 'ns4:GetMeterResultResponse' */
#ifndef SOAP_TYPE_ns4__GetMeterResultResponse
#define SOAP_TYPE_ns4__GetMeterResultResponse (125)
#endif

/* struct ns4__GetTestResults has binding name 'ns4__GetTestResults' for type 'ns4:GetTestResults' */
#ifndef SOAP_TYPE_ns4__GetTestResults
#define SOAP_TYPE_ns4__GetTestResults (124)
#endif

/* struct ns4__GetTestResultsResponse has binding name 'ns4__GetTestResultsResponse' for type 'ns4:GetTestResultsResponse' */
#ifndef SOAP_TYPE_ns4__GetTestResultsResponse
#define SOAP_TYPE_ns4__GetTestResultsResponse (120)
#endif

/* struct ns4__GetMeasurementData has binding name 'ns4__GetMeasurementData' for type 'ns4:GetMeasurementData' */
#ifndef SOAP_TYPE_ns4__GetMeasurementData
#define SOAP_TYPE_ns4__GetMeasurementData (119)
#endif

/* struct ns4__GetMeasurementDataResponse has binding name 'ns4__GetMeasurementDataResponse' for type 'ns4:GetMeasurementDataResponse' */
#ifndef SOAP_TYPE_ns4__GetMeasurementDataResponse
#define SOAP_TYPE_ns4__GetMeasurementDataResponse (115)
#endif

/* struct ns4__GetMeterPositions has binding name 'ns4__GetMeterPositions' for type 'ns4:GetMeterPositions' */
#ifndef SOAP_TYPE_ns4__GetMeterPositions
#define SOAP_TYPE_ns4__GetMeterPositions (114)
#endif

/* struct ns4__GetMeterPositionsResponse has binding name 'ns4__GetMeterPositionsResponse' for type 'ns4:GetMeterPositionsResponse' */
#ifndef SOAP_TYPE_ns4__GetMeterPositionsResponse
#define SOAP_TYPE_ns4__GetMeterPositionsResponse (110)
#endif

/* struct ns4__SetMeterIndications has binding name 'ns4__SetMeterIndications' for type 'ns4:SetMeterIndications' */
#ifndef SOAP_TYPE_ns4__SetMeterIndications
#define SOAP_TYPE_ns4__SetMeterIndications (109)
#endif

/* struct ns4__SetMeterIndicationsResponse has binding name 'ns4__SetMeterIndicationsResponse' for type 'ns4:SetMeterIndicationsResponse' */
#ifndef SOAP_TYPE_ns4__SetMeterIndicationsResponse
#define SOAP_TYPE_ns4__SetMeterIndicationsResponse (105)
#endif

/* struct ns4__GetMeterData has binding name 'ns4__GetMeterData' for type 'ns4:GetMeterData' */
#ifndef SOAP_TYPE_ns4__GetMeterData
#define SOAP_TYPE_ns4__GetMeterData (104)
#endif

/* struct ns4__GetMeterDataResponse has binding name 'ns4__GetMeterDataResponse' for type 'ns4:GetMeterDataResponse' */
#ifndef SOAP_TYPE_ns4__GetMeterDataResponse
#define SOAP_TYPE_ns4__GetMeterDataResponse (101)
#endif

/* struct ns4__GetMetersData has binding name 'ns4__GetMetersData' for type 'ns4:GetMetersData' */
#ifndef SOAP_TYPE_ns4__GetMetersData
#define SOAP_TYPE_ns4__GetMetersData (100)
#endif

/* struct ns4__GetMetersDataResponse has binding name 'ns4__GetMetersDataResponse' for type 'ns4:GetMetersDataResponse' */
#ifndef SOAP_TYPE_ns4__GetMetersDataResponse
#define SOAP_TYPE_ns4__GetMetersDataResponse (96)
#endif

/* struct ns4__SetMetersData has binding name 'ns4__SetMetersData' for type 'ns4:SetMetersData' */
#ifndef SOAP_TYPE_ns4__SetMetersData
#define SOAP_TYPE_ns4__SetMetersData (95)
#endif

/* struct ns4__SetMetersDataResponse has binding name 'ns4__SetMetersDataResponse' for type 'ns4:SetMetersDataResponse' */
#ifndef SOAP_TYPE_ns4__SetMetersDataResponse
#define SOAP_TYPE_ns4__SetMetersDataResponse (91)
#endif

/* struct ns4__GetStatus has binding name 'ns4__GetStatus' for type 'ns4:GetStatus' */
#ifndef SOAP_TYPE_ns4__GetStatus
#define SOAP_TYPE_ns4__GetStatus (90)
#endif

/* struct ns4__GetStatusResponse has binding name 'ns4__GetStatusResponse' for type 'ns4:GetStatusResponse' */
#ifndef SOAP_TYPE_ns4__GetStatusResponse
#define SOAP_TYPE_ns4__GetStatusResponse (86)
#endif

/* struct ns4__Continue has binding name 'ns4__Continue' for type 'ns4:Continue' */
#ifndef SOAP_TYPE_ns4__Continue
#define SOAP_TYPE_ns4__Continue (85)
#endif

/* struct ns4__ContinueResponse has binding name 'ns4__ContinueResponse' for type 'ns4:ContinueResponse' */
#ifndef SOAP_TYPE_ns4__ContinueResponse
#define SOAP_TYPE_ns4__ContinueResponse (82)
#endif

/* struct ns4__Stop has binding name 'ns4__Stop' for type 'ns4:Stop' */
#ifndef SOAP_TYPE_ns4__Stop
#define SOAP_TYPE_ns4__Stop (81)
#endif

/* struct ns4__StopResponse has binding name 'ns4__StopResponse' for type 'ns4:StopResponse' */
#ifndef SOAP_TYPE_ns4__StopResponse
#define SOAP_TYPE_ns4__StopResponse (78)
#endif

/* struct ns4__Start has binding name 'ns4__Start' for type 'ns4:Start' */
#ifndef SOAP_TYPE_ns4__Start
#define SOAP_TYPE_ns4__Start (77)
#endif

/* struct ns4__StartResponse has binding name 'ns4__StartResponse' for type 'ns4:StartResponse' */
#ifndef SOAP_TYPE_ns4__StartResponse
#define SOAP_TYPE_ns4__StartResponse (73)
#endif

/* struct ns4__SetPressTestParameters has binding name 'ns4__SetPressTestParameters' for type 'ns4:SetPressTestParameters' */
#ifndef SOAP_TYPE_ns4__SetPressTestParameters
#define SOAP_TYPE_ns4__SetPressTestParameters (72)
#endif

/* struct ns4__SetPressTestParametersResponse has binding name 'ns4__SetPressTestParametersResponse' for type 'ns4:SetPressTestParametersResponse' */
#ifndef SOAP_TYPE_ns4__SetPressTestParametersResponse
#define SOAP_TYPE_ns4__SetPressTestParametersResponse (69)
#endif

/* struct ns4__GetPressTestParameters has binding name 'ns4__GetPressTestParameters' for type 'ns4:GetPressTestParameters' */
#ifndef SOAP_TYPE_ns4__GetPressTestParameters
#define SOAP_TYPE_ns4__GetPressTestParameters (68)
#endif

/* struct ns4__GetPressTestParametersResponse has binding name 'ns4__GetPressTestParametersResponse' for type 'ns4:GetPressTestParametersResponse' */
#ifndef SOAP_TYPE_ns4__GetPressTestParametersResponse
#define SOAP_TYPE_ns4__GetPressTestParametersResponse (64)
#endif

/* struct ns4__SetTestParameters has binding name 'ns4__SetTestParameters' for type 'ns4:SetTestParameters' */
#ifndef SOAP_TYPE_ns4__SetTestParameters
#define SOAP_TYPE_ns4__SetTestParameters (63)
#endif

/* struct ns4__SetTestParametersResponse has binding name 'ns4__SetTestParametersResponse' for type 'ns4:SetTestParametersResponse' */
#ifndef SOAP_TYPE_ns4__SetTestParametersResponse
#define SOAP_TYPE_ns4__SetTestParametersResponse (60)
#endif

/* struct ns4__GetTestParameters has binding name 'ns4__GetTestParameters' for type 'ns4:GetTestParameters' */
#ifndef SOAP_TYPE_ns4__GetTestParameters
#define SOAP_TYPE_ns4__GetTestParameters (59)
#endif

/* struct ns4__GetTestParametersResponse has binding name 'ns4__GetTestParametersResponse' for type 'ns4:GetTestParametersResponse' */
#ifndef SOAP_TYPE_ns4__GetTestParametersResponse
#define SOAP_TYPE_ns4__GetTestParametersResponse (55)
#endif

/* struct ns4__NewMeasurement has binding name 'ns4__NewMeasurement' for type 'ns4:NewMeasurement' */
#ifndef SOAP_TYPE_ns4__NewMeasurement
#define SOAP_TYPE_ns4__NewMeasurement (54)
#endif

/* struct ns4__NewMeasurementResponse has binding name 'ns4__NewMeasurementResponse' for type 'ns4:NewMeasurementResponse' */
#ifndef SOAP_TYPE_ns4__NewMeasurementResponse
#define SOAP_TYPE_ns4__NewMeasurementResponse (51)
#endif

/* struct ns4__GetTypeList has binding name 'ns4__GetTypeList' for type 'ns4:GetTypeList' */
#ifndef SOAP_TYPE_ns4__GetTypeList
#define SOAP_TYPE_ns4__GetTypeList (50)
#endif

/* struct ns4__GetTypeListResponse has binding name 'ns4__GetTypeListResponse' for type 'ns4:GetTypeListResponse' */
#ifndef SOAP_TYPE_ns4__GetTypeListResponse
#define SOAP_TYPE_ns4__GetTypeListResponse (47)
#endif

/* struct SOAP_ENV__Reason * has binding name 'PointerToSOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Reason
#define SOAP_TYPE_PointerToSOAP_ENV__Reason (156)
#endif

/* struct SOAP_ENV__Detail * has binding name 'PointerToSOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Detail
#define SOAP_TYPE_PointerToSOAP_ENV__Detail (155)
#endif

/* struct SOAP_ENV__Code * has binding name 'PointerToSOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Code
#define SOAP_TYPE_PointerToSOAP_ENV__Code (149)
#endif

/* ns3__TPressTestResult * has binding name 'PointerTons3__TPressTestResult' for type 'ns3:TPressTestResult' */
#ifndef SOAP_TYPE_PointerTons3__TPressTestResult
#define SOAP_TYPE_PointerTons3__TPressTestResult (135)
#endif

/* ns3__TTestResult * has binding name 'PointerTons3__TTestResult' for type 'ns3:TTestResult' */
#ifndef SOAP_TYPE_PointerTons3__TTestResult
#define SOAP_TYPE_PointerTons3__TTestResult (130)
#endif

/* ns3__TTestResults * has binding name 'PointerTons3__TTestResults' for type 'ns3:TTestResults' */
#ifndef SOAP_TYPE_PointerTons3__TTestResults
#define SOAP_TYPE_PointerTons3__TTestResults (121)
#endif

/* ns3__TMeasurementData * has binding name 'PointerTons3__TMeasurementData' for type 'ns3:TMeasurementData' */
#ifndef SOAP_TYPE_PointerTons3__TMeasurementData
#define SOAP_TYPE_PointerTons3__TMeasurementData (116)
#endif

/* TBooleanDynArray * has binding name 'PointerToTBooleanDynArray' for type 'xsd:boolean' */
#ifndef SOAP_TYPE_PointerToTBooleanDynArray
#define SOAP_TYPE_PointerToTBooleanDynArray (111)
#endif

/* TMeterIndications * has binding name 'PointerToTMeterIndications' for type 'ns3:TMeterIndication' */
#ifndef SOAP_TYPE_PointerToTMeterIndications
#define SOAP_TYPE_PointerToTMeterIndications (106)
#endif

/* TIntegerDynArray * has binding name 'PointerToTIntegerDynArray' for type 'xsd:int' */
#ifndef SOAP_TYPE_PointerToTIntegerDynArray
#define SOAP_TYPE_PointerToTIntegerDynArray (97)
#endif

/* TMetersData * has binding name 'PointerToTMetersData' for type 'ns3:TMeterData' */
#ifndef SOAP_TYPE_PointerToTMetersData
#define SOAP_TYPE_PointerToTMetersData (92)
#endif

/* ns3__TStatus * has binding name 'PointerTons3__TStatus' for type 'ns3:TStatus' */
#ifndef SOAP_TYPE_PointerTons3__TStatus
#define SOAP_TYPE_PointerTons3__TStatus (87)
#endif

/* ns3__TWaitEvents * has binding name 'PointerTons3__TWaitEvents' for type 'ns3:TWaitEvents' */
#ifndef SOAP_TYPE_PointerTons3__TWaitEvents
#define SOAP_TYPE_PointerTons3__TWaitEvents (74)
#endif

/* ns3__TPressTestParameters * has binding name 'PointerTons3__TPressTestParameters' for type 'ns3:TPressTestParameters' */
#ifndef SOAP_TYPE_PointerTons3__TPressTestParameters
#define SOAP_TYPE_PointerTons3__TPressTestParameters (65)
#endif

/* ns3__TTestParameters * has binding name 'PointerTons3__TTestParameters' for type 'ns3:TTestParameters' */
#ifndef SOAP_TYPE_PointerTons3__TTestParameters
#define SOAP_TYPE_PointerTons3__TTestParameters (56)
#endif

/* ns3__TMeterResult ** has binding name 'PointerToPointerTons3__TMeterResult' for type 'ns3:TMeterResult' */
#ifndef SOAP_TYPE_PointerToPointerTons3__TMeterResult
#define SOAP_TYPE_PointerToPointerTons3__TMeterResult (46)
#endif

/* ns3__TMeterResult * has binding name 'PointerTons3__TMeterResult' for type 'ns3:TMeterResult' */
#ifndef SOAP_TYPE_PointerTons3__TMeterResult
#define SOAP_TYPE_PointerTons3__TMeterResult (45)
#endif

/* ns3__TMeterIndication ** has binding name 'PointerToPointerTons3__TMeterIndication' for type 'ns3:TMeterIndication' */
#ifndef SOAP_TYPE_PointerToPointerTons3__TMeterIndication
#define SOAP_TYPE_PointerToPointerTons3__TMeterIndication (44)
#endif

/* ns3__TMeterIndication * has binding name 'PointerTons3__TMeterIndication' for type 'ns3:TMeterIndication' */
#ifndef SOAP_TYPE_PointerTons3__TMeterIndication
#define SOAP_TYPE_PointerTons3__TMeterIndication (43)
#endif

/* ns3__TMeterData ** has binding name 'PointerToPointerTons3__TMeterData' for type 'ns3:TMeterData' */
#ifndef SOAP_TYPE_PointerToPointerTons3__TMeterData
#define SOAP_TYPE_PointerToPointerTons3__TMeterData (42)
#endif

/* ns3__TMeterData * has binding name 'PointerTons3__TMeterData' for type 'ns3:TMeterData' */
#ifndef SOAP_TYPE_PointerTons3__TMeterData
#define SOAP_TYPE_PointerTons3__TMeterData (41)
#endif

/* bool * has binding name 'PointerTobool' for type 'xsd:boolean' */
#ifndef SOAP_TYPE_PointerTobool
#define SOAP_TYPE_PointerTobool (40)
#endif

/* int * has binding name 'PointerToint' for type 'xsd:int' */
#ifndef SOAP_TYPE_PointerToint
#define SOAP_TYPE_PointerToint (39)
#endif

/* std::string * has binding name 'PointerTostd__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_PointerTostd__string
#define SOAP_TYPE_PointerTostd__string (38)
#endif

/* TMeterResults * has binding name 'PointerToTMeterResults' for type 'ns3:TMeterResult' */
#ifndef SOAP_TYPE_PointerToTMeterResults
#define SOAP_TYPE_PointerToTMeterResults (37)
#endif

/* TStringDynArray * has binding name 'PointerToTStringDynArray' for type 'xsd:string' */
#ifndef SOAP_TYPE_PointerToTStringDynArray
#define SOAP_TYPE_PointerToTStringDynArray (36)
#endif

/* char ** has binding name 'PointerTo_XML' for type '' */
#ifndef SOAP_TYPE_PointerTo_XML
#define SOAP_TYPE_PointerTo_XML (9)
#endif

/* _QName has binding name '_QName' for type 'xsd:QName' */
#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (6)
#endif

/* _XML has binding name '_XML' for type '' */
#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (5)
#endif

/* char * has binding name 'string' for type 'xsd:string' */
#ifndef SOAP_TYPE_string
#define SOAP_TYPE_string (4)
#endif

/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


#endif

/* End of soapStub.h */
